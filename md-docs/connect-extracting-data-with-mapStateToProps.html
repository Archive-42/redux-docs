<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>connect-extracting-data-with-mapStateToProps</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/prism.css"
    />

    <script
      async
      defer
      src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/prism.js"
    ></script>
  </head>
  <body>
    <h1 id="connect-extracting-data-with-mapstatetoprops">
      Connect: Extracting Data with
      <code class="language-js">mapStateToProps</code>
    </h1>
    <p>
      As the first argument passed in to
      <code class="language-js">connect</code>,
      <code class="language-js">mapStateToProps</code> is used for selecting the
      part of the data from the store that the connected component needs. It’s
      frequently referred to as just
      <code class="language-js">mapState</code> for short.
    </p>
    <ul>
      <li>It is called every time the store state changes.</li>
      <li>
        It receives the entire store state, and should return an object of data
        this component needs.
      </li>
    </ul>
    <h2 id="defining-mapstatetoprops">
      Defining <code class="language-js">mapStateToProps</code>
    </h2>
    <p>
      <code class="language-js">mapStateToProps</code> should be defined as a
      function:
    </p>
    <pre
      class="language-js"
    ><code class="language-js" >function mapStateToProps(state, ownProps?)</code></pre>
    <p>
      It should take a first argument called
      <code class="language-js">state</code>, optionally a second argument
      called <code class="language-js">ownProps</code>, and return a plain
      object containing the data that the connected component needs.
    </p>
    <p>
      This function should be passed as the first argument to
      <code class="language-js">connect</code>, and will be called every time
      when the Redux store state changes. If you do not wish to subscribe to the
      store, pass <code class="language-js">null</code> or
      <code class="language-js">undefined</code> to
      <code class="language-js">connect</code> in place of
      <code class="language-js">mapStateToProps</code>.
    </p>
    <p>
      <strong
        >It does not matter if a
        <code class="language-js">mapStateToProps</code> function is written
        using the <code class="language-js">function</code> keyword (<code
          class="language-js"
          >function mapState(state) { }</code
        >
        ) or as an arrow function (<code class="language-js"
          >const mapState = (state) =&gt; { }</code
        >
        )</strong
      >
      - it will work the same either way.
    </p>
    <h3 id="arguments">Arguments</h3>
    <ol type="1">
      <li>
        <strong><code class="language-js">state</code></strong>
      </li>
      <li>
        <strong><code class="language-js">ownProps</code> (optional)</strong>
      </li>
    </ol>
    <h4 id="state"><code class="language-js">state</code></h4>
    <p>
      The first argument to a
      <code class="language-js">mapStateToProps</code> function is the entire
      Redux store state (the same value returned by a call to
      <code class="language-js">store.getState()</code>). Because of this, the
      first argument is traditionally just called
      <code class="language-js">state</code>. (While you can give the argument
      any name you want, calling it <code class="language-js">store</code> would
      be incorrect - it’s the “state value”, not the “store instance”.)
    </p>
    <p>
      The <code class="language-js">mapStateToProps</code> function should
      always be written with at least
      <code class="language-js">state</code> passed in.
    </p>
    <pre class="language-js"><code class="language-js" >// TodoList.js

function mapStateToProps(state) {
  const { todos } = state
  return { todoList: todos.allIds }
}

export default connect(mapStateToProps)(TodoList)</code></pre>
    <h4 id="ownprops-optional">
      <code class="language-js">ownProps</code> (optional)
    </h4>
    <p>
      You may define the function with a second argument,
      <code class="language-js">ownProps</code>, if your component needs the
      data from its own props to retrieve data from the store. This argument
      will contain all of the props given to the wrapper component that was
      generated by <code class="language-js">connect</code>.
    </p>
    <pre class="language-js"><code class="language-js" >// Todo.js

function mapStateToProps(state, ownProps) {
  const { visibilityFilter } = state
  // ownProps would look like { &quot;id&quot; : 123 }
  const { id } = ownProps
  const todo = getTodoById(state, id)

  // component receives additionally:
  return { todo, visibilityFilter }
}

// Later, in your application, a parent component renders:
;&lt;ConnectedTodo id={123} /&gt;
// and your component receives props.id, props.todo, and props.visibilityFilter</code></pre>
    <p>
      You do not need to include values from
      <code class="language-js">ownProps</code> in the object returned from
      <code class="language-js">mapStateToProps</code>.
      <code class="language-js">connect</code> will automatically merge those
      different prop sources into a final set of props.
    </p>
    <h3 id="return">Return</h3>
    <p>
      Your <code class="language-js">mapStateToProps</code> function should
      return a plain object that contains the data the component needs:
    </p>
    <ul>
      <li>
        Each field in the object will become a prop for your actual component
      </li>
      <li>
        The values in the fields will be used to determine if your component
        needs to re-render
      </li>
    </ul>
    <p>For example:</p>
    <pre
      class="language-js"
    ><code class="language-js" >function mapStateToProps(state) {
  return {
    a: 42,
    todos: state.todos,
    filter: state.visibilityFilter,
  }
}

// component will receive: props.a, props.todos, and props.filter</code></pre>
    <blockquote>
      <p>
        Note: In advanced scenarios where you need more control over the
        rendering performance,
        <code class="language-js">mapStateToProps</code> can also return a
        function. In this case, that function will be used as the final
        <code class="language-js">mapStateToProps</code> for a particular
        component instance. This allows you to do per-instance memoization. See
        the
        <a href="../api/connect.md">Advanced Usage: Factory Functions</a>
        section of the docs for more details, as well as
        <a href="https://github.com/reduxjs/react-redux/pull/279">PR #279</a>
        and the tests it adds. Most apps never need this.
      </p>
    </blockquote>
    <h2 id="usage-guidelines">Usage Guidelines</h2>
    <h3 id="let-mapstatetoprops-reshape-the-data-from-the-store">
      Let <code class="language-js">mapStateToProps</code> Reshape the Data from
      the Store
    </h3>
    <p>
      <code class="language-js">mapStateToProps</code> functions can, and
      should, do a lot more than just
      <code class="language-js">return state.someSlice</code>.
      <strong
        >They have the responsibility of “re-shaping” store data as needed for
        that component.</strong
      >
      This may include returning a value as a specific prop name, combining
      pieces of data from different parts of the state tree, and transforming
      the store data in different ways.
    </p>
    <h3 id="use-selector-functions-to-extract-and-transform-data">
      Use Selector Functions to Extract and Transform Data
    </h3>
    <p>
      We highly encourage the use of “selector” functions to help encapsulate
      the process of extracting values from specific locations in the state
      tree. Memoized selector functions also play a key role in improving
      application performance (see the following sections in this page and the
      <a href="https://redux.js.org/recipes/computing-derived-data"
        >Advanced Usage: Computing Derived Data</a
      >
      page for more details on why and how to use selectors.)
    </p>
    <h3 id="mapstatetoprops-functions-should-be-fast">
      <code class="language-js">mapStateToProps</code> Functions Should Be Fast
    </h3>
    <p>
      Whenever the store changes, all of the
      <code class="language-js">mapStateToProps</code> functions of all of the
      connected components will run. Because of this, your
      <code class="language-js">mapStateToProps</code> functions should run as
      fast as possible. This also means that a slow
      <code class="language-js">mapStateToProps</code> function can be a
      potential bottleneck for your application.
    </p>
    <p>
      As part of the “re-shaping data” idea,
      <code class="language-js">mapStateToProps</code> functions frequently need
      to transform data in various ways (such as filtering an array, mapping an
      array of IDs to their corresponding objects, or extracting plain JS values
      from Immutable.js objects). These transformations can often be expensive,
      both in terms of cost to execute the transformation, and whether the
      component re-renders as a result. If performance is a concern, ensure that
      these transformations are only run if the input values have changed.
    </p>
    <h3 id="mapstatetoprops-functions-should-be-pure-and-synchronous">
      <code class="language-js">mapStateToProps</code> Functions Should Be Pure
      and Synchronous
    </h3>
    <p>
      Much like a Redux reducer, a
      <code class="language-js">mapStateToProps</code> function should always be
      100% pure and synchronous. It should only take
      <code class="language-js">state</code> (and
      <code class="language-js">ownProps</code>) as arguments, and return the
      data the component needs as props without mutating those arguments. It
      should <em>not</em> be used to trigger asynchronous behavior like AJAX
      calls for data fetching, and the functions should not be declared as
      <code class="language-js">async</code>.
    </p>
    <h2 id="mapstatetoprops-and-performance">
      <code class="language-js">mapStateToProps</code> and Performance
    </h2>
    <h3 id="return-values-determine-if-your-component-re-renders">
      Return Values Determine If Your Component Re-Renders
    </h3>
    <p>
      React Redux internally implements the
      <code class="language-js">shouldComponentUpdate</code> method such that
      the wrapper component re-renders precisely when the data your component
      needs has changed. By default, React Redux decides whether the contents of
      the object returned from
      <code class="language-js">mapStateToProps</code> are different using
      <code class="language-js">===</code> comparison (a “shallow equality”
      check) on each fields of the returned object. If any of the fields have
      changed, then your component will be re-rendered so it can receive the
      updated values as props. Note that returning a mutated object of the same
      reference is a common mistake that can result in your component not
      re-rendering when expected.
    </p>
    <p>
      To summarize the behavior of the component wrapped by
      <code class="language-js">connect</code> with
      <code class="language-js">mapStateToProps</code> to extract data from the
      store:
    </p>
    <table style="width: 99%">
      <colgroup>
        <col style="width: 17%" />
        <col style="width: 24%" />
        <col style="width: 57%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th></th>
          <th>
            <code class="language-js">(state) =&gt; stateProps</code>
          </th>
          <th>
            <code class="language-js">(state, ownProps) =&gt; stateProps</code>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><code class="language-js">mapStateToProps</code> runs when:</td>
          <td>store <code class="language-js">state</code> changes</td>
          <td>
            store <code class="language-js">state</code> changes<br />
            or<br />
            any field of <code class="language-js">ownProps</code> is different
          </td>
        </tr>
        <tr class="even">
          <td>component re-renders when:</td>
          <td>
            any field of <code class="language-js">stateProps</code> is
            different
          </td>
          <td>
            any field of <code class="language-js">stateProps</code> is
            different<br />
            or<br />
            any field of <code class="language-js">ownProps</code> is different
          </td>
        </tr>
      </tbody>
    </table>
    <h3 id="only-return-new-object-references-if-needed">
      Only Return New Object References If Needed
    </h3>
    <p>
      React Redux does shallow comparisons to see if the
      <code class="language-js">mapStateToProps</code> results have changed.
      It’s easy to accidentally return new object or array references every
      time, which would cause your component to re-render even if the data is
      actually the same.
    </p>
    <p>
      Many common operations result in new object or array references being
      created:
    </p>
    <ul>
      <li>
        Creating new arrays with
        <code class="language-js">someArray.map()</code> or
        <code class="language-js">someArray.filter()</code>
      </li>
      <li>Merging arrays with <code class="language-js">array.concat</code></li>
      <li>
        Selecting portion of an array with
        <code class="language-js">array.slice</code>
      </li>
      <li>
        Copying values with <code class="language-js">Object.assign</code>
      </li>
      <li>
        Copying values with the spread operator
        <code class="language-js">{ ...oldState, ...newData }</code>
      </li>
    </ul>
    <p>
      Put these operations in
      <a
        href="https://redux.js.org/recipes/computing-derived-data#creating-a-memoized-selector"
        >memoized selector functions</a
      >
      to ensure that they only run if the input values have changed. This will
      also ensure that if the input values <em>haven’t</em> changed,
      <code class="language-js">mapStateToProps</code> will still return the
      same result values as before, and
      <code class="language-js">connect</code> can skip re-rendering.
    </p>
    <h3 id="only-perform-expensive-operations-when-data-changes">
      Only Perform Expensive Operations When Data Changes
    </h3>
    <p>
      Transforming data can often be expensive (<em>and</em> usually results in
      new object references being created). In order for your
      <code class="language-js">mapStateToProps</code> function to be as fast as
      possible, you should only re-run these complex transformations when the
      relevant data has changed.
    </p>
    <p>There are a few ways to approach this:</p>
    <ul>
      <li>
        Some transformations could be calculated in an action creator or
        reducer, and the transformed data could be kept in the store
      </li>
      <li>
        Transformations can also be done in a component’s
        <code class="language-js">render()</code> method
      </li>
      <li>
        If the transformation does need to be done in a
        <code class="language-js">mapStateToProps</code> function, then we
        recommend using
        <a
          href="https://redux.js.org/recipes/computing-derived-data#creating-a-memoized-selector"
          >memoized selector functions</a
        >
        to ensure the transformation is only run when the input values have
        changed.
      </li>
    </ul>
    <h4 id="immutable.js-performance-concerns">
      Immutable.js Performance Concerns
    </h4>
    <p>
      Immutable.js author Lee Byron on Twitter
      <a href="https://twitter.com/leeb/status/746733697093668864?lang=en"
        >explicitly advises avoiding <code class="language-js">toJS</code> when
        performance is a concern</a
      >:
    </p>
    <blockquote>
      <p>
        Perf tip for #immutablejs: avoid .toJS() .toObject() and .toArray() all
        slow full-copy operations which render structural sharing useless.
      </p>
    </blockquote>
    <p>
      There’s several other performance concerns to take into consideration with
      Immutable.js - see the list of links at the end of this page for more
      information.
    </p>
    <h2 id="behavior-and-gotchas">Behavior and Gotchas</h2>
    <h3 id="mapstatetoprops-will-not-run-if-the-store-state-is-the-same">
      <code class="language-js">mapStateToProps</code> Will Not Run if the Store
      State is the Same
    </h3>
    <p>
      The wrapper component generated by
      <code class="language-js">connect</code> subscribes to the Redux store.
      Every time an action is dispatched, it calls
      <code class="language-js">store.getState()</code> and checks to see if
      <code class="language-js">lastState === currentState</code>. If the two
      state values are identical by reference, then it will <em>not</em> re-run
      your <code class="language-js">mapStateToProps</code> function, because it
      assumes that the rest of the store state hasn’t changed either.
    </p>
    <p>
      The Redux <code class="language-js">combineReducers</code> utility
      function tries to optimize for this. If none of the slice reducers
      returned a new value, then
      <code class="language-js">combineReducers</code> returns the old state
      object instead of a new one. This means that mutation in a reducer can
      lead to the root state object not being updated, and thus the UI won’t
      re-render.
    </p>
    <h3 id="the-number-of-declared-arguments-affects-behavior">
      The Number of Declared Arguments Affects Behavior
    </h3>
    <p>
      With just <code class="language-js">(state)</code>, the function runs
      whenever the root store state object is different. With
      <code class="language-js">(state, ownProps)</code>, it runs any time the
      store state is different and ALSO whenever the wrapper props have changed.
    </p>
    <p>
      This means that
      <strong
        >you should not add the
        <code class="language-js">ownProps</code> argument unless you actually
        need to use it</strong
      >, or your <code class="language-js">mapStateToProps</code> function will
      run more often than it needs to.
    </p>
    <p>
      There are some edge cases around this behavior.
      <strong
        >The number of mandatory arguments determines whether
        <code class="language-js">mapStateToProps</code> will receive
        <code class="language-js">ownProps</code></strong
      >.
    </p>
    <p>
      If the formal definition of the function contains one mandatory parameter,
      <code class="language-js">mapStateToProps</code> will <em>not</em> receive
      <code class="language-js">ownProps</code>:
    </p>
    <pre
      class="language-js"
    ><code class="language-js" >function mapStateToProps(state) {
  console.log(state) // state
  console.log(arguments[1]) // undefined
}
const mapStateToProps = (state, ownProps = {}) =&gt; {
  console.log(state) // state
  console.log(ownProps) // {}
}</code></pre>
    <p>
      It <em>will</em> receive <code class="language-js">ownProps</code> when
      the formal definition of the function contains zero or two mandatory
      parameters:
    </p>
    <pre
      class="language-js"
    ><code class="language-js" >function mapStateToProps(state, ownProps) {
  console.log(state) // state
  console.log(ownProps) // ownProps
}

function mapStateToProps() {
  console.log(arguments[0]) // state
  console.log(arguments[1]) // ownProps
}

function mapStateToProps(...args) {
  console.log(args[0]) // state
  console.log(args[1]) // ownProps
}</code></pre>
    <h2 id="links-and-references">Links and References</h2>
    <p><strong>Tutorials</strong></p>
    <ul>
      <li>
        <a
          href="https://blog.isquaredsoftware.com/2017/01/practical-redux-part-6-connected-lists-forms-and-performance/"
          >Practical Redux Series, Part 6: Connected Lists, Forms, and
          Performance</a
        >
      </li>
      <li>
        <a
          href="https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/"
          >Idiomatic Redux: Using Reselect Selectors for Encapsulation and
          Performance</a
        >
      </li>
    </ul>
    <p><strong>Performance</strong></p>
    <ul>
      <li>
        <a href="https://twitter.com/leeb/status/746733697093668864"
          >Lee Byron’s Tweet Suggesting to avoid
          <code class="language-js">toJS</code>,
          <code class="language-js">toArray</code> and
          <code class="language-js">toObject</code> for Performance</a
        >
      </li>
      <li>
        <a
          href="https://blog.rangle.io/react-and-redux-performance-with-reselect/"
          >Improving React and Redux performance with Reselect</a
        >
      </li>
      <li>
        <a
          href="https://github.com/markerikson/react-redux-links/blob/master/react-performance.md#immutable-data"
          >Immutable data performance links</a
        >
      </li>
    </ul>
    <p><strong>Q&amp;A</strong></p>
    <ul>
      <li>
        <a
          href="https://redux.js.org/faq/react-redux#why-is-my-component-re-rendering-too-often"
          >Why Is My Component Re-Rendering Too Often?</a
        >
      </li>
      <li>
        <a
          href="https://redux.js.org/faq/react-redux#why-isnt-my-component-re-rendering-or-my-mapstatetoprops-running"
          >Why isn’t my component re-rendering, or my mapStateToProps running</a
        >
      </li>
      <li>
        <a
          href="https://redux.js.org/faq/react-redux#how-can-i-speed-up-my-mapstatetoprops"
          >How can I speed up my mapStateToProps?</a
        >
      </li>
      <li>
        <a
          href="https://redux.js.org/faq/react-redux#should-i-only-connect-my-top-component-or-can-i-connect-multiple-components-in-my-tree"
          >Should I only connect my top component, or can I connect multiple
          components in my tree?</a
        >
      </li>
    </ul>
  </body>
</html>
