<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>usage-with-typescript</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}

  </style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/prism.css">

<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/prism.js">
</script>
    </head>
<body>
<h1 id="usage-with-typescript">Usage with TypeScript</h1>
<p>React Redux itself is currently written in plain JavaScript. However, it works well with static type systems such as TypeScript.</p>
<p>The React Redux type definitions are a separate <a href="https://npm.im/@types/react-redux">
<code class="language-js" >@types/react-redux</code> typedefs package</a> on NPM. In addition to typing the library functions, the types also export some helpers to make it easier to write typesafe interfaces between your Redux store and your React components.</p>
<p>
<strong>As of React Redux v7.2.3, the <code class="language-js" >react-redux</code> package has a dependency on <code class="language-js" >@types/react-redux</code>, so the type definitions will be automatically installed with the library</strong>. Otherwise, you’ll need to manually install them yourself ( <code class="language-js" >npm install @types/react-redux</code> ).</p>
<h2 id="standard-redux-toolkit-project-setup-with-typescript">Standard Redux Toolkit Project Setup with TypeScript</h2>
<p>We assume that a typical Redux project is using Redux Toolkit and React Redux together.</p>
<p>
<a href="https://redux-toolkit.js.org">Redux Toolkit</a> (RTK) is the standard approach for writing modern Redux logic. RTK is already written in TypeScript, and its API is designed to provide a good experience for TypeScript usage.</p>
<p>The <a href="https://github.com/reduxjs/cra-template-redux-typescript">Redux+TS template for Create-React-App</a> comes with a working example of these patterns already configured.</p>
<h3 id="define-root-state-and-dispatch-types">Define Root State and Dispatch Types</h3>
<p>Using <a href="https://redux-toolkit.js.org/api/configureStore">configureStore</a> should not need any additional typings. You will, however, want to extract the <code class="language-js" >RootState</code> type and the <code class="language-js" >Dispatch</code> type so that they can be referenced as needed. Inferring these types from the store itself means that they correctly update as you add more state slices or modify middleware settings.</p>
<p>Since those are types, it’s safe to export them directly from your store setup file such as <code class="language-js" >app/store.ts</code> and import them directly into other files.</p>
<p>```ts title=“app/store.ts” import { configureStore } from ‘<span class="citation" data-cites="reduxjs/toolkit">
<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>
</span>’ // …</p>
<p>const store = configureStore({ reducer: { posts: postsReducer, comments: commentsReducer, users: usersReducer, }, })</p>
<p>// highlight-start // Infer the <code class="language-js" >RootState</code> and <code class="language-js" >AppDispatch</code> types from the store itself export type RootState = ReturnType&lt;typeof store.getState&gt; // Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState} export type AppDispatch = typeof store.dispatch // highlight-end ```</p>
<h3 id="define-typed-hooks">Define Typed Hooks</h3>
<p>While it’s possible to import the <code class="language-js" >RootState</code> and <code class="language-js" >AppDispatch</code> types into each component, it’s better to <strong>create pre-typed versions of the <code class="language-js" >useDispatch</code> and <code class="language-js" >useSelector</code> hooks for usage in your application</strong>. This is important for a couple reasons:</p>
<ul>
<li>For <code class="language-js" >useSelector</code>, it saves you the need to type <code class="language-js" >(state: RootState)</code> every time</li>
<li>For <code class="language-js" >useDispatch</code>, the default <code class="language-js" >Dispatch</code> type does not know about thunks or other middleware. In order to correctly dispatch thunks, you need to use the specific customized <code class="language-js" >AppDispatch</code> type from the store that includes the thunk middleware types, and use that with <code class="language-js" >useDispatch</code>. Adding a pre-typed <code class="language-js" >useDispatch</code> hook keeps you from forgetting to import <code class="language-js" >AppDispatch</code> where it’s needed.</li>
</ul>
<p>Since these are actual variables, not types, it’s important to define them in a separate file such as <code class="language-js" >app/hooks.ts</code>, not the store setup file. This allows you to import them into any component file that needs to use the hooks, and avoids potential circular import dependency issues.</p>
<p>```ts title=“app/hooks.ts” import { TypedUseSelectorHook, useDispatch, useSelector } from ‘react-redux’ import type { RootState, AppDispatch } from ‘./store’</p>
<p>// highlight-start // Use throughout your app instead of plain <code class="language-js" >useDispatch</code> and <code class="language-js" >useSelector</code> export const useAppDispatch = () =&gt; useDispatch() export const useAppSelector: TypedUseSelectorHook = useSelector // highlight-end ```</p>
<h2 id="typing-hooks-manually">Typing Hooks Manually</h2>
<p>We recommend using the pre-typed <code class="language-js" >useAppSelector</code> and <code class="language-js" >useAppDispatch</code> hooks shown above. If you prefer not to use those, here is how to type the hooks by themselves.</p>
<h3 id="typing-the-useselector-hook">Typing the <code class="language-js" >useSelector</code> hook</h3>
<p>When writing selector functions for use with <code class="language-js" >useSelector</code>, you should explicitly define the type of the <code class="language-js" >state</code> parameter. TS should be able to then infer the return type of the selector, which will be reused as the return type of the <code class="language-js" >useSelector</code> hook:</p>
<pre class="language-js" >
<code class="language-js" >interface RootState {
  isOn: boolean
}

// TS infers type: (state: RootState) =&gt; boolean
const selectIsOn = (state: RootState) =&gt; state.isOn

// TS infers `isOn` is boolean
const isOn = useSelector(selectIsOn)</code>
</pre>
<p>This can also be done inline as well:</p>
<pre class="language-js" >
<code class="language-js" >const isOn = useSelector((state: RootState) =&gt; state.isOn)</code>
</pre>
<h3 id="typing-the-usedispatch-hook">Typing the <code class="language-js" >useDispatch</code> hook</h3>
<p>By default, the return value of <code class="language-js" >useDispatch</code> is the standard <code class="language-js" >Dispatch</code> type defined by the Redux core types, so no declarations are needed:</p>
<pre class="language-js" >
<code class="language-js" >const dispatch = useDispatch()</code>
</pre>
<p>If you have a customized version of the <code class="language-js" >Dispatch</code> type, you may use that type explicitly:</p>
<pre class="language-js" >
<code class="language-js" >// store.ts
export type AppDispatch = typeof store.dispatch

// MyComponent.tsx
const dispatch: AppDispatch = useDispatch()</code>
</pre>
<h2 id="typing-the-connect-higher-order-component">Typing the <code class="language-js" >connect</code> higher order component</h2>
<h3 id="inferring-the-connected-props-automatically">Inferring The Connected Props Automatically</h3>
<p>
<code class="language-js" >connect</code> consists of two functions that are called sequentially. The first function accepts <code class="language-js" >mapState</code> and <code class="language-js" >mapDispatch</code> as arguments, and returns a second function. The second function accepts the component to be wrapped, and returns a new wrapper component that passes down the props from <code class="language-js" >mapState</code> and <code class="language-js" >mapDispatch</code>. Normally, both functions are called together, like <code class="language-js" >connect(mapState, mapDispatch)(MyComponent)</code>.</p>
<p>As of v7.1.2, the <code class="language-js" >@types/react-redux</code> package exposes a helper type, <code class="language-js" >ConnectedProps</code>, that can extract the return types of <code class="language-js" >mapStateToProps</code> and <code class="language-js" >mapDispatchToProps</code> from the first function. This means that if you split the <code class="language-js" >connect</code> call into two steps, all of the “props from Redux” can be inferred automatically without having to write them by hand. While this approach may feel unusual if you’ve been using React-Redux for a while, it does simplify the type declarations considerably.</p>
<pre class="language-js" >
<code class="language-js" >import { connect, ConnectedProps } from &#39;react-redux&#39;

interface RootState {
  isOn: boolean
}

const mapState = (state: RootState) =&gt; ({
  isOn: state.isOn,
})

const mapDispatch = {
  toggleOn: () =&gt; ({ type: &#39;TOGGLE_IS_ON&#39; }),
}

const connector = connect(mapState, mapDispatch)

// The inferred type will look like:
// {isOn: boolean, toggleOn: () =&gt; void}
type PropsFromRedux = ConnectedProps&lt;typeof connector&gt;</code>
</pre>
<p>The return type of <code class="language-js" >ConnectedProps</code> can then be used to type your props object.</p>
<pre class="language-js" >
<code class="language-js" >interface Props extends PropsFromRedux {
  backgroundColor: string
}

const MyComponent = (props: Props) =&gt; (
  &lt;div style={{ backgroundColor: props.backgroundColor }}&gt;
    &lt;button onClick={props.toggleOn}&gt;
      Toggle is {props.isOn ? &#39;ON&#39; : &#39;OFF&#39;}
    &lt;/button&gt;
  &lt;/div&gt;
)

export default connector(MyComponent)</code>
</pre>
<p>Because types can be defined in any order, you can still declare your component before declaring the connector if you want.</p>
<pre class="language-js" >
<code class="language-js" >// alternately, declare `type Props = PropsFromRedux &amp; {backgroundColor: string}`
interface Props extends PropsFromRedux {
  backgroundColor: string;
}

const MyComponent = (props: Props) =&gt; /* same as above */

const connector = connect(/* same as above*/)

type PropsFromRedux = ConnectedProps&lt;typeof connector&gt;

export default connector(MyComponent)</code>
</pre>
<h3 id="manually-typing-connect">Manually Typing <code class="language-js" >connect</code>
</h3>
<p>The <code class="language-js" >connect</code> higher-order component is somewhat complex to type, because there are 3 sources of props: <code class="language-js" >mapStateToProps</code>, <code class="language-js" >mapDispatchToProps</code>, and props passed in from the parent component. Here’s a full example of what it looks like to do that manually.</p>
<pre class="language-js" >
<code class="language-js" >import { connect } from &#39;react-redux&#39;

interface StateProps {
  isOn: boolean
}

interface DispatchProps {
  toggleOn: () =&gt; void
}

interface OwnProps {
  backgroundColor: string
}

type Props = StateProps &amp; DispatchProps &amp; OwnProps

const mapState = (state: RootState) =&gt; ({
  isOn: state.isOn,
})

const mapDispatch = {
  toggleOn: () =&gt; ({ type: &#39;TOGGLE_IS_ON&#39; }),
}

const MyComponent = (props: Props) =&gt; (
  &lt;div style={{ backgroundColor: props.backgroundColor }}&gt;
    &lt;button onClick={props.toggleOn}&gt;
      Toggle is {props.isOn ? &#39;ON&#39; : &#39;OFF&#39;}
    &lt;/button&gt;
  &lt;/div&gt;
)

// Typical usage: `connect` is called after the component is defined
export default connect&lt;StateProps, DispatchProps, OwnProps&gt;(
  mapState,
  mapDispatch
)(MyComponent)</code>
</pre>
<p>It is also possible to shorten this somewhat, by inferring the types of <code class="language-js" >mapState</code> and <code class="language-js" >mapDispatch</code>:</p>
<pre class="language-js" >
<code class="language-js" >const mapState = (state: RootState) =&gt; ({
  isOn: state.isOn,
})

const mapDispatch = {
  toggleOn: () =&gt; ({ type: &#39;TOGGLE_IS_ON&#39; }),
}

type StateProps = ReturnType&lt;typeof mapState&gt;
type DispatchProps = typeof mapDispatch

type Props = StateProps &amp; DispatchProps &amp; OwnProps</code>
</pre>
<p>However, inferring the type of <code class="language-js" >mapDispatch</code> this way will break if it is defined as an object and also refers to thunks.</p>
<h2 id="recommendations">Recommendations</h2>
<p>The hooks API is generally simpler to use with static types. <strong>If you’re looking for the easiest solution for using static types with React-Redux, use the hooks API.</strong>
</p>
<p>If you’re using <code class="language-js" >connect</code>, <strong>we recommend using the <code class="language-js" >ConnectedProps&lt;T&gt;</code> approach for inferring the props from Redux</strong>, as that requires the fewest explicit type declarations.</p>
<h2 id="resources">Resources</h2>
<p>For additional information, see these additional resources:</p>
<ul>
<li>
<a href="https://redux.js.org/recipes/usage-with-typescript">Redux docs: Usage with TypeScript</a>: Examples of how to use Redux Toolkit, the Redux core, and React Redux with TypeScript</li>
<li>
<a href="https://redux-toolkit.js.org/tutorials/typescript">Redux Toolkit docs: TypeScript Quick start</a>: shows how to use RTK and the React-Redux hooks API with TypeScript</li>
<li>
<a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet">React+TypeScript Cheatsheet</a>: a comprehensive guide to using React with TypeScript</li>
<li>
<a href="https://github.com/piotrwitek/react-redux-typescript-guide">React + Redux in TypeScript Guide</a>: extensive information on patterns for using React and Redux with TypeScript</li>
</ul>
</body>
</html>
