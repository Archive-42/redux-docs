[
    {
        "label": "delete_nth",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "delete_nth_naive",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "flatten_iter",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "flatten",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "garage",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "josephus",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "longest_non_repeat_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "longest_non_repeat_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "get_longest_non_repeat_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "get_longest_non_repeat_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "Interval",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "merge_intervals",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "missing_ranges",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "move_zeros",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "plus_one_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "plus_one_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "plus_one_v3",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "rotate_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "rotate_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "rotate_v3",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "summarize_ranges",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "three_sum",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "two_sum",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "max_ones_index",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "trimmean",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "top_1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "limit",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "n_sum",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "DFA",
        "importPath": "algorithms.automata",
        "description": "algorithms.automata",
        "isExtraImport": true,
        "detail": "algorithms.automata",
        "documentation": {}
    },
    {
        "label": "add_operators",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute_iter",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "anagram",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "array_sum_combinations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "unique_array_sum_combinations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "combination_sum",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "get_factors",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "recursive_get_factors",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "find_words",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "generate_abbreviations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "generate_parenthesis_v1",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "generate_parenthesis_v2",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "letter_combinations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "palindromic_substrings",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "pattern_match",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute_unique",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute_recursive",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "subsets_unique",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "subsets",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "subsets_v2",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "count_islands",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "maze_search",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "shortest_distance_from_all_buildings",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "ladder_length",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "add_bitwise_operator",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "count_ones_iter",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "count_ones_recur",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "count_flips_to_convert",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "find_missing_number",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "find_missing_number2",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "flip_bit_longest_seq",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "is_power_of_two",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "reverse_bits",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "single_number",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "single_number2",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "single_number3",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "subsets",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "get_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "set_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "clear_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "update_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "int_to_bytes_big_endian",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "int_to_bytes_little_endian",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "bytes_big_endian_to_int",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "bytes_little_endian_to_int",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "swap_pair",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "find_difference",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "has_alternative_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "has_alternative_bit_fast",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "insert_one_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "insert_mult_bits",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "remove_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "binary_gap",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "HuffmanCoding",
        "importPath": "algorithms.compression.huffman_coding",
        "description": "algorithms.compression.huffman_coding",
        "isExtraImport": true,
        "detail": "algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "decode_rle",
        "importPath": "algorithms.compression.rle_compression",
        "description": "algorithms.compression.rle_compression",
        "isExtraImport": true,
        "detail": "algorithms.compression.rle_compression",
        "documentation": {}
    },
    {
        "label": "encode_rle",
        "importPath": "algorithms.compression.rle_compression",
        "description": "algorithms.compression.rle_compression",
        "isExtraImport": true,
        "detail": "algorithms.compression.rle_compression",
        "documentation": {}
    },
    {
        "label": "elias_gamma",
        "importPath": "algorithms.compression.elias",
        "description": "algorithms.compression.elias",
        "isExtraImport": true,
        "detail": "algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "elias_delta",
        "importPath": "algorithms.compression.elias",
        "description": "algorithms.compression.elias",
        "isExtraImport": true,
        "detail": "algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "get_factors",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "get_factors_iterative1",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "get_factors_iterative2",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "num_islands",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "pacific_atlantic",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "Sudoku",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "walls_and_gates",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "find_path",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "max_profit_naive",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "max_profit_optimized",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "climb_stairs",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "climb_stairs_optimized",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "count",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "combination_sum_topdown",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "combination_sum_bottom_up",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "edit_distance",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "egg_drop",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "fib_recursive",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "fib_list",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "fib_iter",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "hosoya_testing",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "house_robber",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "Job",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "schedule",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "get_maximum_value",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence_optimized",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence_optimized2",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "int_divide",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "find_k_factor",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "planting_trees",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "Tarjan",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "check_bipartite",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "ford_fulkerson",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "edmonds_karp",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "dinic",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "maximum_flow_bfs",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "maximum_flow_dfs",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "all_pairs_shortest_path",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "bellman_ford",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "bellman_ford",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "count_connected_number_of_component",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "prims_minimum_spanning",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "Dijkstra",
        "importPath": "algorithms.graph.dijkstra",
        "description": "algorithms.graph.dijkstra",
        "isExtraImport": true,
        "detail": "algorithms.graph.dijkstra",
        "documentation": {}
    },
    {
        "label": "BinaryHeap",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "get_skyline",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "max_sliding_window",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "k_closest",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "get_histogram",
        "importPath": "algorithms.distribution.histogram",
        "description": "algorithms.distribution.histogram",
        "isExtraImport": true,
        "detail": "algorithms.distribution.histogram",
        "documentation": {}
    },
    {
        "label": "SegmentTree",
        "importPath": "algorithms.tree.segment_tree.iterative_segment_tree",
        "description": "algorithms.tree.segment_tree.iterative_segment_tree",
        "isExtraImport": true,
        "detail": "algorithms.tree.segment_tree.iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reverse_list",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "reverse_list_recursive",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "remove_range",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "swap_pairs",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "rotate_right",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_cyclic",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "merge_two_list",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "merge_two_list_recur",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_palindrome_stack",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_palindrome_dict",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "RandomListNode",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "copy_random_pointer_v1",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "copy_random_pointer_v2",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "ResizableHashTable",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "SeparateChainingHashTable",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "word_pattern",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "is_isomorphic",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "longest_palindromic_subsequence",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "power",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "power_recur",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "int_to_base",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "base_to_int",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "decimal_to_binary_ip",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "euler_totient",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "extended_gcd",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "factorial_recur",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "gcd",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "lcm",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "trailing_zero",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "gcd_bit",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "gen_strobogrammatic",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "strobogrammatic_in_range",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "is_strobogrammatic",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "is_strobogrammatic2",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "modular_inverse",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "modular_exponential",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_next_square",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_next_square2",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "prime_check",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "get_primes",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "pythagoras",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "encrypt",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "decrypt",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "combination",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "combination_memo",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "hailstone",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "magic_number",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_order",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_primitive_root",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "##-------------------------------------------------------------------\n\"\"\"\n    bob_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "##-------------------------------------------------------------------\n\"\"\"\n    num_digits",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "diffie_hellman_key_exchange",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "krishnamurthy_number",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "chinese_remainder_theorem",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "bomb_enemy",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "copy_transform",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "crout_matrix_decomposition",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "cholesky_matrix_decomposition",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "matrix_exponentiation",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "matrix_inversion",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "multiply",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "rotate_image",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sparse_dot_vector",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "spiral_traversal",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sudoku_validator",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sum_sub_squares",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sort_matrix_diagonally",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "distance",
        "importPath": "algorithms.ml.nearest_neighbor",
        "description": "algorithms.ml.nearest_neighbor",
        "isExtraImport": true,
        "detail": "algorithms.ml.nearest_neighbor",
        "documentation": {}
    },
    {
        "label": "nearest_neighbor",
        "importPath": "algorithms.ml.nearest_neighbor",
        "description": "algorithms.ml.nearest_neighbor",
        "isExtraImport": true,
        "detail": "algorithms.ml.nearest_neighbor",
        "documentation": {}
    },
    {
        "label": "Monomial",
        "importPath": "algorithms.maths.polynomial",
        "description": "algorithms.maths.polynomial",
        "isExtraImport": true,
        "detail": "algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "importPath": "algorithms.maths.polynomial",
        "description": "algorithms.maths.polynomial",
        "isExtraImport": true,
        "detail": "algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "Monomial",
        "importPath": "algorithms.maths.polynomial",
        "description": "algorithms.maths.polynomial",
        "isExtraImport": true,
        "detail": "algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ArrayQueue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "LinkedListQueue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "max_sliding_window",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "reconstruct_queue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "PriorityQueue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "binary_search_recur",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "ternary_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "first_occurrence",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "last_occurrence",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_insert",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "two_sum",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "two_sum1",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "two_sum2",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_range",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "find_min_rotate",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "find_min_rotate_recur",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_rotate",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_rotate_recur",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "jump_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter_v1",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter_v2",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "interpolation_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "find_keyboard_row",
        "importPath": "algorithms.set",
        "description": "algorithms.set",
        "isExtraImport": true,
        "detail": "algorithms.set",
        "documentation": {}
    },
    {
        "label": "bitonic_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "bogo_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "bubble_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "comb_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "counting_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "cycle_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "max_heap_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "min_heap_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "merge_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "pancake_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "pigeonhole_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "quick_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "selection_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "bucket_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "shell_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "radix_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "gnome_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "cocktail_shaker_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "top_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "top_sort_recursive",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "first_is_consecutive",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "second_is_consecutive",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "remove_min",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "first_stutter",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "second_stutter",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "first_switch_pairs",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "second_switch_pairs",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "simplify_path",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "ArrayStack",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "LinkedListStack",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "OrderedStack",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "misras_gries",
        "importPath": "algorithms.streaming.misra_gries",
        "description": "algorithms.streaming.misra_gries",
        "isExtraImport": true,
        "detail": "algorithms.streaming.misra_gries",
        "documentation": {}
    },
    {
        "label": "one_sparse",
        "importPath": "algorithms.streaming",
        "description": "algorithms.streaming",
        "isExtraImport": true,
        "detail": "algorithms.streaming",
        "documentation": {}
    },
    {
        "label": "add_binary",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "match_symbol",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "match_symbol_1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "bracket",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "decode_string",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "delete_reoccurring_characters",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "domain_name_1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "domain_name_2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "encode",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "group_anagrams",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "int_to_roman",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_reverse",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_two_pointer",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_stack",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_deque",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_rotated",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_rotated_v1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "license_number",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "make_sentence",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_merge_recursive",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_merge_iterative",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "multiply",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_one_edit",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_one_edit2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "rabin_karp",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "ultra_pythonic",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "iterative",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "recursive",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "pythonic",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "reverse_vowel",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "reverse_words",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "roman_to_int",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strip_url_params1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strip_url_params2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strip_url_params3",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_0",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_regular_expression",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "word_squares",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "convert_morse_word",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "unique_morse",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "judge_circle",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strong_password",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "check_pangram",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "contain_string",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "count_binary_substring",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "repeat_string",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "text_justification",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "min_distance",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "##-------------------------------------------------------------------\n\"\"\"\n    rotate",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "first_unique_char",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "repeat_substring",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "atbash",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_palindrome",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "knuth_morris_pratt",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "panagram",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "preorder",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "preorder_rec",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "postorder",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "postorder_rec",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "inorder",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "inorder_rec",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "BTree",
        "importPath": "algorithms.tree.b_tree",
        "description": "algorithms.tree.b_tree",
        "isExtraImport": true,
        "detail": "algorithms.tree.b_tree",
        "documentation": {}
    },
    {
        "label": "construct_tree_postorder_preorder",
        "importPath": "algorithms.tree",
        "description": "algorithms.tree",
        "isExtraImport": true,
        "detail": "algorithms.tree",
        "documentation": {}
    },
    {
        "label": "Fenwick_Tree",
        "importPath": "algorithms.tree.fenwick_tree.fenwick_tree",
        "description": "algorithms.tree.fenwick_tree.fenwick_tree",
        "isExtraImport": true,
        "detail": "algorithms.tree.fenwick_tree.fenwick_tree",
        "documentation": {}
    },
    {
        "label": "join_with_slash",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "full_path",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "simplify_path_v1",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "simplify_path_v2",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "TestJosephus",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestJosephus(unittest.TestCase):\n    def test_josephus(self):\n        a = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n        josephus_generator = josephus(a, 3)\n        self.assertEqual(next(josephus_generator), \"3\")\n        self.assertEqual(next(josephus_generator), \"6\")\n        self.assertEqual(next(josephus_generator), \"9\")\n        self.assertEqual(next(josephus_generator), \"4\")\n        self.assertEqual(next(josephus_generator), \"8\")\n        self.assertEqual(next(josephus_generator), \"5\")",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestDeleteNth",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestDeleteNth(unittest.TestCase):\n    def test_delete_nth_naive(self):\n        self.assertListEqual(\n            delete_nth_naive([20, 37, 20, 21, 37, 21, 21], n=1), [20, 37, 21]\n        )\n        self.assertListEqual(\n            delete_nth_naive([1, 1, 3, 3, 7, 2, 2, 2, 2], n=3), [1, 1, 3, 3, 7, 2, 2, 2]\n        )\n        self.assertListEqual(\n            delete_nth_naive([1, 2, 3, 1, 1, 2, 1, 2, 3, 3, 2, 4, 5, 3, 1], n=3),",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestFlatten",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestFlatten(unittest.TestCase):\n    def test_flatten(self):\n        nested_list = [2, 1, [3, [4, 5], 6], 7, [8]]\n        flattened = flatten(nested_list)\n        self.assertEqual(flattened, [2, 1, 3, 4, 5, 6, 7, 8])\n        nested_list = [[3, [4, 5], 6], 7, [8]]\n        flattened = flatten(nested_list)\n        self.assertEqual(flattened, [3, 4, 5, 6, 7, 8])\n        nested_list = [[], [8]]\n        flattened = flatten(nested_list)",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestGarage",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestGarage(unittest.TestCase):\n    def test_garage(self):\n        initial = [1, 2, 3, 0, 4]\n        final = [0, 3, 2, 1, 4]\n        steps, seq = garage(initial, final)\n        self.assertEqual(steps, 4)\n        self.assertListEqual(\n            seq, [[0, 2, 3, 1, 4], [2, 0, 3, 1, 4], [2, 3, 0, 1, 4], [0, 3, 2, 1, 4]]\n        )\nclass TestLongestNonRepeat(unittest.TestCase):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestLongestNonRepeat",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestLongestNonRepeat(unittest.TestCase):\n    def test_longest_non_repeat_v1(self):\n        string = \"abcabcbb\"\n        self.assertEqual(longest_non_repeat_v1(string), 3)\n        string = \"bbbbb\"\n        self.assertEqual(longest_non_repeat_v1(string), 1)\n        string = \"pwwkew\"\n        self.assertEqual(longest_non_repeat_v1(string), 3)\n        string = \"dvdf\"\n        self.assertEqual(longest_non_repeat_v1(string), 3)",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMaxOnesIndex",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMaxOnesIndex(unittest.TestCase):\n    def test_max_ones_index(self):\n        self.assertEqual(9, max_ones_index([1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1]))\n        self.assertEqual(3, max_ones_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]))\n        self.assertEqual(-1, max_ones_index([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\nclass TestMergeInterval(unittest.TestCase):\n    def test_merge(self):\n        interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]\n        intervals = [Interval(i[0], i[1]) for i in interval_list]\n        merged_intervals = Interval.merge(intervals)",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMergeInterval",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMergeInterval(unittest.TestCase):\n    def test_merge(self):\n        interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]\n        intervals = [Interval(i[0], i[1]) for i in interval_list]\n        merged_intervals = Interval.merge(intervals)\n        self.assertEqual(\n            merged_intervals, [Interval(1, 6), Interval(8, 10), Interval(15, 18)]\n        )\n    def test_merge_intervals(self):\n        interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMissingRanges",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMissingRanges(unittest.TestCase):\n    def test_missing_ranges(self):\n        arr = [3, 5, 10, 11, 12, 15, 19]\n        self.assertListEqual(\n            missing_ranges(arr, 0, 20),\n            [(0, 2), (4, 4), (6, 9), (13, 14), (16, 18), (20, 20)],\n        )\n        self.assertListEqual(\n            missing_ranges(arr, 6, 100), [(6, 9), (13, 14), (16, 18), (20, 100)]\n        )",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMoveZeros",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMoveZeros(unittest.TestCase):\n    def test_move_zeros(self):\n        self.assertListEqual(\n            move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \"a\"]),\n            [False, 1, 1, 2, 1, 3, \"a\", 0, 0],\n        )\n        self.assertListEqual(\n            move_zeros([0, 34, \"rahul\", [], None, 0, True, 0]),\n            [34, \"rahul\", [], None, True, 0, 0, 0],\n        )",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestPlusOne",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestPlusOne(unittest.TestCase):\n    def test_plus_one_v1(self):\n        self.assertListEqual(plus_one_v1([0]), [1])\n        self.assertListEqual(plus_one_v1([9]), [1, 0])\n        self.assertListEqual(plus_one_v1([1, 0, 9]), [1, 1, 0])\n        self.assertListEqual(plus_one_v1([9, 9, 8, 0, 0, 9]), [9, 9, 8, 0, 1, 0])\n        self.assertListEqual(plus_one_v1([9, 9, 9, 9]), [1, 0, 0, 0, 0])\n    def test_plus_one_v2(self):\n        self.assertListEqual(plus_one_v2([0]), [1])\n        self.assertListEqual(plus_one_v2([9]), [1, 0])",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestRotateArray",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestRotateArray(unittest.TestCase):\n    def test_rotate_v1(self):\n        self.assertListEqual(\n            rotate_v1([1, 2, 3, 4, 5, 6, 7], k=3), [5, 6, 7, 1, 2, 3, 4]\n        )\n        self.assertListEqual(\n            rotate_v1([1, 2, 3, 4, 5, 6, 7], k=1), [7, 1, 2, 3, 4, 5, 6]\n        )\n        self.assertListEqual(\n            rotate_v1([1, 2, 3, 4, 5, 6, 7], k=7), [1, 2, 3, 4, 5, 6, 7]",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestSummaryRanges",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestSummaryRanges(unittest.TestCase):\n    def test_summarize_ranges(self):\n        self.assertListEqual(\n            summarize_ranges([0, 1, 2, 4, 5, 7]), [(0, 2), (4, 5), (7, 7)]\n        )\n        self.assertListEqual(\n            summarize_ranges([-5, -4, -3, 1, 2, 4, 5, 6]), [(-5, -3), (1, 2), (4, 6)]\n        )\n        self.assertListEqual(summarize_ranges([-2, -1, 0, 1, 2]), [(-2, 2)])\nclass TestThreeSum(unittest.TestCase):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestThreeSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestThreeSum(unittest.TestCase):\n    def test_three_sum(self):\n        self.assertSetEqual(three_sum([-1, 0, 1, 2, -1, -4]), {(-1, 0, 1), (-1, -1, 2)})\n        self.assertSetEqual(\n            three_sum([-1, 3, 1, 2, -1, -4, -2]), {(-4, 1, 3), (-2, -1, 3), (-1, -1, 2)}\n        )\nclass TestTwoSum(unittest.TestCase):\n    def test_two_sum(self):\n        self.assertTupleEqual((0, 2), two_sum([2, 11, 7, 9], target=9))\n        self.assertTupleEqual((0, 3), two_sum([-3, 5, 2, 3, 8, -9], target=0))",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestTwoSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestTwoSum(unittest.TestCase):\n    def test_two_sum(self):\n        self.assertTupleEqual((0, 2), two_sum([2, 11, 7, 9], target=9))\n        self.assertTupleEqual((0, 3), two_sum([-3, 5, 2, 3, 8, -9], target=0))\n        self.assertIsNone(two_sum([-3, 5, 2, 3, 8, -9], target=6))\nclass TestTrimmean(unittest.TestCase):\n    def test_trimmean(self):\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20), 5.5)\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 20), 6.0)\nclass TestTop1(unittest.TestCase):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestTrimmean",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestTrimmean(unittest.TestCase):\n    def test_trimmean(self):\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20), 5.5)\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 20), 6.0)\nclass TestTop1(unittest.TestCase):\n    def test_top_1(self):\n        self.assertListEqual(top_1([1, 1, 2, 2, 3]), [1, 2])\n        self.assertListEqual(top_1([1, 2, 3, 324, 234, 23, 23, 1, 23, 23]), [23])\nclass TestLimit(unittest.TestCase):\n    def test_limit(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestTop1",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestTop1(unittest.TestCase):\n    def test_top_1(self):\n        self.assertListEqual(top_1([1, 1, 2, 2, 3]), [1, 2])\n        self.assertListEqual(top_1([1, 2, 3, 324, 234, 23, 23, 1, 23, 23]), [23])\nclass TestLimit(unittest.TestCase):\n    def test_limit(self):\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2, 4), [2, 3, 4])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2), [2, 3, 4, 5])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], None, 4), [1, 2, 3, 4])\nclass TestNSum(unittest.TestCase):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestLimit",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestLimit(unittest.TestCase):\n    def test_limit(self):\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2, 4), [2, 3, 4])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2), [2, 3, 4, 5])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], None, 4), [1, 2, 3, 4])\nclass TestNSum(unittest.TestCase):\n    def test_n_sum(self):\n        self.assertEqual(n_sum(2, [-3, 5, 2, 3, 8, -9], 6), [])  # noqa: E501\n        self.assertEqual(\n            n_sum(3, [-5, -4, -3, -2, -1, 0, 1, 2, 3], 0),",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestNSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestNSum(unittest.TestCase):\n    def test_n_sum(self):\n        self.assertEqual(n_sum(2, [-3, 5, 2, 3, 8, -9], 6), [])  # noqa: E501\n        self.assertEqual(\n            n_sum(3, [-5, -4, -3, -2, -1, 0, 1, 2, 3], 0),\n            sorted(\n                [\n                    [-5, 2, 3],\n                    [-2, 0, 2],\n                    [-4, 1, 3],",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestDFA",
        "kind": 6,
        "importPath": "algorithms.tests.test_automata",
        "description": "algorithms.tests.test_automata",
        "peekOfCode": "class TestDFA(unittest.TestCase):\n    def test_DFA(self):\n        transitions = {\"a\": {\"1\": \"a\", \"0\": \"b\"}, \"b\": {\"1\": \"b\", \"0\": \"a\"}}\n        final = [\"a\"]\n        start = \"a\"\n        self.assertEqual(False, DFA(transitions, start, final, \"000111100\"))\n        self.assertEqual(True, DFA(transitions, start, final, \"111000011\"))\n        transitions1 = {\n            \"0\": {\"0\": \"1\", \"1\": \"0\"},\n            \"1\": {\"0\": \"2\", \"1\": \"0\"},",
        "detail": "algorithms.tests.test_automata",
        "documentation": {}
    },
    {
        "label": "TestAddOperator",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestAddOperator(unittest.TestCase):\n    def test_add_operators(self):\n        # \"123\", 6 -> [\"1+2+3\", \"1*2*3\"]\n        s = \"123\"\n        target = 6\n        self.assertEqual(add_operators(s, target), [\"1+2+3\", \"1*2*3\"])\n        # \"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n        s = \"232\"\n        target = 8\n        self.assertEqual(add_operators(s, target), [\"2+3*2\", \"2*3+2\"])",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPermuteAndAnagram",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPermuteAndAnagram(unittest.TestCase):\n    def test_permute(self):\n        perms = [\"abc\", \"bac\", \"bca\", \"acb\", \"cab\", \"cba\"]\n        self.assertEqual(perms, permute(\"abc\"))\n    def test_permute_iter(self):\n        it = permute_iter(\"abc\")\n        perms = [\"abc\", \"bac\", \"bca\", \"acb\", \"cab\", \"cba\"]\n        for i in range(len(perms)):\n            self.assertEqual(perms[i], next(it))\n    def test_angram(self):",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestArrayCombinationSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestArrayCombinationSum(unittest.TestCase):\n    def test_array_sum_combinations(self):\n        A = [1, 2, 3, 3]\n        B = [2, 3, 3, 4]\n        C = [2, 3, 3, 4]\n        target = 7\n        answer = [\n            [1, 2, 4],\n            [1, 3, 3],\n            [1, 3, 3],",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestCombinationSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestCombinationSum(unittest.TestCase):\n    def check_sum(self, nums, target):\n        if sum(nums) == target:\n            return (True, nums)\n        else:\n            return (False, nums)\n    def test_combination_sum(self):\n        candidates1 = [2, 3, 6, 7]\n        target1 = 7\n        answer1 = [[2, 2, 3], [7]]",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestFactorCombinations",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestFactorCombinations(unittest.TestCase):\n    def test_get_factors(self):\n        target1 = 32\n        answer1 = [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]\n        self.assertEqual(sorted(get_factors(target1)), sorted(answer1))\n        target2 = 12\n        answer2 = [[2, 6], [2, 2, 3], [3, 4]]\n        self.assertEqual(sorted(get_factors(target2)), sorted(answer2))\n        self.assertEqual(sorted(get_factors(1)), [])\n        self.assertEqual(sorted(get_factors(37)), [])",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestFindWords",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestFindWords(unittest.TestCase):\n    def test_normal(self):\n        board = [\n            [\"o\", \"a\", \"a\", \"n\"],\n            [\"e\", \"t\", \"a\", \"e\"],\n            [\"i\", \"h\", \"k\", \"r\"],\n            [\"i\", \"f\", \"l\", \"v\"],\n        ]\n        words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n        self.assertEqual(find_words(board, words).sort(), [\"oath\", \"eat\"].sort())",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestGenerateAbbreviations",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestGenerateAbbreviations(unittest.TestCase):\n    def test_generate_abbreviations(self):\n        word1 = \"word\"\n        answer1 = [\n            \"word\",\n            \"wor1\",\n            \"wo1d\",\n            \"wo2\",\n            \"w1rd\",\n            \"w1r1\",",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPatternMatch",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPatternMatch(unittest.TestCase):\n    def test_pattern_match(self):\n        pattern1 = \"abab\"\n        string1 = \"redblueredblue\"\n        pattern2 = \"aaaa\"\n        string2 = \"asdasdasdasd\"\n        pattern3 = \"aabb\"\n        string3 = \"xyzabcxzyabc\"\n        self.assertTrue(pattern_match(pattern1, string1))\n        self.assertTrue(pattern_match(pattern2, string2))",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestGenerateParenthesis",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestGenerateParenthesis(unittest.TestCase):\n    def test_generate_parenthesis(self):\n        self.assertEqual(generate_parenthesis_v1(2), [\"()()\", \"(())\"])\n        self.assertEqual(\n            generate_parenthesis_v1(3),\n            [\"()()()\", \"()(())\", \"(())()\", \"(()())\", \"((()))\"],\n        )\n        self.assertEqual(generate_parenthesis_v2(2), [\"(())\", \"()()\"])\n        self.assertEqual(\n            generate_parenthesis_v2(3),",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestLetterCombinations",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestLetterCombinations(unittest.TestCase):\n    def test_letter_combinations(self):\n        digit1 = \"23\"\n        answer1 = [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n        self.assertEqual(sorted(letter_combinations(digit1)), sorted(answer1))\n        digit2 = \"34\"\n        answer2 = [\"dg\", \"dh\", \"di\", \"eg\", \"eh\", \"ei\", \"fg\", \"fh\", \"fi\"]\n        self.assertEqual(sorted(letter_combinations(digit2)), sorted(answer2))\nclass TestPalindromicSubstrings(unittest.TestCase):\n    def test_palindromic_substrings(self):",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPalindromicSubstrings",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPalindromicSubstrings(unittest.TestCase):\n    def test_palindromic_substrings(self):\n        string1 = \"abc\"\n        answer1 = [[\"a\", \"b\", \"c\"]]\n        self.assertEqual(palindromic_substrings(string1), sorted(answer1))\n        string2 = \"abcba\"\n        answer2 = [[\"abcba\"], [\"a\", \"bcb\", \"a\"], [\"a\", \"b\", \"c\", \"b\", \"a\"]]\n        self.assertEqual(sorted(palindromic_substrings(string2)), sorted(answer2))\n        string3 = \"abcccba\"\n        answer3 = [",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPermuteUnique",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPermuteUnique(unittest.TestCase):\n    def test_permute_unique(self):\n        nums1 = [1, 1, 2]\n        answer1 = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]\n        self.assertEqual(sorted(permute_unique(nums1)), sorted(answer1))\n        nums2 = [1, 2, 1, 3]\n        answer2 = [\n            [3, 1, 2, 1],\n            [1, 3, 2, 1],\n            [1, 2, 3, 1],",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPermute",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPermute(unittest.TestCase):\n    def test_permute(self):\n        nums1 = [1, 2, 3, 4]\n        answer1 = [\n            [1, 2, 3, 4],\n            [2, 1, 3, 4],\n            [2, 3, 1, 4],\n            [2, 3, 4, 1],\n            [1, 3, 2, 4],\n            [3, 1, 2, 4],",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestSubsetsUnique",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestSubsetsUnique(unittest.TestCase):\n    def test_subsets_unique(self):\n        nums1 = [1, 2, 2]\n        answer1 = [(1, 2), (1,), (1, 2, 2), (2,), (), (2, 2)]\n        self.assertEqual(sorted(subsets_unique(nums1)), sorted(answer1))\n        nums2 = [1, 2, 3, 4]\n        answer2 = [\n            (1, 2),\n            (1, 3),\n            (1, 2, 3, 4),",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestSubsets",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestSubsets(unittest.TestCase):\n    def test_subsets(self):\n        nums1 = [1, 2, 3]\n        answer1 = [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n        self.assertEqual(sorted(subsets(nums1)), sorted(answer1))\n        nums2 = [1, 2, 3, 4]\n        answer2 = [\n            [1, 2, 3, 4],\n            [1, 2, 3],\n            [1, 2, 4],",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestCountIslands",
        "kind": 6,
        "importPath": "algorithms.tests.test_bfs",
        "description": "algorithms.tests.test_bfs",
        "peekOfCode": "class TestCountIslands(unittest.TestCase):\n    def test_count_islands(self):\n        grid_1 = [[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]\n        self.assertEqual(1, count_islands(grid_1))\n        grid_2 = [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]\n        self.assertEqual(3, count_islands(grid_2))\n        grid_3 = [\n            [1, 1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 1],",
        "detail": "algorithms.tests.test_bfs",
        "documentation": {}
    },
    {
        "label": "TestMazeSearch",
        "kind": 6,
        "importPath": "algorithms.tests.test_bfs",
        "description": "algorithms.tests.test_bfs",
        "peekOfCode": "class TestMazeSearch(unittest.TestCase):\n    def test_maze_search(self):\n        grid_1 = [\n            [1, 0, 1, 1, 1, 1],\n            [1, 0, 1, 0, 1, 0],\n            [1, 0, 1, 0, 1, 1],\n            [1, 1, 1, 0, 1, 1],\n        ]\n        self.assertEqual(14, maze_search(grid_1))\n        grid_2 = [[1, 0, 0], [0, 1, 1], [0, 1, 1]]",
        "detail": "algorithms.tests.test_bfs",
        "documentation": {}
    },
    {
        "label": "TestWordLadder",
        "kind": 6,
        "importPath": "algorithms.tests.test_bfs",
        "description": "algorithms.tests.test_bfs",
        "peekOfCode": "class TestWordLadder(unittest.TestCase):\n    def test_ladder_length(self):\n        # hit -> hot -> dot -> dog -> cog\n        self.assertEqual(\n            5, ladder_length(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"])\n        )\n        # pick -> sick -> sink -> sank -> tank == 5\n        self.assertEqual(\n            5, ladder_length(\"pick\", \"tank\", [\"tock\", \"tick\", \"sank\", \"sink\", \"sick\"])\n        )",
        "detail": "algorithms.tests.test_bfs",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_bit",
        "description": "algorithms.tests.test_bit",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Initialize seed.\"\"\"\n        random.seed(\"test\")\n    def test_add_bitwise_operator(self):\n        self.assertEqual(5432 + 97823, add_bitwise_operator(5432, 97823))\n        self.assertEqual(0, add_bitwise_operator(0, 0))\n        self.assertEqual(10, add_bitwise_operator(10, 0))\n        self.assertEqual(10, add_bitwise_operator(0, 10))\n    def test_count_ones_recur(self):",
        "detail": "algorithms.tests.test_bit",
        "documentation": {}
    },
    {
        "label": "TestHuffmanCoding",
        "kind": 6,
        "importPath": "algorithms.tests.test_compression",
        "description": "algorithms.tests.test_compression",
        "peekOfCode": "class TestHuffmanCoding(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.file_in_name = \"huffman_coding_in.txt\"\n        cls.file_out_bin_name = \"huffman_coding_out.bin\"\n        cls.file_out_name = \"huffman_coding_out.txt\"\n    def setUp(self):\n        import random\n        random.seed(1951)\n        with open(self.file_in_name, \"wb\") as file_in:",
        "detail": "algorithms.tests.test_compression",
        "documentation": {}
    },
    {
        "label": "TestRLECompression",
        "kind": 6,
        "importPath": "algorithms.tests.test_compression",
        "description": "algorithms.tests.test_compression",
        "peekOfCode": "class TestRLECompression(unittest.TestCase):\n    def test_encode_rle(self):\n        self.assertEqual(\n            \"12W1B12W3B24W1B14W\",\n            encode_rle(\n                \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n            ),\n        )\n    def test_decode_rle(self):\n        self.assertEqual(",
        "detail": "algorithms.tests.test_compression",
        "documentation": {}
    },
    {
        "label": "TestEliasCoding",
        "kind": 6,
        "importPath": "algorithms.tests.test_compression",
        "description": "algorithms.tests.test_compression",
        "peekOfCode": "class TestEliasCoding(unittest.TestCase):\n    def test_elias_gamma(self):\n        correct_result = [\n            \"0\",\n            \"00\",\n            \"100\",\n            \"101\",\n            \"11000\",\n            \"11001\",\n            \"11010\",",
        "detail": "algorithms.tests.test_compression",
        "documentation": {}
    },
    {
        "label": "TestAllFactors",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestAllFactors(unittest.TestCase):\n    def test_get_factors(self):\n        self.assertEqual(\n            [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]],\n            get_factors(32),\n        )\n    def test_get_factors_iterative1(self):\n        self.assertEqual(\n            [[2, 16], [4, 8], [2, 2, 8], [2, 4, 4], [2, 2, 2, 4], [2, 2, 2, 2, 2]],\n            get_factors_iterative1(32),",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestCountIslands",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestCountIslands(unittest.TestCase):\n    def test_num_islands(self):\n        self.assertEqual(\n            1,\n            num_islands(\n                [[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]\n            ),\n        )\n        self.assertEqual(\n            3,",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestPacificAtlantic",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestPacificAtlantic(unittest.TestCase):\n    def test_pacific_atlantic(self):\n        self.assertEqual(\n            [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]],\n            pacific_atlantic(\n                [\n                    [1, 2, 2, 3, 5],\n                    [3, 2, 3, 4, 4],\n                    [2, 4, 5, 3, 1],\n                    [6, 7, 1, 4, 5],",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestSudoku",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestSudoku(unittest.TestCase):\n    def test_sudoku_solver(self):\n        board = [[\"5\", \"3\", \".\"], [\"6\", \".\", \".\"], [\".\", \"9\", \"8\"]]\n        test_obj = Sudoku(board, 3, 3)\n        test_obj.solve()\n        self.assertEqual(\n            [[\"5\", \"3\", \"1\"], [\"6\", \"1\", \"2\"], [\"1\", \"9\", \"8\"]], test_obj.board\n        )\nclass TestWallsAndGates(unittest.TestCase):\n    def test_walls_and_gates(self):",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestWallsAndGates",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestWallsAndGates(unittest.TestCase):\n    def test_walls_and_gates(self):\n        rooms = [\n            [float(\"inf\"), -1, 0, float(\"inf\")],\n            [float(\"inf\"), float(\"inf\"), float(\"inf\"), -1],\n            [float(\"inf\"), -1, float(\"inf\"), -1],\n            [0, -1, float(\"inf\"), float(\"inf\")],\n        ]\n        walls_and_gates(rooms)\n        self.assertEqual(",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestMazeSearch",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestMazeSearch(unittest.TestCase):\n    def test_maze_search(self):\n        maze_1 = [\n            [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],\n            [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],\n        ]\n        self.assertEqual(37, find_path(maze_1))\n        maze_2 = [\n            [1, 0, 1, 1, 1, 1],\n            [1, 0, 1, 0, 1, 0],",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestBuySellStock",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestBuySellStock(unittest.TestCase):\n    def test_max_profit_naive(self):\n        self.assertEqual(max_profit_naive([7, 1, 5, 3, 6, 4]), 5)\n        self.assertEqual(max_profit_naive([7, 6, 4, 3, 1]), 0)\n    def test_max_profit_optimized(self):\n        self.assertEqual(max_profit_optimized([7, 1, 5, 3, 6, 4]), 5)\n        self.assertEqual(max_profit_optimized([7, 6, 4, 3, 1]), 0)\nclass TestClimbingStairs(unittest.TestCase):\n    def test_climb_stairs(self):\n        self.assertEqual(climb_stairs(2), 2)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestClimbingStairs",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestClimbingStairs(unittest.TestCase):\n    def test_climb_stairs(self):\n        self.assertEqual(climb_stairs(2), 2)\n        self.assertEqual(climb_stairs(10), 89)\n    def test_climb_stairs_optimized(self):\n        self.assertEqual(climb_stairs_optimized(2), 2)\n        self.assertEqual(climb_stairs_optimized(10), 89)\nclass TestCoinChange(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(count([1, 2, 3], 4), 4)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestCoinChange",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestCoinChange(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(count([1, 2, 3], 4), 4)\n        self.assertEqual(count([2, 5, 3, 6], 10), 5)\nclass TestCombinationSum(unittest.TestCase):\n    def test_combination_sum_topdown(self):\n        self.assertEqual(combination_sum_topdown([1, 2, 3], 4), 7)\n    def test_combination_sum_bottom_up(self):\n        self.assertEqual(combination_sum_bottom_up([1, 2, 3], 4), 7)\nclass TestEditDistance(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestCombinationSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestCombinationSum(unittest.TestCase):\n    def test_combination_sum_topdown(self):\n        self.assertEqual(combination_sum_topdown([1, 2, 3], 4), 7)\n    def test_combination_sum_bottom_up(self):\n        self.assertEqual(combination_sum_bottom_up([1, 2, 3], 4), 7)\nclass TestEditDistance(unittest.TestCase):\n    def test_edit_distance(self):\n        self.assertEqual(edit_distance(\"food\", \"money\"), 4)\n        self.assertEqual(edit_distance(\"horse\", \"ros\"), 3)\nclass TestEggDrop(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestEditDistance",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestEditDistance(unittest.TestCase):\n    def test_edit_distance(self):\n        self.assertEqual(edit_distance(\"food\", \"money\"), 4)\n        self.assertEqual(edit_distance(\"horse\", \"ros\"), 3)\nclass TestEggDrop(unittest.TestCase):\n    def test_egg_drop(self):\n        self.assertEqual(egg_drop(1, 2), 2)\n        self.assertEqual(egg_drop(2, 6), 3)\n        self.assertEqual(egg_drop(3, 14), 4)\nclass TestFib(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestEggDrop",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestEggDrop(unittest.TestCase):\n    def test_egg_drop(self):\n        self.assertEqual(egg_drop(1, 2), 2)\n        self.assertEqual(egg_drop(2, 6), 3)\n        self.assertEqual(egg_drop(3, 14), 4)\nclass TestFib(unittest.TestCase):\n    def test_fib_recursive(self):\n        self.assertEqual(fib_recursive(10), 55)\n        self.assertEqual(fib_recursive(30), 832040)\n    def test_fib_list(self):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestFib",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestFib(unittest.TestCase):\n    def test_fib_recursive(self):\n        self.assertEqual(fib_recursive(10), 55)\n        self.assertEqual(fib_recursive(30), 832040)\n    def test_fib_list(self):\n        self.assertEqual(fib_list(10), 55)\n        self.assertEqual(fib_list(30), 832040)\n    def test_fib_iter(self):\n        self.assertEqual(fib_iter(10), 55)\n        self.assertEqual(fib_iter(30), 832040)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestHosoyaTriangle",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestHosoyaTriangle(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file hosoya_triangle\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_hosoya(self):\n        self.assertEqual([1], hosoya_testing(1))\n        self.assertEqual(\n            [1, 1, 1, 2, 1, 2, 3, 2, 2, 3, 5, 3, 4, 3, 5, 8, 5, 6, 6, 5, 8],",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestHouseRobber",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestHouseRobber(unittest.TestCase):\n    def test_house_robber(self):\n        self.assertEqual(44, house_robber([1, 2, 16, 3, 15, 3, 12, 1]))\nclass TestJobScheduling(unittest.TestCase):\n    def test_job_scheduling(self):\n        job1, job2 = Job(1, 3, 2), Job(2, 3, 4)\n        self.assertEqual(4, schedule([job1, job2]))\nclass TestKnapsack(unittest.TestCase):\n    def test_get_maximum_value(self):\n        item1, item2, item3 = Item(60, 10), Item(100, 20), Item(120, 30)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestJobScheduling",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestJobScheduling(unittest.TestCase):\n    def test_job_scheduling(self):\n        job1, job2 = Job(1, 3, 2), Job(2, 3, 4)\n        self.assertEqual(4, schedule([job1, job2]))\nclass TestKnapsack(unittest.TestCase):\n    def test_get_maximum_value(self):\n        item1, item2, item3 = Item(60, 10), Item(100, 20), Item(120, 30)\n        self.assertEqual(220, get_maximum_value([item1, item2, item3], 50))\n        item1, item2, item3, item4 = Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)\n        self.assertEqual(80, get_maximum_value([item1, item2, item3, item4], 5))",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestKnapsack",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestKnapsack(unittest.TestCase):\n    def test_get_maximum_value(self):\n        item1, item2, item3 = Item(60, 10), Item(100, 20), Item(120, 30)\n        self.assertEqual(220, get_maximum_value([item1, item2, item3], 50))\n        item1, item2, item3, item4 = Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)\n        self.assertEqual(80, get_maximum_value([item1, item2, item3, item4], 5))\nclass TestLongestIncreasingSubsequence(unittest.TestCase):\n    def test_longest_increasing_subsequence(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestLongestIncreasingSubsequence",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestLongestIncreasingSubsequence(unittest.TestCase):\n    def test_longest_increasing_subsequence(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestLongestIncreasingSubsequenceOptimized(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestLongestIncreasingSubsequenceOptimized2(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized2(self):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestLongestIncreasingSubsequenceOptimized",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestLongestIncreasingSubsequenceOptimized(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestLongestIncreasingSubsequenceOptimized2(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized2(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestIntDivide(unittest.TestCase):\n    def test_int_divide(self):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestLongestIncreasingSubsequenceOptimized2",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestLongestIncreasingSubsequenceOptimized2(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized2(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestIntDivide(unittest.TestCase):\n    def test_int_divide(self):\n        self.assertEqual(5, int_divide(4))\n        self.assertEqual(42, int_divide(10))\n        self.assertEqual(204226, int_divide(50))\nclass Test_dp_K_Factor(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestIntDivide",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestIntDivide(unittest.TestCase):\n    def test_int_divide(self):\n        self.assertEqual(5, int_divide(4))\n        self.assertEqual(42, int_divide(10))\n        self.assertEqual(204226, int_divide(50))\nclass Test_dp_K_Factor(unittest.TestCase):\n    def test_kfactor(self):\n        # Test 1\n        n1 = 4\n        k1 = 1",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "Test_dp_K_Factor",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class Test_dp_K_Factor(unittest.TestCase):\n    def test_kfactor(self):\n        # Test 1\n        n1 = 4\n        k1 = 1\n        self.assertEqual(find_k_factor(n1, k1), 1)\n        # Test 2\n        n2 = 7\n        k2 = 1\n        self.assertEqual(find_k_factor(n2, k2), 70302)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestPlantingTrees",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestPlantingTrees(unittest.TestCase):\n    def test_simple(self):\n        # arrange\n        trees = [0, 1, 10, 10]\n        L = 10\n        W = 1\n        # act\n        res = planting_trees(trees, L, W)\n        # assert\n        self.assertEqual(res, 2.414213562373095)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestTarjan",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestTarjan(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the file tarjan.py\n    Arguments:\n        unittest {[type]} -- [description]\n    ##-------------------------------------------------------------------\n\"\"\"\n    def test_tarjan_example_1(self):\n        # Graph from https://en.wikipedia.org/wiki/File:Scc.png",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestCheckBipartite",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestCheckBipartite(unittest.TestCase):\n    def test_check_bipartite(self):\n        adj_list_1 = [[0, 0, 1], [0, 0, 1], [1, 1, 0]]\n        self.assertEqual(True, check_bipartite(adj_list_1))\n        adj_list_2 = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n        self.assertEqual(True, check_bipartite(adj_list_2))\n        adj_list_3 = [[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]\n        self.assertEqual(False, check_bipartite(adj_list_3))\nclass TestDijkstra(unittest.TestCase):\n    def test_dijkstra(self):",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestDijkstra",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestDijkstra(unittest.TestCase):\n    def test_dijkstra(self):\n        g = Dijkstra(9)\n        g.graph = [\n            [0, 4, 0, 0, 0, 0, 0, 8, 0],\n            [4, 0, 8, 0, 0, 0, 0, 11, 0],\n            [0, 8, 0, 7, 0, 4, 0, 0, 2],\n            [0, 0, 7, 0, 9, 14, 0, 0, 0],\n            [0, 0, 0, 9, 0, 10, 0, 0, 0],\n            [0, 0, 4, 14, 10, 0, 2, 0, 0],",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestMaximum_Flow_Bfs",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestMaximum_Flow_Bfs(unittest.TestCase):\n##-------------------------------------------------------------------\n\"\"\"\n    \"\"\"\n    Test for the file def maximum_flow_bfs.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_maximum_flow_bfs(self):\n        graph = [",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestAll_Pairs_Shortest_Path",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestAll_Pairs_Shortest_Path(unittest.TestCase):\n    def test_all_pairs_shortest_path(self):\n        graph = [\n            [0, 0.1, 0.101, 0.142, 0.277],\n            [0.465, 0, 0.191, 0.192, 0.587],\n            [0.245, 0.554, 0, 0.333, 0.931],\n            [1.032, 0.668, 0.656, 0, 0.151],\n            [0.867, 0.119, 0.352, 0.398, 0],\n        ]\n        result = all_pairs_shortest_path(graph)",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestBellmanFord",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestBellmanFord(unittest.TestCase):\n    def test_bellman_ford(self):\n        graph1 = {\n            \"a\": {\"b\": 6, \"e\": 7},\n            \"b\": {\"c\": 5, \"d\": -4, \"e\": 8},\n            \"c\": {\"b\": -2},\n            \"d\": {\"a\": 2, \"c\": 7},\n            \"e\": {\"b\": -3},\n        }\n        self.assertEqual(True, bellman_ford(graph1, \"a\"))",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestConnectedComponentInGraph",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestConnectedComponentInGraph(unittest.TestCase):\n    \"\"\"\n     Class for testing different cases for connected components in graph\n    \"\"\"\n##-------------------------------------------------------------------\n\"\"\"\n    def test_count_connected_components(self):\n        \"\"\"\n           Test Function that test the different cases of count connected components\n            2----------0    1--------5      3",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "PrimsMinimumSpanning",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class PrimsMinimumSpanning(unittest.TestCase):\n    def test_prim_spanning(self):\n        graph1 = {\n            1: [[3, 2], [8, 3]],\n            2: [[3, 1], [5, 4]],\n            3: [[8, 1], [2, 4], [4, 5]],\n            4: [[5, 2], [2, 3], [6, 5]],\n            5: [[4, 3], [6, 4]],\n        }\n        self.assertEqual(14, prims_minimum_spanning(graph1))",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestBinaryHeap",
        "kind": 6,
        "importPath": "algorithms.tests.test_heap",
        "description": "algorithms.tests.test_heap",
        "peekOfCode": "class TestBinaryHeap(unittest.TestCase):\n    \"\"\"\n        Test suite for the binary_heap data structures\n    \"\"\"\n    def setUp(self):\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.min_heap.insert(4)\n    ##-------------------------------------------------------------------\n\"\"\"",
        "detail": "algorithms.tests.test_heap",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_heap",
        "description": "algorithms.tests.test_heap",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_get_skyline(self):\n        buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]\n        # Expect output\n        output = [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]\n        self.assertEqual(output, get_skyline(buildings))\n    def test_max_sliding_window(self):\n        nums = [1, 3, -1, -3, 5, 3, 6, 7]\n        self.assertEqual([3, 3, 5, 5, 6, 7], max_sliding_window(nums, 3))\n    def test_k_closest_points(self):",
        "detail": "algorithms.tests.test_heap",
        "documentation": {}
    },
    {
        "label": "TestListsInHistogram",
        "kind": 6,
        "importPath": "algorithms.tests.test_histogram",
        "description": "algorithms.tests.test_histogram",
        "peekOfCode": "class TestListsInHistogram(unittest.TestCase):\n    def test_histogram(self):\n        list_1 = [3, 3, 2, 1]\n        list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7]\n        self.assertEqual(get_histogram(list_1), {1: 1, 2: 1, 3: 2})\n        self.assertEqual(get_histogram(list_2), {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1})\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "algorithms.tests.test_histogram",
        "documentation": {}
    },
    {
        "label": "TestSegmentTree",
        "kind": 6,
        "importPath": "algorithms.tests.test_iterative_segment_tree",
        "description": "algorithms.tests.test_iterative_segment_tree",
        "peekOfCode": "class TestSegmentTree(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the Iterative Segment Tree data structure\n    ##-------------------------------------------------------------------\n\"\"\"\n    def test_segment_tree_creation(self):\n        arr = [2, 4, 3, 6, 8, 9, 3]\n        max_segment_tree = SegmentTree(arr, max)\n        min_segment_tree = SegmentTree(arr, min)",
        "detail": "algorithms.tests.test_iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "algorithms.tests.test_iterative_segment_tree",
        "description": "algorithms.tests.test_iterative_segment_tree",
        "peekOfCode": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nclass TestSegmentTree(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the Iterative Segment Tree data structure\n    ##-------------------------------------------------------------------\n\"\"\"",
        "detail": "algorithms.tests.test_iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.tests.test_linkedlist",
        "description": "algorithms.tests.test_linkedlist",
        "peekOfCode": "class Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n# Convert from linked list Node to list for testing\ndef convert(head):\n    ret = []\n    if head:\n        current = head\n        while current:",
        "detail": "algorithms.tests.test_linkedlist",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_linkedlist",
        "description": "algorithms.tests.test_linkedlist",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        # list test for palindrome\n        self.l = Node(\"A\")\n        self.l.next = Node(\"B\")\n        self.l.next.next = Node(\"C\")\n        self.l.next.next.next = Node(\"B\")\n        self.l.next.next.next.next = Node(\"A\")\n        self.l1 = Node(\"A\")\n        self.l1.next = Node(\"B\")",
        "detail": "algorithms.tests.test_linkedlist",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "algorithms.tests.test_linkedlist",
        "description": "algorithms.tests.test_linkedlist",
        "peekOfCode": "def convert(head):\n    ret = []\n    if head:\n        current = head\n        while current:\n            ret.append(current.val)\n            current = current.next\n    return ret\nclass TestSuite(unittest.TestCase):\n    def setUp(self):",
        "detail": "algorithms.tests.test_linkedlist",
        "documentation": {}
    },
    {
        "label": "TestHashTable",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestHashTable(unittest.TestCase):\n    def test_one_entry(self):\n        m = HashTable(10)\n        m.put(1, \"1\")\n        self.assertEqual(\"1\", m.get(1))\n    def test_add_entry_bigger_than_table_size(self):\n        m = HashTable(10)\n        m.put(11, \"1\")\n        self.assertEqual(\"1\", m.get(11))\n    def test_get_none_if_key_missing_and_hash_collision(self):",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestSeparateChainingHashTable",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestSeparateChainingHashTable(unittest.TestCase):\n    def test_one_entry(self):\n        m = SeparateChainingHashTable(10)\n        m.put(1, \"1\")\n        self.assertEqual(\"1\", m.get(1))\n    def test_two_entries_with_same_hash(self):\n        m = SeparateChainingHashTable(10)\n        m.put(1, \"1\")\n        m.put(11, \"11\")\n        self.assertEqual(\"1\", m.get(1))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestWordPattern",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestWordPattern(unittest.TestCase):\n    def test_word_pattern(self):\n        self.assertTrue(word_pattern(\"abba\", \"dog cat cat dog\"))\n        self.assertFalse(word_pattern(\"abba\", \"dog cat cat fish\"))\n        self.assertFalse(word_pattern(\"abba\", \"dog dog dog dog\"))\n        self.assertFalse(word_pattern(\"aaaa\", \"dog cat cat dog\"))\nclass TestIsSomorphic(unittest.TestCase):\n    def test_is_isomorphic(self):\n        self.assertTrue(is_isomorphic(\"egg\", \"add\"))\n        self.assertFalse(is_isomorphic(\"foo\", \"bar\"))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestIsSomorphic",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestIsSomorphic(unittest.TestCase):\n    def test_is_isomorphic(self):\n        self.assertTrue(is_isomorphic(\"egg\", \"add\"))\n        self.assertFalse(is_isomorphic(\"foo\", \"bar\"))\n        self.assertTrue(is_isomorphic(\"paper\", \"title\"))\nclass TestLongestPalindromicSubsequence(unittest.TestCase):\n    def test_longest_palindromic_subsequence_is_correct(self):\n        self.assertEqual(3, longest_palindromic_subsequence(\"BBABCBCAB\"))\n        self.assertEqual(4, longest_palindromic_subsequence(\"abbaeae\"))\n        self.assertEqual(7, longest_palindromic_subsequence(\"babbbababaa\"))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestLongestPalindromicSubsequence",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestLongestPalindromicSubsequence(unittest.TestCase):\n    def test_longest_palindromic_subsequence_is_correct(self):\n        self.assertEqual(3, longest_palindromic_subsequence(\"BBABCBCAB\"))\n        self.assertEqual(4, longest_palindromic_subsequence(\"abbaeae\"))\n        self.assertEqual(7, longest_palindromic_subsequence(\"babbbababaa\"))\n        self.assertEqual(4, longest_palindromic_subsequence(\"daccandeeja\"))\n    def test_longest_palindromic_subsequence_is_incorrect(self):\n        self.assertNotEqual(4, longest_palindromic_subsequence(\"BBABCBCAB\"))\n        self.assertNotEqual(5, longest_palindromic_subsequence(\"abbaeae\"))\n        self.assertNotEqual(2, longest_palindromic_subsequence(\"babbbababaa\"))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestIsAnagram",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestIsAnagram(unittest.TestCase):\n    def test_is_anagram(self):\n        self.assertTrue(is_anagram(\"anagram\", \"nagaram\"))\n        self.assertFalse(is_anagram(\"rat\", \"car\"))\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestPower",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPower(unittest.TestCase):\n    \"\"\"\n    Test for the file power.py\n    ##-------------------------------------------------------------------\n\"\"\"\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_power(self):\n        self.assertEqual(8, power(2, 3))\n        self.assertEqual(1, power(5, 0))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestBaseConversion",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestBaseConversion(unittest.TestCase):\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_int_to_base(self):\n        self.assertEqual(\"101\", int_to_base(5, 2))\n        self.assertEqual(\"0\", int_to_base(0, 2))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestEulerTotient",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestEulerTotient(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file euler_totient.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n##-------------------------------------------------------------------\n\"\"\"\n    def test_euler_totient(self):\n        self.assertEqual(4, euler_totient(8))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestExtendedGcd",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestExtendedGcd(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file extended_gcd.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_extended_gcd(self):\n        self.assertEqual((0, 1, 2), extended_gcd(8, 2))\n        self.assertEqual((0, 1, 17), extended_gcd(13, 17))\nclass TestGcd(unittest.TestCase):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestGcd",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestGcd(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file gcd.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_gcd(self):\n        self.assertEqual(4, gcd(8, 12))\n        self.assertEqual(1, gcd(13, 17))\n    def test_gcd_non_integer_input(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestGenerateStroboGrammatic",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestGenerateStroboGrammatic(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file generate_strobogrammatic.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertEqual([\"88\", \"11\", \"96\", \"69\"], gen_strobogrammatic(2))\n    def test_strobogrammatic_in_range(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestIsStrobogrammatic",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestIsStrobogrammatic(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file is_strobogrammatic.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_strobogrammatic(self):\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertFalse(is_strobogrammatic(\"14\"))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestModularInverse",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestModularInverse(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file modular_Exponential.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n        # checks if x * x_inv == 1 (mod m)\n        self.assertEqual(1, 2 * modular_inverse.modular_inverse(2, 19) % 19)",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestModularExponential",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestModularExponential(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file modular_Exponential.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n##-------------------------------------------------------------------\n\"\"\"\n    def test_modular_exponential(self):\n        self.assertEqual(1, modular_exponential(5, 117, 19))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestNextPerfectSquare",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestNextPerfectSquare(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file next_perfect_square.py\n##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"##-------------------------------------------------------------------\n\"\"\"\n    def test_find_next_square(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestPrimesSieveOfEratosthenes",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPrimesSieveOfEratosthenes(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file primes_sieve_of_eratosthenes.py\n    Arguments:\n        unittest {[type]} -- [description]\n    ##-------------------------------------------------------------------\n\"\"\"\n    def test_primes(self):\n        self.assertListEqual([2, 3, 5, 7], get_primes(7))\n        self.assertRaises(ValueError, get_primes, -42)",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestPrimeTest",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPrimeTest(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file prime_test.py\n    Arguments:\n    ##-------------------------------------------------------------------\n\"\"\"\n    \"\"\"\n    def test_prime_test(self):\n        \"\"\"\n            checks all prime numbers between 2 up to 100.",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestPythagoras",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPythagoras(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file pythagoras.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_pythagoras(self):\n        self.assertEqual(\"Hypotenuse = 3.605551275463989\", pythagoras(3, 2, \"?\"))\nclass TestRabinMiller(unittest.TestCase):\n    \"\"\"[summary]",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestRabinMiller",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestRabinMiller(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rabin_miller.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertTrue(is_prime(7, 2))\n        self.assertTrue(is_prime(13, 11))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestRSA",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestRSA(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rsa.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_encrypt_decrypt(self):\n        self.assertEqual(7, decrypt(encrypt(7, 23, 143), 47, 143))\n    ##-------------------------------------------------------------------\n\"\"\"",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestCombination",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestCombination(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file combination.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_combination(self):\n        self.assertEqual(10, combination(5, 2))\n        self.assertEqual(252, combination(10, 5))\n    def test_combination_memo(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestFactorial",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestFactorial(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file factorial.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_factorial(self):\n        self.assertEqual(1, factorial(0))\n        self.assertEqual(120, factorial(5))\n    ##-------------------------------------------------------------------",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestHailstone",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestHailstone(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file hailstone.py\n##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_hailstone(self):\n        self.assertEqual([8, 4, 2, 1], hailstone.hailstone(8))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestCosineSimilarity",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestCosineSimilarity(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file cosine_similarity.py\n    Arguments:\n    ##-------------------------------------------------------------------\n\"\"\"\n    \"\"\"\n    def test_cosine_similarity(self):\n        vec_a = [1, 1, 1]\n        vec_b = [-1, -1, -1]",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestFindPrimitiveRoot",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestFindPrimitiveRoot(unittest.TestCase):\n    \"\"\"[summary]\n    ##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_primitive_root_simple(self):\n        self.assertListEqual([0], find_primitive_root(1))\n        self.assertListEqual([2, 3], find_primitive_root(5))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestFindOrder",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestFindOrder(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the file find_order_simple.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_order_simple(self):\n        self.assertEqual(1, find_order(1, 1))\n        self.assertEqual(6, find_order(3, 7))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestKrishnamurthyNumber",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestKrishnamurthyNumber(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file krishnamurthy_number.py\n##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_krishnamurthy_number(self):\n        self.assertFalse(krishnamurthy_number(0))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestMagicNumber",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestMagicNumber(unittest.TestCase):\n    \"\"\"[summary]\n    ##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_magic_number(self):\n        self.assertTrue(magic_number(50113))\n        self.assertTrue(magic_number(1234))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestDiffieHellmanKeyExchange",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestDiffieHellmanKeyExchange(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file diffie_hellman_key_exchange.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_order_simple(self):\n        self.assertFalse(diffie_hellman_key_exchange(3, 6))\n        self.assertTrue(diffie_hellman_key_exchange(3, 353))\n        self.assertFalse(diffie_hellman_key_exchange(5, 211))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestNumberOfDigits",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestNumberOfDigits(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file num_digits.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_num_digits(self):\n        self.assertEqual(2, num_digits(12))\n        self.assertEqual(5, num_digits(99999))\n        self.assertEqual(1, num_digits(8))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestChineseRemainderSolver",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestChineseRemainderSolver(unittest.TestCase):\n    def test_k_three(self):\n        # Example which should give the answer 143\n        # which is the smallest possible x that\n        # solves the system of equations\n        num = [3, 7, 10]\n        rem = [2, 3, 3]\n        self.assertEqual(\n            chinese_remainder_theorem.solve_chinese_remainder(num, rem), 143\n        )",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestBombEnemy",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestBombEnemy(unittest.TestCase):\n    def test_3x4(self):\n        grid1 = [[\"0\", \"E\", \"0\", \"0\"], [\"E\", \"0\", \"W\", \"E\"], [\"0\", \"E\", \"0\", \"0\"]]\n        self.assertEqual(3, bomb_enemy.max_killed_enemies(grid1))\n        grid1 = [\n            [\"0\", \"E\", \"0\", \"E\"],\n            [\"E\", \"E\", \"E\", \"0\"],\n            [\"E\", \"0\", \"W\", \"E\"],\n            [\"0\", \"E\", \"0\", \"0\"],\n        ]",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestCopyTransform",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestCopyTransform(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file copy_transform.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_copy_transform(self):\n        self.assertEqual(\n    ##-------------------------------------------------------------------\n\"\"\"",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestCroutMatrixDecomposition",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestCroutMatrixDecomposition(unittest.TestCase):\n    \"\"\"[summary]\n    ##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_crout_matrix_decomposition(self):\n        self.assertEqual(\n            ([[9.0, 0.0], [7.0, 0.0]], [[1.0, 1.0], [0.0, 1.0]]),",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestCholeskyMatrixDecomposition",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestCholeskyMatrixDecomposition(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file cholesky_matrix_decomposition.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_cholesky_matrix_decomposition(self):\n        self.assertEqual(\n            [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]],\n            cholesky_matrix_decomposition.cholesky_decomposition(",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestInversion",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestInversion(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file matrix_inversion.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n##-------------------------------------------------------------------\n\"\"\"\n    def test_inversion(self):\n        from fractions import Fraction",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMatrixExponentiation",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestMatrixExponentiation(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file matrix_exponentiation.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n##-------------------------------------------------------------------\n\"\"\"\n    def test_matrix_exponentiation(self):\n        mat = [[1, 0, 2], [2, 1, 0], [0, 2, 1]]",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMultiply",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestMultiply(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the file multiply.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_multiply(self):\n        self.assertEqual(\n            multiply.multiply([[1, 2, 3], [2, 1, 1]], [[1], [2], [3]]), [[14], [7]]",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSparseDotVector",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSparseDotVector(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file sparse_dot_vector.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_sparse_dot_vector(self):\n        self.assertEqual(\n            sparse_dot_vector.dot_product(\n                sparse_dot_vector.vector_to_index_value_list([1.0, 2.0, 3.0]),",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSpiralTraversal",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSpiralTraversal(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file spiral_traversal.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_spiral_traversal(self):\n        self.assertEqual(\n            spiral_traversal.spiral_traversal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),\n            [1, 2, 3, 6, 9, 8, 7, 4, 5],",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSudokuValidator",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSudokuValidator(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file sudoku_validator.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_sudoku_validator(self):\n        self.assertTrue(\n            sudoku_validator.valid_solution(\n                [",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSumSubSquares",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSumSubSquares(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file sum_sub_squares.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_sum_sub_squares(self):\n        mat = [\n            [1, 1, 1, 1, 1],\n            [2, 2, 2, 2, 2],",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSortMatrixDiagonally",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSortMatrixDiagonally(unittest.TestCase):\n    def test_sort_diagonally(self):\n        mat = [[3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2]]\n        self.assertEqual(\n            sort_matrix_diagonally.sort_diagonally(mat),\n            [[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3]],\n        )\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestML",
        "kind": 6,
        "importPath": "algorithms.tests.test_ml",
        "description": "algorithms.tests.test_ml",
        "peekOfCode": "class TestML(unittest.TestCase):\n    def setUp(self):\n        # train set for the AND-function\n        self.trainSetAND = {(0, 0): 0, (0, 1): 0, (1, 0): 0, (1, 1): 1}\n        # train set for light or dark colors\n        self.trainSetLight = {\n            (11, 98, 237): \"L\",\n            (3, 39, 96): \"D\",\n            (242, 226, 12): \"L\",\n            (99, 93, 4): \"D\",",
        "detail": "algorithms.tests.test_ml",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.m1 = Monomial({})\n        self.m2 = Monomial({1: 1}, 2)\n        self.m3 = Monomial({1: 2, 2: -1}, 1.5)\n        self.m4 = Monomial({1: 1, 2: 2, 3: -2}, 3)\n        self.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n        self.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n        self.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n        self.m8 = Monomial({150: 5, 170: 2, 10000: 3}, 0)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.p0 = Polynomial([Monomial({})])\n        self.p1 = Polynomial([Monomial({}), Monomial({})])\n        self.p2 = Polynomial([Monomial({1: 1}, 2)])\n        self.p3 = Polynomial([Monomial({1: 1}, 2), Monomial({1: 2, 2: -1}, 1.5)])\n        self.p4 = Polynomial(\n            [\n                Monomial({2: 1, 3: 0}, Fraction(2, 3)),\n                Monomial({1: -1, 3: 2}, math.pi),",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_queues",
        "description": "algorithms.tests.test_queues",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_max_sliding_window(self):\n        array = [1, 3, -1, -3, 5, 3, 6, 7]\n        self.assertEqual(max_sliding_window(array, k=5), [5, 5, 6, 7])\n        self.assertEqual(max_sliding_window(array, k=3), [3, 3, 5, 5, 6, 7])\n        self.assertEqual(max_sliding_window(array, k=7), [6, 7])\n        array = [8, 5, 10, 7, 9, 4, 15, 12, 90, 13]\n        self.assertEqual(max_sliding_window(array, k=4), [10, 10, 10, 15, 15, 90, 90])\n        self.assertEqual(max_sliding_window(array, k=7), [15, 15, 90, 90])\n        self.assertEqual(",
        "detail": "algorithms.tests.test_queues",
        "documentation": {}
    },
    {
        "label": "TestPriorityQueue",
        "kind": 6,
        "importPath": "algorithms.tests.test_queues",
        "description": "algorithms.tests.test_queues",
        "peekOfCode": "class TestPriorityQueue(unittest.TestCase):\n    \"\"\"Test suite for the PriorityQueue data structures.\n    \"\"\"\n    def test_PriorityQueue(self):\n        queue = PriorityQueue([3, 4, 1, 6])\n        self.assertEqual(4, queue.size())\n        self.assertEqual(1, queue.pop())\n        self.assertEqual(3, queue.size())\n        queue.push(2)\n        self.assertEqual(4, queue.size())",
        "detail": "algorithms.tests.test_queues",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_search",
        "description": "algorithms.tests.test_search",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_first_occurrence(self):\n        def helper(array, query):\n            idx = array.index(query) if query in array else None\n            return idx\n        array = [1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 6]\n        self.assertEqual(first_occurrence(array, 1), helper(array, 1))\n        self.assertEqual(first_occurrence(array, 3), helper(array, 3))\n        self.assertEqual(first_occurrence(array, 5), helper(array, 5))\n        self.assertEqual(first_occurrence(array, 6), helper(array, 6))",
        "detail": "algorithms.tests.test_search",
        "documentation": {}
    },
    {
        "label": "TestFindKeyboardRow",
        "kind": 6,
        "importPath": "algorithms.tests.test_set",
        "description": "algorithms.tests.test_set",
        "peekOfCode": "class TestFindKeyboardRow(unittest.TestCase):\n    def test_find_keyboard_row(self):\n        self.assertEqual(\n            [\"Alaska\", \"Dad\"], find_keyboard_row([\"Hello\", \"Alaska\", \"Dad\", \"Peace\"])\n        )",
        "detail": "algorithms.tests.test_set",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_sort",
        "description": "algorithms.tests.test_sort",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_bogo_sort(self):\n        self.assertTrue(is_sorted(bogo_sort([1, 23, 5])))\n    def test_bitonic_sort(self):\n        self.assertTrue(is_sorted(bitonic_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    def test_bubble_sort(self):\n        self.assertTrue(is_sorted(bubble_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    def test_comb_sort(self):\n        self.assertTrue(is_sorted(comb_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    def test_counting_sort(self):",
        "detail": "algorithms.tests.test_sort",
        "documentation": {}
    },
    {
        "label": "TestTopSort",
        "kind": 6,
        "importPath": "algorithms.tests.test_sort",
        "description": "algorithms.tests.test_sort",
        "peekOfCode": "class TestTopSort(unittest.TestCase):\n    def setUp(self):\n        self.depGraph = {\n            \"a\": [\"b\"],\n            \"b\": [\"c\"],\n            \"c\": [\"e\"],\n            \"e\": [\"g\"],\n            \"d\": [],\n            \"f\": [\"e\", \"d\"],\n            \"g\": [],",
        "detail": "algorithms.tests.test_sort",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "kind": 2,
        "importPath": "algorithms.tests.test_sort",
        "description": "algorithms.tests.test_sort",
        "peekOfCode": "def is_sorted(array):\n    \"\"\"\n    Helper function to check if the given array is sorted.\n    ##-------------------------------------------------------------------\n\"\"\"\n    :return: True if sorted in ascending order, else False\n    \"\"\"\n    for i in range(len(array) - 1):\n        if array[i] > array[i + 1]:\n            return False",
        "detail": "algorithms.tests.test_sort",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_stack",
        "description": "algorithms.tests.test_stack",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_is_consecutive(self):\n        self.assertTrue(first_is_consecutive([3, 4, 5, 6, 7]))\n        self.assertFalse(first_is_consecutive([3, 4, 6, 7]))\n        self.assertFalse(first_is_consecutive([3, 2, 1]))\n        self.assertTrue(second_is_consecutive([3, 4, 5, 6, 7]))\n        self.assertFalse(second_is_consecutive([3, 4, 6, 7]))\n        self.assertFalse(second_is_consecutive([3, 2, 1]))\n    def test_is_sorted(self):\n        # Test case: bottom [6, 3, 5, 1, 2, 4] top",
        "detail": "algorithms.tests.test_stack",
        "documentation": {}
    },
    {
        "label": "TestStack",
        "kind": 6,
        "importPath": "algorithms.tests.test_stack",
        "description": "algorithms.tests.test_stack",
        "peekOfCode": "class TestStack(unittest.TestCase):\n    def test_ArrayStack(self):\n        stack = ArrayStack()\n        stack.push(1)\n        stack.push(2)\n        stack.push(3)\n        # test __iter__()\n        it = iter(stack)\n        self.assertEqual(3, next(it))\n        self.assertEqual(2, next(it))",
        "detail": "algorithms.tests.test_stack",
        "documentation": {}
    },
    {
        "label": "TestOrderedStack",
        "kind": 6,
        "importPath": "algorithms.tests.test_stack",
        "description": "algorithms.tests.test_stack",
        "peekOfCode": "class TestOrderedStack(unittest.TestCase):\n    def test_OrderedStack(self):\n        stack = OrderedStack()\n        self.assertTrue(stack.is_empty())\n        stack.push(1)\n        stack.push(4)\n        stack.push(3)\n        stack.push(6)\n        \"bottom - > 1 3 4 6 \"\n        self.assertEqual(6, stack.pop())",
        "detail": "algorithms.tests.test_stack",
        "documentation": {}
    },
    {
        "label": "TestMisraGreis",
        "kind": 6,
        "importPath": "algorithms.tests.test_streaming",
        "description": "algorithms.tests.test_streaming",
        "peekOfCode": "class TestMisraGreis(unittest.TestCase):\n    def test_misra_correct(self):\n        self.assertEqual({\"4\": 5}, misras_gries([1, 4, 4, 4, 5, 4, 4]))\n        self.assertEqual({\"1\": 4}, misras_gries([0, 0, 0, 1, 1, 1, 1]))\n        self.assertEqual({\"0\": 4, \"1\": 3}, misras_gries([0, 0, 0, 0, 1, 1, 1, 2, 2], 3))\n    def test_misra_incorrect(self):\n        self.assertEqual(None, misras_gries([1, 2, 5, 4, 5, 4, 4, 5, 4, 4, 5]))\n        self.assertEqual(None, misras_gries([0, 0, 0, 2, 1, 1, 1]))\n        self.assertEqual(None, misras_gries([0, 0, 0, 1, 1, 1]))\nclass TestOneSparse(unittest.TestCase):",
        "detail": "algorithms.tests.test_streaming",
        "documentation": {}
    },
    {
        "label": "TestOneSparse",
        "kind": 6,
        "importPath": "algorithms.tests.test_streaming",
        "description": "algorithms.tests.test_streaming",
        "peekOfCode": "class TestOneSparse(unittest.TestCase):\n    def test_one_sparse_correct(self):\n        self.assertEqual(\n            4, one_sparse([(4, \"+\"), (2, \"+\"), (2, \"-\"), (4, \"+\"), (3, \"+\"), (3, \"-\")])\n        )\n        self.assertEqual(\n            2,\n            one_sparse(\n                [(2, \"+\"), (2, \"+\"), (2, \"+\"), (2, \"+\"), (2, \"+\"), (2, \"+\"), (2, \"+\")]\n            ),",
        "detail": "algorithms.tests.test_streaming",
        "documentation": {}
    },
    {
        "label": "TestAddBinary",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestAddBinary(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the file add_binary.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_add_binary(self):\n        self.assertEqual(\"100\", add_binary(\"11\", \"1\"))\n        self.assertEqual(\"101\", add_binary(\"100\", \"1\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestBreakingBad",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestBreakingBad(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file breaking_bad.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def setUp(self):\n        self.words = [\"Amazon\", \"Microsoft\", \"Google\"]\n        self.symbols = [\"i\", \"Am\", \"cro\", \"le\", \"abc\"]\n    ##-------------------------------------------------------------------",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestDecodeString",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestDecodeString(unittest.TestCase):\n    ##-------------------------------------------------------------------\n\"\"\"\n    Test for the file decode_string.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_decode_string(self):\n        self.assertEqual(\"aaabcbc\", decode_string(\"3[a]2[bc]\"))\n        self.assertEqual(\"accaccacc\", decode_string(\"3[a2[c]]\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestDeleteReoccurring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestDeleteReoccurring(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file delete_reoccurring.py\n##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_delete_reoccurring_characters(self):\n        self.assertEqual(\"abc\", delete_reoccurring_characters(\"aaabcccc\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestDomainExtractor",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestDomainExtractor(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file domain_extractor.py\n    Arguments:\n        unittest {[type]} -- [description]\n    ##-------------------------------------------------------------------\n\"\"\"\n    def test_valid(self):\n        self.assertEqual(domain_name_1(\"https://github.com/SaadBenn\"), \"github\")\n    def test_invalid(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestEncodeDecode",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestEncodeDecode(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file encode_decode.py\n    ##-------------------------------------------------------------------\n\"\"\"\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_encode(self):\n        self.assertEqual(\"4:keon2:is7:awesome\", encode(\"keon is awesome\"))\n    def test_decode(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestGroupAnagrams",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestGroupAnagrams(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file group_anagrams.py\n##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_group_anagrams(self):\n        self.assertEqual(",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestIntToRoman",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestIntToRoman(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file int_to_roman.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_int_to_roman(self):\n        self.assertEqual(\"DCXLIV\", int_to_roman(644))\n        self.assertEqual(\"I\", int_to_roman(1))\n        self.assertEqual(\"MMMCMXCIX\", int_to_roman(3999))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestIsPalindrome",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestIsPalindrome(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file is_palindrome.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n        # 'Otto' is a old german name.\n        self.assertTrue(is_palindrome(\"Otto\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestIsRotated",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestIsRotated(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file is_rotated.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_rotated(self):\n        self.assertTrue(is_rotated(\"hello\", \"hello\"))\n        self.assertTrue(is_rotated(\"hello\", \"llohe\"))\n    ##-------------------------------------------------------------------",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRotated",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRotated(unittest.TestCase):\n    def test_rotate(self):\n        self.assertEqual(\"llohe\", rotate(\"hello\", 2))\n        self.assertEqual(\"hello\", rotate(\"hello\", 5))\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertEqual(\"llohe\", rotate(\"hello\", 7))\n    def test_rotate_alt(self):\n        self.assertEqual(\"llohe\", rotate_alt(\"hello\", 2))\n        self.assertEqual(\"hello\", rotate_alt(\"hello\", 5))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestLicenseNumber",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestLicenseNumber(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file license_number.py\n    ##-------------------------------------------------------------------\n\"\"\"\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_license_number(self):\n        self.assertEqual(\"a-b-c-d-f-d-d-f\", license_number(\"a-bc-dfd-df\", 1))\n        self.assertEqual(\"ab-cd-fd-df\", license_number(\"a-bc-dfd-df\", 2))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMakeSentence",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMakeSentence(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file make_sentence.py\n##-------------------------------------------------------------------\n\"\"\"\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_make_sentence(self):\n        dictionarys = [\"\", \"app\", \"let\", \"t\", \"apple\", \"applet\"]",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMergeStringChecker",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMergeStringChecker(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file merge_string_checker.py\n    ##-------------------------------------------------------------------\n\"\"\"\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_merge_recursive(self):\n        self.assertTrue(is_merge_recursive(\"codewars\", \"cdw\", \"oears\"))\n    def test_is_merge_iterative(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMultiplyStrings",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMultiplyStrings(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file multiply_strings.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertEqual(\"23\", multiply(\"1\", \"23\"))\n        self.assertEqual(\"529\", multiply(\"23\", \"23\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestOneEditDistance",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestOneEditDistance(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file one_edit_distance.py\n    Arguments:\n        unittest {[type]} -- [description]\n    ##-------------------------------------------------------------------\n\"\"\"\n    def test_is_one_edit(self):\n        self.assertTrue(is_one_edit(\"abc\", \"abd\"))\n        self.assertFalse(is_one_edit(\"abc\", \"aed\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRabinKarp",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRabinKarp(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rabin_karp.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertEqual(3, rabin_karp(\"abc\", \"zsnabckfkd\"))\n        self.assertEqual(None, rabin_karp(\"abc\", \"zsnajkskfkd\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestReverseString",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestReverseString(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file reverse_string.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n##-------------------------------------------------------------------\n\"\"\"\n    def test_recursive(self):\n        self.assertEqual(\"ereht olleh\", recursive(\"hello there\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestReverseVowel",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestReverseVowel(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file reverse_vowel.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_reverse_vowel(self):\n        self.assertEqual(\"holle\", reverse_vowel(\"hello\"))\nclass TestReverseWords(unittest.TestCase):\n    \"\"##-------------------------------------------------------------------",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestReverseWords",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestReverseWords(unittest.TestCase):\n    \"\"##-------------------------------------------------------------------\n\"\"\"\n    Test for the file reverse_words.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_reverse_words(self):\n        self.assertEqual(\n            \"pizza like I and kim keon am I\",",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRomanToInt",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRomanToInt(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file roman_to_int.py\n    Arguments:\n    ##-------------------------------------------------------------------\n\"\"\"\n    \"\"\"\n    def test_roman_to_int(self):\n        self.assertEqual(621, roman_to_int(\"DCXXI\"))\n        self.assertEqual(1, roman_to_int(\"I\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestValidateCoordinates",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestValidateCoordinates(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file validate_coordinates.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_valid(self):\n        valid_coordinates = [\"-23, 25\", \"4, -3\", \"90, 180\", \"-90, -180\"]\n        for coordinate in valid_coordinates:\n            self.assertTrue(is_valid_coordinates_0(coordinate))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestWordSquares",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestWordSquares(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file word_squares.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_word_squares(self):\n        self.assertEqual(\n            [[\"wall\", \"area\", \"lead\", \"lady\"], [\"ball\", \"area\", \"lead\", \"lady\"]],\n            word_squares([\"area\", \"lead\", \"wall\", \"lady\", \"ball\"]),",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestUniqueMorse",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestUniqueMorse(unittest.TestCase):\n    def test_convert_morse_word(self):\n        self.assertEqual(\"--...-.\", convert_morse_word(\"gin\"))\n        self.assertEqual(\"--...--.\", convert_morse_word(\"msg\"))\n    def test_unique_morse(self):\n        self.assertEqual(2, unique_morse([\"gin\", \"zen\", \"gig\", \"msg\"]))\nclass TestJudgeCircle(unittest.TestCase):\n    def test_judge_circle(self):\n        self.assertTrue(judge_circle(\"UDLRUD\"))\n        self.assertFalse(judge_circle(\"LLRU\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestJudgeCircle",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestJudgeCircle(unittest.TestCase):\n    def test_judge_circle(self):\n        self.assertTrue(judge_circle(\"UDLRUD\"))\n        self.assertFalse(judge_circle(\"LLRU\"))\nclass TestStrongPassword(unittest.TestCase):\n    def test_strong_password(self):\n        self.assertEqual(3, strong_password(3, \"Ab1\"))\n        self.assertEqual(1, strong_password(11, \"#Algorithms\"))\nclass TestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestStrongPassword",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestStrongPassword(unittest.TestCase):\n    def test_strong_password(self):\n        self.assertEqual(3, strong_password(3, \"Ab1\"))\n        self.assertEqual(1, strong_password(11, \"#Algorithms\"))\nclass TestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):\n        self.assertEqual(\"Lipps_Asvph!\", caesar_cipher(\"Hello_World!\", 4))\n        self.assertEqual(\"okffng-Qwvb\", caesar_cipher(\"middle-Outz\", 2))\nclass TestCheckPangram(unittest.TestCase):\n    def test_check_pangram(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCaesarCipher",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):\n        self.assertEqual(\"Lipps_Asvph!\", caesar_cipher(\"Hello_World!\", 4))\n        self.assertEqual(\"okffng-Qwvb\", caesar_cipher(\"middle-Outz\", 2))\nclass TestCheckPangram(unittest.TestCase):\n    def test_check_pangram(self):\n        self.assertTrue(check_pangram(\"The quick brown fox jumps over the lazy dog\"))\n        self.assertFalse(check_pangram(\"The quick brown fox\"))\nclass TestContainString(unittest.TestCase):\n    def test_contain_string(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCheckPangram",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCheckPangram(unittest.TestCase):\n    def test_check_pangram(self):\n        self.assertTrue(check_pangram(\"The quick brown fox jumps over the lazy dog\"))\n        self.assertFalse(check_pangram(\"The quick brown fox\"))\nclass TestContainString(unittest.TestCase):\n    def test_contain_string(self):\n        self.assertEqual(-1, contain_string(\"mississippi\", \"issipi\"))\n        self.assertEqual(0, contain_string(\"Hello World\", \"\"))\n        self.assertEqual(2, contain_string(\"hello\", \"ll\"))\nclass TestCountBinarySubstring(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestContainString",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestContainString(unittest.TestCase):\n    def test_contain_string(self):\n        self.assertEqual(-1, contain_string(\"mississippi\", \"issipi\"))\n        self.assertEqual(0, contain_string(\"Hello World\", \"\"))\n        self.assertEqual(2, contain_string(\"hello\", \"ll\"))\nclass TestCountBinarySubstring(unittest.TestCase):\n    def test_count_binary_substring(self):\n        self.assertEqual(6, count_binary_substring(\"00110011\"))\n        self.assertEqual(4, count_binary_substring(\"10101\"))\n        self.assertEqual(3, count_binary_substring(\"00110\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCountBinarySubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCountBinarySubstring(unittest.TestCase):\n    def test_count_binary_substring(self):\n        self.assertEqual(6, count_binary_substring(\"00110011\"))\n        self.assertEqual(4, count_binary_substring(\"10101\"))\n        self.assertEqual(3, count_binary_substring(\"00110\"))\nclass TestCountBinarySubstring(unittest.TestCase):\n    def test_repeat_string(self):\n        self.assertEqual(3, repeat_string(\"abcd\", \"cdabcdab\"))\n        self.assertEqual(4, repeat_string(\"bb\", \"bbbbbbb\"))\nclass TestTextJustification(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCountBinarySubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCountBinarySubstring(unittest.TestCase):\n    def test_repeat_string(self):\n        self.assertEqual(3, repeat_string(\"abcd\", \"cdabcdab\"))\n        self.assertEqual(4, repeat_string(\"bb\", \"bbbbbbb\"))\nclass TestTextJustification(unittest.TestCase):\n    def test_text_justification(self):\n        self.assertEqual(\n            [\"This    is    an\", \"example  of text\", \"justification.  \"],\n            text_justification(\n                [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], 16",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestTextJustification",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestTextJustification(unittest.TestCase):\n    def test_text_justification(self):\n        self.assertEqual(\n            [\"This    is    an\", \"example  of text\", \"justification.  \"],\n            text_justification(\n                [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], 16\n            ),\n        )\n    ##-------------------------------------------------------------------\n\"\"\"",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMinDistance",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMinDistance(unittest.TestCase):\n    def test_min_distance(self):\n        self.assertEqual(2, min_distance(\"sea\", \"eat\"))\n        self.assertEqual(6, min_distance(\"abAlgocrithmf\", \"Algorithmmd\"))\nclass TestLongestCommonPrefix(unittest.TestCase):\n    def test_longest_common_prefix(self):\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertEqual(\"fl\", longest_common_prefix_v1([\"flower\", \"flow\", \"flight\"]))\n        self.assertEqual(\"\", longest_common_prefix_v1([\"dog\", \"racecar\", \"car\"]))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestLongestCommonPrefix",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestLongestCommonPrefix(unittest.TestCase):\n    def test_longest_common_prefix(self):\n    ##-------------------------------------------------------------------\n\"\"\"\n        self.assertEqual(\"fl\", longest_common_prefix_v1([\"flower\", \"flow\", \"flight\"]))\n        self.assertEqual(\"\", longest_common_prefix_v1([\"dog\", \"racecar\", \"car\"]))\n        # Test second solution\n        self.assertEqual(\"fl\", longest_common_prefix_v2([\"flower\", \"flow\", \"flight\"]))\n        self.assertEqual(\"\", longest_common_prefix_v2([\"dog\", \"racecar\", \"car\"]))\n        # Test third solution",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestFirstUniqueChar",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestFirstUniqueChar(unittest.TestCase):\n    def test_first_unique_char(self):\n        self.assertEqual(0, first_unique_char(\"leetcode\"))\n        self.assertEqual(2, first_unique_char(\"loveleetcode\"))\n##-------------------------------------------------------------------\n\"\"\"\nclass TestRepeatSubstring(unittest.TestCase):\n    def test_repeat_substring(self):\n        self.assertTrue(repeat_substring(\"abab\"))\n        self.assertFalse(repeat_substring(\"aba\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRepeatSubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRepeatSubstring(unittest.TestCase):\n    def test_repeat_substring(self):\n        self.assertTrue(repeat_substring(\"abab\"))\n        self.assertFalse(repeat_substring(\"aba\"))\n        self.assertTrue(repeat_substring(\"abcabcabcabc\"))\nclass TestAtbashCipher(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file atbash_cipher.py\n    Arguments:\n    ##-------------------------------------------------------------------",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestAtbashCipher",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestAtbashCipher(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file atbash_cipher.py\n    Arguments:\n    ##-------------------------------------------------------------------\n\"\"\"\n    \"\"\"\n    def test_atbash_cipher(self):\n        self.assertEqual(\"zyxwvutsrqponml\", atbash(\"abcdefghijklmno\"))\n        self.assertEqual(\"KbgslM\", atbash(\"PythoN\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestLongestPalindromicSubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestLongestPalindromicSubstring(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file longest_palindromic_substring.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_longest_palindromic_substring(self):\n        self.assertEqual(\"bb\", longest_palindrome(\"cbbd\"))\n        self.assertEqual(\"abba\", longest_palindrome(\"abba\"))\n        self.assertEqual(\"asdadsa\", longest_palindrome(\"dasdasdasdasdasdadsa\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestKnuthMorrisPratt",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestKnuthMorrisPratt(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file knuth_morris_pratt.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_knuth_morris_pratt(self):\n        self.assertEqual([0, 1, 2, 3, 4], knuth_morris_pratt(\"aaaaaaa\", \"aaa\"))\n        self.assertEqual([0, 4], knuth_morris_pratt(\"abcdabc\", \"abc\"))\n        self.assertEqual([], knuth_morris_pratt(\"aabcdaab\", \"aba\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestPanagram",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestPanagram(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file panagram.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_empty_string(self):\n        # Arrange\n        string = \"\"\n        # Act",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass TestTraversal(unittest.TestCase):\n    def test_preorder(self):\n        tree = create_tree()\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder(tree))\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder_rec(tree))",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestTraversal",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestTraversal(unittest.TestCase):\n    def test_preorder(self):\n        tree = create_tree()\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder(tree))\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder_rec(tree))\n    def test_postorder(self):\n        tree = create_tree()\n        self.assertEqual([25, 75, 50, 125, 175, 150, 100], postorder(tree))\n        self.assertEqual([25, 75, 50, 125, 175, 150, 100], postorder_rec(tree))\n    def test_inorder(self):",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestBTree",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestBTree(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        import random\n        random.seed(18719)\n        cls.random = random\n        cls.range = 10000\n    def setUp(self):\n        self.keys_to_insert = [\n            self.random.randrange(-self.range, self.range) for i in range(self.range)",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestConstructTreePreorderPostorder",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestConstructTreePreorderPostorder(unittest.TestCase):\n    def test_construct_tree(self):\n        # Test 1\n        ctpp.pre_index = 0\n        pre1 = [1, 2, 4, 8, 9, 5, 3, 6, 7]\n        post1 = [8, 9, 4, 5, 2, 6, 7, 3, 1]\n        size1 = len(pre1)\n        self.assertEqual(\n            ctpp.construct_tree(pre1, post1, size1), [8, 4, 9, 2, 5, 1, 6, 3, 7]\n        )",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestFenwickTree",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestFenwickTree(unittest.TestCase):\n    def test_construct_tree_with_update_1(self):\n        freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]\n        ft = Fenwick_Tree(freq)\n        bit_tree = ft.construct()\n        self.assertEqual(12, ft.get_sum(bit_tree, 5))\n        freq[3] += 6\n        ft.update_bit(bit_tree, 3, 6)\n        self.assertEqual(18, ft.get_sum(bit_tree, 5))\n    def test_construct_tree_with_update_2(self):",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "create_tree",
        "kind": 2,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "def create_tree():\n    n1 = Node(100)\n    n2 = Node(50)\n    n3 = Node(150)\n    n4 = Node(25)\n    n5 = Node(75)\n    n6 = Node(125)\n    n7 = Node(175)\n    n1.left, n1.right = n2, n3\n    n2.left, n2.right = n4, n5",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestUnixPath",
        "kind": 6,
        "importPath": "algorithms.tests.test_unix",
        "description": "algorithms.tests.test_unix",
        "peekOfCode": "class TestUnixPath(unittest.TestCase):\n    def test_join_with_slash(self):\n        self.assertEqual(\"path/to/dir/file\", join_with_slash(\"path/to/dir/\", \"file\"))\n        self.assertEqual(\"path/to/dir/file\", join_with_slash(\"path/to/dir\", \"file\"))\n        self.assertEqual(\n            \"http://algorithms/part\", join_with_slash(\"http://algorithms\", \"part\")\n        )\n        self.assertEqual(\n            \"http://algorithms/part\", join_with_slash(\"http://algorithms/\", \"part\")\n        )",
        "detail": "algorithms.tests.test_unix",
        "documentation": {}
    },
    {
        "label": "long_description",
        "kind": 2,
        "importPath": "algorithms.setup",
        "description": "algorithms.setup",
        "peekOfCode": "def long_description():\n    with io.open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n        readme = f.read()\n    return readme\nsetup(\n    name=\"algorithms\",\n    version=\"0.1.4\",\n    description=\"Pythonic Data Structures and Algorithms\",\n    long_description=long_description(),\n    long_description_content_type=\"text/markdown\",",
        "detail": "algorithms.setup",
        "documentation": {}
    }
]