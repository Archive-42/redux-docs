[
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heapify",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappushpop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heapreplace",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heapify",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappush",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "PriorityQueue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "DirectedGraph",
        "importPath": "algorithms.graph.graph",
        "description": "algorithms.graph.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph.graph",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ascii_letters",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ascii_lowercase",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "gcd",
        "importPath": "algorithms.maths.gcd",
        "description": "algorithms.maths.gcd",
        "isExtraImport": true,
        "detail": "algorithms.maths.gcd",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "fractions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fractions",
        "description": "fractions",
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Rational",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Monomial",
        "importPath": "polynomial",
        "description": "polynomial",
        "isExtraImport": true,
        "detail": "polynomial",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "importPath": "polynomial",
        "description": "polynomial",
        "isExtraImport": true,
        "detail": "polynomial",
        "documentation": {}
    },
    {
        "label": "lcm",
        "importPath": "gcd",
        "description": "gcd",
        "isExtraImport": true,
        "detail": "gcd",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "urllib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib",
        "description": "urllib",
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "tree.tree",
        "description": "tree.tree",
        "isExtraImport": true,
        "detail": "tree.tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "tree.tree",
        "description": "tree.tree",
        "isExtraImport": true,
        "detail": "tree.tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "tree.tree",
        "description": "tree.tree",
        "isExtraImport": true,
        "detail": "tree.tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "bst",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "bst",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "bst",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "bst",
        "importPath": "bst",
        "description": "bst",
        "isExtraImport": true,
        "detail": "bst",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "tree",
        "description": "tree",
        "isExtraImport": true,
        "detail": "tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "tree",
        "description": "tree",
        "isExtraImport": true,
        "detail": "tree",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "CommonMarkParser",
        "importPath": "recommonmark.parser",
        "description": "recommonmark.parser",
        "isExtraImport": true,
        "detail": "recommonmark.parser",
        "documentation": {}
    },
    {
        "label": "delete_nth",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "delete_nth_naive",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "flatten_iter",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "flatten",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "garage",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "josephus",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "longest_non_repeat_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "longest_non_repeat_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "get_longest_non_repeat_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "get_longest_non_repeat_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "Interval",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "merge_intervals",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "missing_ranges",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "move_zeros",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "plus_one_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "plus_one_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "plus_one_v3",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "rotate_v1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "rotate_v2",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "rotate_v3",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "summarize_ranges",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "three_sum",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "two_sum",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "max_ones_index",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "trimmean",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "top_1",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "limit",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "n_sum",
        "importPath": "algorithms.arrays",
        "description": "algorithms.arrays",
        "isExtraImport": true,
        "detail": "algorithms.arrays",
        "documentation": {}
    },
    {
        "label": "DFA",
        "importPath": "algorithms.automata",
        "description": "algorithms.automata",
        "isExtraImport": true,
        "detail": "algorithms.automata",
        "documentation": {}
    },
    {
        "label": "add_operators",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute_iter",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "anagram",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "array_sum_combinations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "unique_array_sum_combinations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "combination_sum",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "get_factors",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "recursive_get_factors",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "find_words",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "generate_abbreviations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "generate_parenthesis_v1",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "generate_parenthesis_v2",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "letter_combinations",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "palindromic_substrings",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "pattern_match",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute_unique",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "permute_recursive",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "subsets_unique",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "subsets",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "subsets_v2",
        "importPath": "algorithms.backtrack",
        "description": "algorithms.backtrack",
        "isExtraImport": true,
        "detail": "algorithms.backtrack",
        "documentation": {}
    },
    {
        "label": "count_islands",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "maze_search",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "shortest_distance_from_all_buildings",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "ladder_length",
        "importPath": "algorithms.bfs",
        "description": "algorithms.bfs",
        "isExtraImport": true,
        "detail": "algorithms.bfs",
        "documentation": {}
    },
    {
        "label": "add_bitwise_operator",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "count_ones_iter",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "count_ones_recur",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "count_flips_to_convert",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "find_missing_number",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "find_missing_number2",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "flip_bit_longest_seq",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "is_power_of_two",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "reverse_bits",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "single_number",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "single_number2",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "single_number3",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "subsets",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "get_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "set_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "clear_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "update_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "int_to_bytes_big_endian",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "int_to_bytes_little_endian",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "bytes_big_endian_to_int",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "bytes_little_endian_to_int",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "swap_pair",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "find_difference",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "has_alternative_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "has_alternative_bit_fast",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "insert_one_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "insert_mult_bits",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "remove_bit",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "binary_gap",
        "importPath": "algorithms.bit",
        "description": "algorithms.bit",
        "isExtraImport": true,
        "detail": "algorithms.bit",
        "documentation": {}
    },
    {
        "label": "HuffmanCoding",
        "importPath": "algorithms.compression.huffman_coding",
        "description": "algorithms.compression.huffman_coding",
        "isExtraImport": true,
        "detail": "algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "decode_rle",
        "importPath": "algorithms.compression.rle_compression",
        "description": "algorithms.compression.rle_compression",
        "isExtraImport": true,
        "detail": "algorithms.compression.rle_compression",
        "documentation": {}
    },
    {
        "label": "encode_rle",
        "importPath": "algorithms.compression.rle_compression",
        "description": "algorithms.compression.rle_compression",
        "isExtraImport": true,
        "detail": "algorithms.compression.rle_compression",
        "documentation": {}
    },
    {
        "label": "elias_gamma",
        "importPath": "algorithms.compression.elias",
        "description": "algorithms.compression.elias",
        "isExtraImport": true,
        "detail": "algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "elias_delta",
        "importPath": "algorithms.compression.elias",
        "description": "algorithms.compression.elias",
        "isExtraImport": true,
        "detail": "algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "get_factors",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "get_factors_iterative1",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "get_factors_iterative2",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "num_islands",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "pacific_atlantic",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "Sudoku",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "walls_and_gates",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "find_path",
        "importPath": "algorithms.dfs",
        "description": "algorithms.dfs",
        "isExtraImport": true,
        "detail": "algorithms.dfs",
        "documentation": {}
    },
    {
        "label": "max_profit_naive",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "max_profit_optimized",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "climb_stairs",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "climb_stairs_optimized",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "count",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "combination_sum_topdown",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "combination_sum_bottom_up",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "edit_distance",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "egg_drop",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "fib_recursive",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "fib_list",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "fib_iter",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "hosoya_testing",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "house_robber",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "Job",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "schedule",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "get_maximum_value",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence_optimized",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence_optimized2",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "int_divide",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "find_k_factor",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "planting_trees",
        "importPath": "algorithms.dp",
        "description": "algorithms.dp",
        "isExtraImport": true,
        "detail": "algorithms.dp",
        "documentation": {}
    },
    {
        "label": "Tarjan",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "check_bipartite",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "ford_fulkerson",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "edmonds_karp",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "dinic",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "maximum_flow_bfs",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "maximum_flow_dfs",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "all_pairs_shortest_path",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "bellman_ford",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "bellman_ford",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "count_connected_number_of_component",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "prims_minimum_spanning",
        "importPath": "algorithms.graph",
        "description": "algorithms.graph",
        "isExtraImport": true,
        "detail": "algorithms.graph",
        "documentation": {}
    },
    {
        "label": "Dijkstra",
        "importPath": "algorithms.graph.dijkstra",
        "description": "algorithms.graph.dijkstra",
        "isExtraImport": true,
        "detail": "algorithms.graph.dijkstra",
        "documentation": {}
    },
    {
        "label": "BinaryHeap",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "get_skyline",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "max_sliding_window",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "k_closest",
        "importPath": "algorithms.heap",
        "description": "algorithms.heap",
        "isExtraImport": true,
        "detail": "algorithms.heap",
        "documentation": {}
    },
    {
        "label": "get_histogram",
        "importPath": "algorithms.distribution.histogram",
        "description": "algorithms.distribution.histogram",
        "isExtraImport": true,
        "detail": "algorithms.distribution.histogram",
        "documentation": {}
    },
    {
        "label": "SegmentTree",
        "importPath": "algorithms.tree.segment_tree.iterative_segment_tree",
        "description": "algorithms.tree.segment_tree.iterative_segment_tree",
        "isExtraImport": true,
        "detail": "algorithms.tree.segment_tree.iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "reverse_list",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "reverse_list_recursive",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "remove_range",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "swap_pairs",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "rotate_right",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_cyclic",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "merge_two_list",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "merge_two_list_recur",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_palindrome_stack",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "is_palindrome_dict",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "RandomListNode",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "copy_random_pointer_v1",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "copy_random_pointer_v2",
        "importPath": "algorithms.linkedlist",
        "description": "algorithms.linkedlist",
        "isExtraImport": true,
        "detail": "algorithms.linkedlist",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "ResizableHashTable",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "SeparateChainingHashTable",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "word_pattern",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "is_isomorphic",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "longest_palindromic_subsequence",
        "importPath": "algorithms.map",
        "description": "algorithms.map",
        "isExtraImport": true,
        "detail": "algorithms.map",
        "documentation": {}
    },
    {
        "label": "power",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "power_recur",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "int_to_base",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "base_to_int",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "decimal_to_binary_ip",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "euler_totient",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "extended_gcd",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "factorial_recur",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "gcd",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "lcm",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "trailing_zero",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "gcd_bit",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "gen_strobogrammatic",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "strobogrammatic_in_range",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "is_strobogrammatic",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "is_strobogrammatic2",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "modular_inverse",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "modular_exponential",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_next_square",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_next_square2",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "prime_check",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "get_primes",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "pythagoras",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "encrypt",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "decrypt",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "combination",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "combination_memo",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "hailstone",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "magic_number",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_order",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "find_primitive_root",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "diffie_hellman_key_exchange",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "num_digits",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_private_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_public_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "alice_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "bob_shared_key",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "diffie_hellman_key_exchange",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "krishnamurthy_number",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "chinese_remainder_theorem",
        "importPath": "algorithms.maths",
        "description": "algorithms.maths",
        "isExtraImport": true,
        "detail": "algorithms.maths",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "bomb_enemy",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "copy_transform",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "crout_matrix_decomposition",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "cholesky_matrix_decomposition",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "matrix_exponentiation",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "matrix_inversion",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "multiply",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "rotate_image",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sparse_dot_vector",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "spiral_traversal",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sudoku_validator",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sum_sub_squares",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "sort_matrix_diagonally",
        "importPath": "algorithms.matrix",
        "description": "algorithms.matrix",
        "isExtraImport": true,
        "detail": "algorithms.matrix",
        "documentation": {}
    },
    {
        "label": "distance",
        "importPath": "algorithms.ml.nearest_neighbor",
        "description": "algorithms.ml.nearest_neighbor",
        "isExtraImport": true,
        "detail": "algorithms.ml.nearest_neighbor",
        "documentation": {}
    },
    {
        "label": "nearest_neighbor",
        "importPath": "algorithms.ml.nearest_neighbor",
        "description": "algorithms.ml.nearest_neighbor",
        "isExtraImport": true,
        "detail": "algorithms.ml.nearest_neighbor",
        "documentation": {}
    },
    {
        "label": "Monomial",
        "importPath": "algorithms.maths.polynomial",
        "description": "algorithms.maths.polynomial",
        "isExtraImport": true,
        "detail": "algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "importPath": "algorithms.maths.polynomial",
        "description": "algorithms.maths.polynomial",
        "isExtraImport": true,
        "detail": "algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "Monomial",
        "importPath": "algorithms.maths.polynomial",
        "description": "algorithms.maths.polynomial",
        "isExtraImport": true,
        "detail": "algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "ArrayQueue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "LinkedListQueue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "max_sliding_window",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "reconstruct_queue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "PriorityQueue",
        "importPath": "algorithms.queues",
        "description": "algorithms.queues",
        "isExtraImport": true,
        "detail": "algorithms.queues",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "binary_search_recur",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "ternary_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "first_occurrence",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "last_occurrence",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_insert",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "two_sum",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "two_sum1",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "two_sum2",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_range",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "find_min_rotate",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "find_min_rotate_recur",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_rotate",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "search_rotate_recur",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "jump_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter_v1",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter_v2",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "interpolation_search",
        "importPath": "algorithms.search",
        "description": "algorithms.search",
        "isExtraImport": true,
        "detail": "algorithms.search",
        "documentation": {}
    },
    {
        "label": "find_keyboard_row",
        "importPath": "algorithms.set",
        "description": "algorithms.set",
        "isExtraImport": true,
        "detail": "algorithms.set",
        "documentation": {}
    },
    {
        "label": "bitonic_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "bogo_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "bubble_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "comb_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "counting_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "cycle_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "max_heap_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "min_heap_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "merge_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "pancake_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "pigeonhole_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "quick_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "selection_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "bucket_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "shell_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "radix_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "gnome_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "cocktail_shaker_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "top_sort",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "top_sort_recursive",
        "importPath": "algorithms.sort",
        "description": "algorithms.sort",
        "isExtraImport": true,
        "detail": "algorithms.sort",
        "documentation": {}
    },
    {
        "label": "first_is_consecutive",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "second_is_consecutive",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "remove_min",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "first_stutter",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "second_stutter",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "first_switch_pairs",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "second_switch_pairs",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "simplify_path",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "ArrayStack",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "LinkedListStack",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "OrderedStack",
        "importPath": "algorithms.stack",
        "description": "algorithms.stack",
        "isExtraImport": true,
        "detail": "algorithms.stack",
        "documentation": {}
    },
    {
        "label": "misras_gries",
        "importPath": "algorithms.streaming.misra_gries",
        "description": "algorithms.streaming.misra_gries",
        "isExtraImport": true,
        "detail": "algorithms.streaming.misra_gries",
        "documentation": {}
    },
    {
        "label": "one_sparse",
        "importPath": "algorithms.streaming",
        "description": "algorithms.streaming",
        "isExtraImport": true,
        "detail": "algorithms.streaming",
        "documentation": {}
    },
    {
        "label": "add_binary",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "match_symbol",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "match_symbol_1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "bracket",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "decode_string",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "delete_reoccurring_characters",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "domain_name_1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "domain_name_2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "encode",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "group_anagrams",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "int_to_roman",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_reverse",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_two_pointer",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_stack",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_palindrome_deque",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_rotated",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_rotated_v1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "license_number",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "make_sentence",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_merge_recursive",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_merge_iterative",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "multiply",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_one_edit",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_one_edit2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "rabin_karp",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "ultra_pythonic",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "iterative",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "recursive",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "pythonic",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "reverse_vowel",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "reverse_words",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "roman_to_int",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strip_url_params1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strip_url_params2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strip_url_params3",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_0",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_regular_expression",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "word_squares",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "convert_morse_word",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "unique_morse",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "judge_circle",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "strong_password",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "check_pangram",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "contain_string",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "count_binary_substring",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "repeat_string",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "text_justification",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "min_distance",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v1",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v2",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v3",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "rotate",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "first_unique_char",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "repeat_substring",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "atbash",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "longest_palindrome",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "knuth_morris_pratt",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "panagram",
        "importPath": "algorithms.strings",
        "description": "algorithms.strings",
        "isExtraImport": true,
        "detail": "algorithms.strings",
        "documentation": {}
    },
    {
        "label": "preorder",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "preorder_rec",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "postorder",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "postorder_rec",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "inorder",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "inorder_rec",
        "importPath": "algorithms.tree.traversal",
        "description": "algorithms.tree.traversal",
        "isExtraImport": true,
        "detail": "algorithms.tree.traversal",
        "documentation": {}
    },
    {
        "label": "BTree",
        "importPath": "algorithms.tree.b_tree",
        "description": "algorithms.tree.b_tree",
        "isExtraImport": true,
        "detail": "algorithms.tree.b_tree",
        "documentation": {}
    },
    {
        "label": "construct_tree_postorder_preorder",
        "importPath": "algorithms.tree",
        "description": "algorithms.tree",
        "isExtraImport": true,
        "detail": "algorithms.tree",
        "documentation": {}
    },
    {
        "label": "Fenwick_Tree",
        "importPath": "algorithms.tree.fenwick_tree.fenwick_tree",
        "description": "algorithms.tree.fenwick_tree.fenwick_tree",
        "isExtraImport": true,
        "detail": "algorithms.tree.fenwick_tree.fenwick_tree",
        "documentation": {}
    },
    {
        "label": "join_with_slash",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "full_path",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "simplify_path_v1",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "simplify_path_v2",
        "importPath": "algorithms.unix",
        "description": "algorithms.unix",
        "isExtraImport": true,
        "detail": "algorithms.unix",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "delete_nth_naive",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.delete_nth",
        "description": "algorithms.algorithms.arrays.delete_nth",
        "peekOfCode": "def delete_nth_naive(array, n):\n    ans = []\n    for num in array:\n        if ans.count(num) < n:\n            ans.append(num)\n    return ans\n# Time Complexity O(n), using hash tables.\ndef delete_nth(array, n):\n    result = []\n    counts = collections.defaultdict(int)  # keep track of occurrences",
        "detail": "algorithms.algorithms.arrays.delete_nth",
        "documentation": {}
    },
    {
        "label": "delete_nth",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.delete_nth",
        "description": "algorithms.algorithms.arrays.delete_nth",
        "peekOfCode": "def delete_nth(array, n):\n    result = []\n    counts = collections.defaultdict(int)  # keep track of occurrences\n    for i in array:\n        if counts[i] < n:\n            result.append(i)\n            counts[i] += 1\n    return result",
        "detail": "algorithms.algorithms.arrays.delete_nth",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.flatten",
        "description": "algorithms.algorithms.arrays.flatten",
        "peekOfCode": "def flatten(input_arr, output_arr=None):\n    if output_arr is None:\n        output_arr = []\n    for ele in input_arr:\n        if not isinstance(ele, str) and isinstance(ele, Iterable):\n            flatten(ele, output_arr)    #tail-recursion\n        else:\n            output_arr.append(ele)      #produce the result\n    return output_arr\n# returns iterator",
        "detail": "algorithms.algorithms.arrays.flatten",
        "documentation": {}
    },
    {
        "label": "flatten_iter",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.flatten",
        "description": "algorithms.algorithms.arrays.flatten",
        "peekOfCode": "def flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)    \n        else:\n            yield element",
        "detail": "algorithms.algorithms.arrays.flatten",
        "documentation": {}
    },
    {
        "label": "garage",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.garage",
        "description": "algorithms.algorithms.arrays.garage",
        "peekOfCode": "def garage(initial, final):\n    initial = initial[::]      # prevent changes in original 'initial'\n    seq = []                   # list of each step in sequence\n    steps = 0\n    while initial != final:\n        zero = initial.index(0)\n        if zero != final.index(0):  # if zero isn't where it should be,\n            car_to_move = final[zero]   # what should be where zero is,\n            pos = initial.index(car_to_move)         # and where is it?\n            initial[zero], initial[pos] = initial[pos], initial[zero]",
        "detail": "algorithms.algorithms.arrays.garage",
        "documentation": {}
    },
    {
        "label": "Steps",
        "kind": 5,
        "importPath": "algorithms.algorithms.arrays.garage",
        "description": "algorithms.algorithms.arrays.garage",
        "peekOfCode": "Steps =  4\nSequence : \n0 2 3 1 4\n2 0 3 1 4\n2 3 0 1 4\n0 3 2 1 4\n\"\"\"\ndef garage(initial, final):\n    initial = initial[::]      # prevent changes in original 'initial'\n    seq = []                   # list of each step in sequence",
        "detail": "algorithms.algorithms.arrays.garage",
        "documentation": {}
    },
    {
        "label": "josephus",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.josephus",
        "description": "algorithms.algorithms.arrays.josephus",
        "peekOfCode": "def josephus(int_list, skip):\n    skip = skip - 1                     # list starts with 0 index\n    idx = 0\n    len_list = (len(int_list))\n    while len_list > 0:\n        idx = (skip + idx) % len_list   # hash index to every 3rd\n        yield int_list.pop(idx)\n        len_list -= 1",
        "detail": "algorithms.algorithms.arrays.josephus",
        "documentation": {}
    },
    {
        "label": "limit",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.limit",
        "description": "algorithms.algorithms.arrays.limit",
        "peekOfCode": "def limit(arr, min_lim=None, max_lim=None):\n    min_check = lambda val: True if min_lim is None else (min_lim <= val)\n    max_check = lambda val: True if max_lim is None else (val <= max_lim)\n    return [val for val in arr if min_check(val) and max_check(val)]",
        "detail": "algorithms.algorithms.arrays.limit",
        "documentation": {}
    },
    {
        "label": "Complexity",
        "kind": 5,
        "importPath": "algorithms.algorithms.arrays.limit",
        "description": "algorithms.algorithms.arrays.limit",
        "peekOfCode": "Complexity = O(n)\n\"\"\"\n# tl:dr -- array slicing by value\ndef limit(arr, min_lim=None, max_lim=None):\n    min_check = lambda val: True if min_lim is None else (min_lim <= val)\n    max_check = lambda val: True if max_lim is None else (val <= max_lim)\n    return [val for val in arr if min_check(val) and max_check(val)]",
        "detail": "algorithms.algorithms.arrays.limit",
        "documentation": {}
    },
    {
        "label": "longest_non_repeat_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.longest_non_repeat",
        "description": "algorithms.algorithms.arrays.longest_non_repeat",
        "peekOfCode": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0",
        "detail": "algorithms.algorithms.arrays.longest_non_repeat",
        "documentation": {}
    },
    {
        "label": "longest_non_repeat_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.longest_non_repeat",
        "description": "algorithms.algorithms.arrays.longest_non_repeat",
        "peekOfCode": "def longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if string is None:\n        return 0\n    start, max_len = 0, 0\n    used_char = {}",
        "detail": "algorithms.algorithms.arrays.longest_non_repeat",
        "documentation": {}
    },
    {
        "label": "get_longest_non_repeat_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.longest_non_repeat",
        "description": "algorithms.algorithms.arrays.longest_non_repeat",
        "peekOfCode": "def get_longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    if string is None:\n        return 0, ''\n    sub_string = ''\n    dict = {}",
        "detail": "algorithms.algorithms.arrays.longest_non_repeat",
        "documentation": {}
    },
    {
        "label": "get_longest_non_repeat_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.longest_non_repeat",
        "description": "algorithms.algorithms.arrays.longest_non_repeat",
        "peekOfCode": "def get_longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    if string is None:\n        return 0, ''\n    sub_string = ''",
        "detail": "algorithms.algorithms.arrays.longest_non_repeat",
        "documentation": {}
    },
    {
        "label": "max_ones_index",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.max_ones_index",
        "description": "algorithms.algorithms.arrays.max_ones_index",
        "peekOfCode": "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    for curr in range(n):\n        # If current element is 0,\n        # then calculate the difference\n        # between curr and prev_prev_zero",
        "detail": "algorithms.algorithms.arrays.max_ones_index",
        "documentation": {}
    },
    {
        "label": "Interval",
        "kind": 6,
        "importPath": "algorithms.algorithms.arrays.merge_intervals",
        "description": "algorithms.algorithms.arrays.merge_intervals",
        "peekOfCode": "class Interval:\n    \"\"\"\n    A set of real numbers with methods to determine if other\n     numbers are included in the set.\n    Includes related methods to merge and print interval sets.\n    \"\"\"\n    def __init__(self, start=0, end=0):\n        self.start = start\n        self.end = end\n    def __repr__(self):",
        "detail": "algorithms.algorithms.arrays.merge_intervals",
        "documentation": {}
    },
    {
        "label": "merge_intervals",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.merge_intervals",
        "description": "algorithms.algorithms.arrays.merge_intervals",
        "peekOfCode": "def merge_intervals(intervals):\n    \"\"\" Merge intervals in the form of a list. \"\"\"\n    if intervals is None:\n        return None\n    intervals.sort(key=lambda i: i[0])\n    out = [intervals.pop(0)]\n    for i in intervals:\n        if out[-1][-1] >= i[0]:\n            out[-1][-1] = max(out[-1][-1], i[-1])\n        else:",
        "detail": "algorithms.algorithms.arrays.merge_intervals",
        "documentation": {}
    },
    {
        "label": "missing_ranges",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.missing_ranges",
        "description": "algorithms.algorithms.arrays.missing_ranges",
        "peekOfCode": "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n-1))\n            start = n + 1\n    if start <= hi:                 # after done iterating thru array,",
        "detail": "algorithms.algorithms.arrays.missing_ranges",
        "documentation": {}
    },
    {
        "label": "move_zeros",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.move_zeros",
        "description": "algorithms.algorithms.arrays.move_zeros",
        "peekOfCode": "def move_zeros(array):\n    result = []\n    zeros = 0\n    for i in array:\n            if i == 0 and type(i) != bool:  # not using `not i` to avoid `False`, `[]`, etc.\n                zeros += 1\n            else:\n                result.append(i)\n    result.extend([0] * zeros)\n    return result",
        "detail": "algorithms.algorithms.arrays.move_zeros",
        "documentation": {}
    },
    {
        "label": "n_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.n_sum",
        "description": "algorithms.algorithms.arrays.n_sum",
        "peekOfCode": "def n_sum(n, nums, target, **kv):\n    \"\"\"\n    n: int\n    nums: list[object]\n    target: object\n    sum_closure: function, optional\n        Given two elements of nums, return sum of both.\n    compare_closure: function, optional\n        Given one object of nums and target, return -1, 1, or 0.\n    same_closure: function, optional",
        "detail": "algorithms.algorithms.arrays.n_sum",
        "documentation": {}
    },
    {
        "label": "plus_one_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.plus_one",
        "description": "algorithms.algorithms.arrays.plus_one",
        "peekOfCode": "def plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits)-1\n    while i >= 0 or ten == 1:",
        "detail": "algorithms.algorithms.arrays.plus_one",
        "documentation": {}
    },
    {
        "label": "plus_one_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.plus_one",
        "description": "algorithms.algorithms.arrays.plus_one",
        "peekOfCode": "def plus_one_v2(digits):\n    n = len(digits)\n    for i in range(n-1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    digits.insert(0, 1)\n    return digits\ndef plus_one_v3(num_arr):",
        "detail": "algorithms.algorithms.arrays.plus_one",
        "documentation": {}
    },
    {
        "label": "plus_one_v3",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.plus_one",
        "description": "algorithms.algorithms.arrays.plus_one",
        "peekOfCode": "def plus_one_v3(num_arr):\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if num_arr[idx[0]]:\n            return num_arr\n    return [1] + num_arr",
        "detail": "algorithms.algorithms.arrays.plus_one",
        "documentation": {}
    },
    {
        "label": "rotate_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.rotate",
        "description": "algorithms.algorithms.arrays.rotate",
        "peekOfCode": "def rotate_v1(array, k):\n    \"\"\"\n    Rotate the entire array 'k' times\n    T(n)- O(nk)\n    :type array: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify array in-place instead.\n    \"\"\"\n    array = array[:]\n    n = len(array)",
        "detail": "algorithms.algorithms.arrays.rotate",
        "documentation": {}
    },
    {
        "label": "rotate_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.rotate",
        "description": "algorithms.algorithms.arrays.rotate",
        "peekOfCode": "def rotate_v2(array, k):\n    \"\"\"\n    Reverse segments of the array, followed by the entire array\n    T(n)- O(n)\n    :type array: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    array = array[:]\n    def reverse(arr, a, b):",
        "detail": "algorithms.algorithms.arrays.rotate",
        "documentation": {}
    },
    {
        "label": "rotate_v3",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.rotate",
        "description": "algorithms.algorithms.arrays.rotate",
        "peekOfCode": "def rotate_v3(array, k):\n    if array is None:\n        return None\n    length = len(array)\n    k = k % length\n    return array[length - k:] + array[:length - k]",
        "detail": "algorithms.algorithms.arrays.rotate",
        "documentation": {}
    },
    {
        "label": "summarize_ranges",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.summarize_ranges",
        "description": "algorithms.algorithms.arrays.summarize_ranges",
        "peekOfCode": "def summarize_ranges(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: List[]\n    \"\"\"\n    res = []\n    if len(array) == 1:\n        return [str(array[0])]\n    i = 0\n    while i < len(array):",
        "detail": "algorithms.algorithms.arrays.summarize_ranges",
        "documentation": {}
    },
    {
        "label": "three_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.three_sum",
        "description": "algorithms.algorithms.arrays.three_sum",
        "peekOfCode": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if i > 0 and array[i] == array[i - 1]:\n            continue",
        "detail": "algorithms.algorithms.arrays.three_sum",
        "documentation": {}
    },
    {
        "label": "top_1",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.top_1",
        "description": "algorithms.algorithms.arrays.top_1",
        "peekOfCode": "def top_1(arr):\n    values = {}\n    # reserve each value which first appears on keys\n    # reserve how many time each value appears by index number on values\n    result = []\n    f_val = 0\n    for i in arr:\n        if i in values:\n            values[i] += 1\n        else:",
        "detail": "algorithms.algorithms.arrays.top_1",
        "documentation": {}
    },
    {
        "label": "trimmean",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.trimmean",
        "description": "algorithms.algorithms.arrays.trimmean",
        "peekOfCode": "def trimmean(arr, per):\n    ratio = per/200\n    # /100 for easy calculation by *, and /2 for easy adaption to best and worst parts.\n    cal_sum = 0\n    # sum value to be calculated to trimmean.\n    arr.sort()\n    neg_val = int(len(arr)*ratio)\n    arr = arr[neg_val:len(arr)-neg_val]\n    for i in arr:\n        cal_sum += i",
        "detail": "algorithms.algorithms.arrays.trimmean",
        "documentation": {}
    },
    {
        "label": "two_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.arrays.two_sum",
        "description": "algorithms.algorithms.arrays.two_sum",
        "peekOfCode": "def two_sum(array, target):\n    dic = {}\n    for i, num in enumerate(array):\n        if num in dic:\n            return dic[num], i\n        else:\n            dic[target - num] = i\n    return None",
        "detail": "algorithms.algorithms.arrays.two_sum",
        "documentation": {}
    },
    {
        "label": "add_operators",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.add_operators",
        "description": "algorithms.algorithms.backtrack.add_operators",
        "peekOfCode": "def add_operators(num, target):\n    \"\"\"\n    :type num: str\n    :type target: int\n    :rtype: List[str]\n    \"\"\"\n    def dfs(res, path, num, target, pos, prev, multed):\n        if pos == len(num):\n            if target == prev:\n                res.append(path)",
        "detail": "algorithms.algorithms.backtrack.add_operators",
        "documentation": {}
    },
    {
        "label": "anagram",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.anagram",
        "description": "algorithms.algorithms.backtrack.anagram",
        "peekOfCode": "def anagram(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n    for c in s1:\n        pos = ord(c)-ord('a')\n        c1[pos] = c1[pos] + 1\n    for c in s2:\n        pos = ord(c)-ord('a')\n        c2[pos] = c2[pos] + 1\n    return c1 == c2",
        "detail": "algorithms.algorithms.backtrack.anagram",
        "documentation": {}
    },
    {
        "label": "array_sum_combinations",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.array_sum_combinations",
        "description": "algorithms.algorithms.backtrack.array_sum_combinations",
        "peekOfCode": "def array_sum_combinations(A, B, C, target):\n    def over(constructed_sofar):\n        sum = 0\n        to_stop, reached_target = False, False\n        for elem in constructed_sofar:\n            sum += elem\n        if sum >= target or len(constructed_sofar) >= 3:\n            to_stop = True\n            if sum == target and 3 == len(constructed_sofar):\n                reached_target = True",
        "detail": "algorithms.algorithms.backtrack.array_sum_combinations",
        "documentation": {}
    },
    {
        "label": "unique_array_sum_combinations",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.array_sum_combinations",
        "description": "algorithms.algorithms.backtrack.array_sum_combinations",
        "peekOfCode": "def unique_array_sum_combinations(A, B, C, target):\n    \"\"\"\n    1. Sort all the arrays - a,b,c. - This improves average time complexity.\n    2. If c[i] < Sum, then look for Sum - c[i] in array a and b.\n       When pair found, insert c[i], a[j] & b[k] into the result list.\n       This can be done in O(n).\n    3. Keep on doing the above procedure while going through complete c array.\n    Complexity: O(n(m+p))\n    \"\"\"\n    def check_sum(n, *nums):",
        "detail": "algorithms.algorithms.backtrack.array_sum_combinations",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.array_sum_combinations",
        "description": "algorithms.algorithms.backtrack.array_sum_combinations",
        "peekOfCode": "A = [1, 2, 3, 3]\nB = [2, 3, 3, 4]\nC = [2, 3, 3, 4]\ntarget = 7\n*/\nResult:\n[[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2],\n [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n\"\"\"\nimport itertools",
        "detail": "algorithms.algorithms.backtrack.array_sum_combinations",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.array_sum_combinations",
        "description": "algorithms.algorithms.backtrack.array_sum_combinations",
        "peekOfCode": "B = [2, 3, 3, 4]\nC = [2, 3, 3, 4]\ntarget = 7\n*/\nResult:\n[[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2],\n [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n\"\"\"\nimport itertools\nfrom functools import partial",
        "detail": "algorithms.algorithms.backtrack.array_sum_combinations",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.array_sum_combinations",
        "description": "algorithms.algorithms.backtrack.array_sum_combinations",
        "peekOfCode": "C = [2, 3, 3, 4]\ntarget = 7\n*/\nResult:\n[[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2],\n [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n\"\"\"\nimport itertools\nfrom functools import partial\ndef array_sum_combinations(A, B, C, target):",
        "detail": "algorithms.algorithms.backtrack.array_sum_combinations",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.array_sum_combinations",
        "description": "algorithms.algorithms.backtrack.array_sum_combinations",
        "peekOfCode": "target = 7\n*/\nResult:\n[[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2],\n [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n\"\"\"\nimport itertools\nfrom functools import partial\ndef array_sum_combinations(A, B, C, target):\n    def over(constructed_sofar):",
        "detail": "algorithms.algorithms.backtrack.array_sum_combinations",
        "documentation": {}
    },
    {
        "label": "combination_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.combination_sum",
        "description": "algorithms.algorithms.backtrack.combination_sum",
        "peekOfCode": "def combination_sum(candidates, target):\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target-nums[i], i, path+[nums[i]], res)\n    res = []",
        "detail": "algorithms.algorithms.backtrack.combination_sum",
        "documentation": {}
    },
    {
        "label": "get_factors",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.factor_combinations",
        "description": "algorithms.algorithms.backtrack.factor_combinations",
        "peekOfCode": "def get_factors(n):\n    todo, combis = [(n, 2, [])], []\n    while todo:\n        n, i, combi = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n//i])\n                todo.append((n//i, i, combi+[i]))\n            i += 1\n    return combis",
        "detail": "algorithms.algorithms.backtrack.factor_combinations",
        "documentation": {}
    },
    {
        "label": "recursive_get_factors",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.factor_combinations",
        "description": "algorithms.algorithms.backtrack.factor_combinations",
        "peekOfCode": "def recursive_get_factors(n):\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n//i]),\n                factor(n//i, i, combi+[i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])",
        "detail": "algorithms.algorithms.backtrack.factor_combinations",
        "documentation": {}
    },
    {
        "label": "8",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.factor_combinations",
        "description": "algorithms.algorithms.backtrack.factor_combinations",
        "peekOfCode": "8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n\nand return all possible combinations of its factors.\nNote:\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples:\ninput: 1\noutput:",
        "detail": "algorithms.algorithms.backtrack.factor_combinations",
        "documentation": {}
    },
    {
        "label": "find_words",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.find_words",
        "description": "algorithms.algorithms.backtrack.find_words",
        "peekOfCode": "def find_words(board, words):\n    def backtrack(board, i, j, trie, pre, used, result):\n        '''\n        backtrack tries to build each words from\n        the board and return all words found\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs",
        "detail": "algorithms.algorithms.backtrack.find_words",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.find_words",
        "description": "algorithms.algorithms.backtrack.find_words",
        "peekOfCode": "board = [\n         ['o','a','a','n'],\n         ['e','t','a','e'],\n         ['i','h','k','r'],\n         ['i','f','l','v']\n         ]\nwords = [\"oath\",\"pea\",\"eat\",\"rain\"]\n'''\ndef find_words(board, words):\n    def backtrack(board, i, j, trie, pre, used, result):",
        "detail": "algorithms.algorithms.backtrack.find_words",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.find_words",
        "description": "algorithms.algorithms.backtrack.find_words",
        "peekOfCode": "words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n'''\ndef find_words(board, words):\n    def backtrack(board, i, j, trie, pre, used, result):\n        '''\n        backtrack tries to build each words from\n        the board and return all words found\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index",
        "detail": "algorithms.algorithms.backtrack.find_words",
        "documentation": {}
    },
    {
        "label": "generate_abbreviations",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.generate_abbreviations",
        "description": "algorithms.algorithms.backtrack.generate_abbreviations",
        "peekOfCode": "def generate_abbreviations(word):\n    def backtrack(result, word, pos, count, cur):\n        if pos == len(word):\n            if count > 0:\n                cur += str(count)\n            result.append(cur)\n            return\n        if count > 0:  # add the current word\n            backtrack(result, word, pos+1, 0, cur+str(count)+word[pos])\n        else:",
        "detail": "algorithms.algorithms.backtrack.generate_abbreviations",
        "documentation": {}
    },
    {
        "label": "generate_parenthesis_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.generate_parenthesis",
        "description": "algorithms.algorithms.backtrack.generate_parenthesis",
        "peekOfCode": "def generate_parenthesis_v1(n):\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n            return\n        if right > 0:\n            add_pair(res, s + \")\", left, right - 1)\n        if left > 0:\n            add_pair(res, s + \"(\", left - 1, right + 1)\n    res = []",
        "detail": "algorithms.algorithms.backtrack.generate_parenthesis",
        "documentation": {}
    },
    {
        "label": "generate_parenthesis_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.generate_parenthesis",
        "description": "algorithms.algorithms.backtrack.generate_parenthesis",
        "peekOfCode": "def generate_parenthesis_v2(n):\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n        if left > 0:\n            add_pair(res, s + \"(\", left - 1, right)\n        if right > 0 and left < right:\n            add_pair(res, s + \")\", left, right - 1)\n    res = []\n    add_pair(res, \"\", n, n)",
        "detail": "algorithms.algorithms.backtrack.generate_parenthesis",
        "documentation": {}
    },
    {
        "label": "letter_combinations",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.letter_combination",
        "description": "algorithms.algorithms.backtrack.letter_combination",
        "peekOfCode": "def letter_combinations(digits):\n    if digits == \"\":\n        return []\n    kmaps = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",",
        "detail": "algorithms.algorithms.backtrack.letter_combination",
        "documentation": {}
    },
    {
        "label": "palindromic_substrings",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.palindrome_partitioning",
        "description": "algorithms.algorithms.backtrack.palindrome_partitioning",
        "peekOfCode": "def palindromic_substrings(s):\n    if not s:\n        return [[]]\n    results = []\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings(s[i:]):\n                results.append([sub] + rest)\n    return results",
        "detail": "algorithms.algorithms.backtrack.palindrome_partitioning",
        "documentation": {}
    },
    {
        "label": "palindromic_substrings_iter",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.palindrome_partitioning",
        "description": "algorithms.algorithms.backtrack.palindrome_partitioning",
        "peekOfCode": "def palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:",
        "detail": "algorithms.algorithms.backtrack.palindrome_partitioning",
        "documentation": {}
    },
    {
        "label": "pattern_match",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.pattern_match",
        "description": "algorithms.algorithms.backtrack.pattern_match",
        "peekOfCode": "def pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    def backtrack(pattern, string, dic):\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n        if len(pattern) == len(string) == 0:",
        "detail": "algorithms.algorithms.backtrack.pattern_match",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.pattern_match",
        "description": "algorithms.algorithms.backtrack.pattern_match",
        "peekOfCode": "pattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.\n\"\"\"\ndef pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str",
        "detail": "algorithms.algorithms.backtrack.pattern_match",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.pattern_match",
        "description": "algorithms.algorithms.backtrack.pattern_match",
        "peekOfCode": "pattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.\n\"\"\"\ndef pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool",
        "detail": "algorithms.algorithms.backtrack.pattern_match",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "algorithms.algorithms.backtrack.pattern_match",
        "description": "algorithms.algorithms.backtrack.pattern_match",
        "peekOfCode": "pattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.\n\"\"\"\ndef pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool\n    \"\"\"",
        "detail": "algorithms.algorithms.backtrack.pattern_match",
        "documentation": {}
    },
    {
        "label": "permute",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.permute",
        "description": "algorithms.algorithms.backtrack.permute",
        "peekOfCode": "def permute(elements):\n    \"\"\"\n        returns a list with the permuations.\n    \"\"\"\n    if len(elements) <= 1:\n        return [elements]\n    else:\n        tmp = []\n        for perm in permute(elements[1:]):\n            for i in range(len(elements)):",
        "detail": "algorithms.algorithms.backtrack.permute",
        "documentation": {}
    },
    {
        "label": "permute_iter",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.permute",
        "description": "algorithms.algorithms.backtrack.permute",
        "peekOfCode": "def permute_iter(elements):\n    \"\"\"\n        iterator: returns a perumation by each call.\n    \"\"\"\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in permute_iter(elements[1:]):\n            for i in range(len(elements)):\n                yield perm[:i] + elements[0:1] + perm[i:]",
        "detail": "algorithms.algorithms.backtrack.permute",
        "documentation": {}
    },
    {
        "label": "permute_recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.permute",
        "description": "algorithms.algorithms.backtrack.permute",
        "peekOfCode": "def permute_recursive(nums):\n    def dfs(res, nums, path):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            print(nums[:i]+nums[i+1:])\n            dfs(res, nums[:i]+nums[i+1:], path+[nums[i]])\n    res = []\n    dfs(res, nums, [])\n    return res",
        "detail": "algorithms.algorithms.backtrack.permute",
        "documentation": {}
    },
    {
        "label": "permute_unique",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.permute_unique",
        "description": "algorithms.algorithms.backtrack.permute_unique",
        "peekOfCode": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l)+1):\n                new_perms.append(l[:i]+[n]+l[i:])\n                if i < len(l) and l[i] == n:\n                    break  # handles duplication\n        perms = new_perms",
        "detail": "algorithms.algorithms.backtrack.permute_unique",
        "documentation": {}
    },
    {
        "label": "subsets",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.subsets",
        "description": "algorithms.algorithms.backtrack.subsets",
        "peekOfCode": "def subsets(nums):\n    \"\"\"\n    O(2**n)\n    \"\"\"\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.append(list(stack))\n        else:\n            # take nums[pos]\n            stack.append(nums[pos])",
        "detail": "algorithms.algorithms.backtrack.subsets",
        "documentation": {}
    },
    {
        "label": "backtrack",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.subsets",
        "description": "algorithms.algorithms.backtrack.subsets",
        "peekOfCode": "def backtrack(res, nums, cur, pos):\n    if pos >= len(nums):\n        res.append(cur)\n    else:\n        backtrack(res, nums, cur+[nums[pos]], pos+1)\n        backtrack(res, nums, cur, pos+1)\n\"\"\"\n# Iteratively\ndef subsets_v2(nums):\n    res = [[]]",
        "detail": "algorithms.algorithms.backtrack.subsets",
        "documentation": {}
    },
    {
        "label": "subsets_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.subsets",
        "description": "algorithms.algorithms.backtrack.subsets",
        "peekOfCode": "def subsets_v2(nums):\n    res = [[]]\n    for num in sorted(nums):\n        res += [item+[num] for item in res]\n    return res",
        "detail": "algorithms.algorithms.backtrack.subsets",
        "documentation": {}
    },
    {
        "label": "subsets_unique",
        "kind": 2,
        "importPath": "algorithms.algorithms.backtrack.subsets_unique",
        "description": "algorithms.algorithms.backtrack.subsets_unique",
        "peekOfCode": "def subsets_unique(nums):\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            # take\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos+1)\n            stack.pop()\n            # don't take",
        "detail": "algorithms.algorithms.backtrack.subsets_unique",
        "documentation": {}
    },
    {
        "label": "count_islands",
        "kind": 2,
        "importPath": "algorithms.algorithms.bfs.count_islands",
        "description": "algorithms.algorithms.bfs.count_islands",
        "peekOfCode": "def count_islands(grid):\n    row = len(grid)\n    col = len(grid[0])\n    num_islands = 0\n    visited = [[0] * col for i in range(row)]\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    queue = []\n    for i in range(row):\n        for j, num in enumerate(grid[i]):\n            if num == 1 and visited[i][j] != 1:",
        "detail": "algorithms.algorithms.bfs.count_islands",
        "documentation": {}
    },
    {
        "label": "maze_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.bfs.maze_search",
        "description": "algorithms.algorithms.bfs.maze_search",
        "peekOfCode": "def maze_search(maze):\n    BLOCKED, ALLOWED = 0, 1\n    UNVISITED, VISITED = 0, 1\n    initial_x, initial_y = 0, 0\n    if maze[initial_x][initial_y] == BLOCKED:\n        return -1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    height, width = len(maze), len(maze[0])\n    target_x, target_y = height - 1, width - 1\n    queue = deque([(initial_x, initial_y, 0)])",
        "detail": "algorithms.algorithms.bfs.maze_search",
        "documentation": {}
    },
    {
        "label": "shortest_distance",
        "kind": 2,
        "importPath": "algorithms.algorithms.bfs.shortest_distance_from_all_buildings",
        "description": "algorithms.algorithms.bfs.shortest_distance_from_all_buildings",
        "peekOfCode": "def shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n    matrix = [[[0,0] for i in range(len(grid[0]))] for j in range(len(grid))]\n    count = 0    # count how many building we have visited\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1",
        "detail": "algorithms.algorithms.bfs.shortest_distance_from_all_buildings",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.bfs.shortest_distance_from_all_buildings",
        "description": "algorithms.algorithms.bfs.shortest_distance_from_all_buildings",
        "peekOfCode": "def bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        i, j, step = q.pop(0)\n        for k, l in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n            # only the position be visited by count times will append to queue\n            if 0<=k<len(grid) and 0<=l<len(grid[0]) and \\\n                    matrix[k][l][1]==count and grid[k][l]==0:\n                matrix[k][l][0] += step+1\n                matrix[k][l][1] = count+1",
        "detail": "algorithms.algorithms.bfs.shortest_distance_from_all_buildings",
        "documentation": {}
    },
    {
        "label": "ladder_length",
        "kind": 2,
        "importPath": "algorithms.algorithms.bfs.word_ladder",
        "description": "algorithms.algorithms.bfs.word_ladder",
        "peekOfCode": "def ladder_length(begin_word, end_word, word_list):\n    \"\"\"\n    Bidirectional BFS!!!\n    :type begin_word: str\n    :type end_word: str\n    :type word_list: Set[str]\n    :rtype: int\n    \"\"\"\n    if len(begin_word) != len(end_word):\n        return -1   # not possible",
        "detail": "algorithms.algorithms.bfs.word_ladder",
        "documentation": {}
    },
    {
        "label": "word_range",
        "kind": 2,
        "importPath": "algorithms.algorithms.bfs.word_ladder",
        "description": "algorithms.algorithms.bfs.word_ladder",
        "peekOfCode": "def word_range(word):\n    for ind in range(len(word)):\n        temp = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z') + 1)]:\n            if c != temp:\n                yield word[:ind] + c + word[ind + 1:]",
        "detail": "algorithms.algorithms.bfs.word_ladder",
        "documentation": {}
    },
    {
        "label": "begin_word",
        "kind": 5,
        "importPath": "algorithms.algorithms.bfs.word_ladder",
        "description": "algorithms.algorithms.bfs.word_ladder",
        "peekOfCode": "begin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\n\"\"\"",
        "detail": "algorithms.algorithms.bfs.word_ladder",
        "documentation": {}
    },
    {
        "label": "end_word",
        "kind": 5,
        "importPath": "algorithms.algorithms.bfs.word_ladder",
        "description": "algorithms.algorithms.bfs.word_ladder",
        "peekOfCode": "end_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\n\"\"\"\ndef ladder_length(begin_word, end_word, word_list):",
        "detail": "algorithms.algorithms.bfs.word_ladder",
        "documentation": {}
    },
    {
        "label": "word_list",
        "kind": 5,
        "importPath": "algorithms.algorithms.bfs.word_ladder",
        "description": "algorithms.algorithms.bfs.word_ladder",
        "peekOfCode": "word_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\n\"\"\"\ndef ladder_length(begin_word, end_word, word_list):\n    \"\"\"",
        "detail": "algorithms.algorithms.bfs.word_ladder",
        "documentation": {}
    },
    {
        "label": "add_bitwise_operator",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.add_bitwise_operator",
        "description": "algorithms.algorithms.bit.add_bitwise_operator",
        "peekOfCode": "def add_bitwise_operator(x, y):\n    while y:\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x",
        "detail": "algorithms.algorithms.bit.add_bitwise_operator",
        "documentation": {}
    },
    {
        "label": "binary_gap",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.binary_gap",
        "description": "algorithms.algorithms.bit.binary_gap",
        "peekOfCode": "def binary_gap(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        if N & 1:\n            if last is not None:\n                ans = max(ans, index - last)\n            last = index\n        index = index + 1",
        "detail": "algorithms.algorithms.bit.binary_gap",
        "documentation": {}
    },
    {
        "label": "binary_gap_improved",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.binary_gap",
        "description": "algorithms.algorithms.bit.binary_gap",
        "peekOfCode": "def binary_gap_improved(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        tes = N & 1\n        if tes:\n            if last is not None:\n                ans = max(ans, index - last + 1)\n            else:",
        "detail": "algorithms.algorithms.bit.binary_gap",
        "documentation": {}
    },
    {
        "label": "get_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bit_operation",
        "description": "algorithms.algorithms.bit.bit_operation",
        "peekOfCode": "def get_bit(num, i):\n    return (num & (1 << i)) != 0\n\"\"\"\nThis function shifts 1 over by i bits, creating a value being like 0001000. By\nperforming an OR with num, only value at bit i will change.\n\"\"\"\ndef set_bit(num, i):\n    return num | (1 << i)\n\"\"\"\nThis method operates in almost the reverse of set_bit",
        "detail": "algorithms.algorithms.bit.bit_operation",
        "documentation": {}
    },
    {
        "label": "set_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bit_operation",
        "description": "algorithms.algorithms.bit.bit_operation",
        "peekOfCode": "def set_bit(num, i):\n    return num | (1 << i)\n\"\"\"\nThis method operates in almost the reverse of set_bit\n\"\"\"\ndef clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask\n\"\"\"\nTo set the ith bit to value, we first clear the bit at position i by using a",
        "detail": "algorithms.algorithms.bit.bit_operation",
        "documentation": {}
    },
    {
        "label": "clear_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bit_operation",
        "description": "algorithms.algorithms.bit.bit_operation",
        "peekOfCode": "def clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask\n\"\"\"\nTo set the ith bit to value, we first clear the bit at position i by using a\nmask. Then, we shift the intended value. Finally we OR these two numbers\n\"\"\"\ndef update_bit(num, i, bit):\n    mask = ~(1 << i)\n    return (num & mask) | (bit << i)",
        "detail": "algorithms.algorithms.bit.bit_operation",
        "documentation": {}
    },
    {
        "label": "update_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bit_operation",
        "description": "algorithms.algorithms.bit.bit_operation",
        "peekOfCode": "def update_bit(num, i, bit):\n    mask = ~(1 << i)\n    return (num & mask) | (bit << i)",
        "detail": "algorithms.algorithms.bit.bit_operation",
        "documentation": {}
    },
    {
        "label": "int_to_bytes_big_endian",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bytes_int_conversion",
        "description": "algorithms.algorithms.bit.bytes_int_conversion",
        "peekOfCode": "def int_to_bytes_big_endian(num):\n    bytestr = deque()\n    while num > 0:\n        # list.insert(0, ...) is inefficient\n        bytestr.appendleft(num & 0xff)\n        num >>= 8\n    return bytes(bytestr)\ndef int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:",
        "detail": "algorithms.algorithms.bit.bytes_int_conversion",
        "documentation": {}
    },
    {
        "label": "int_to_bytes_little_endian",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bytes_int_conversion",
        "description": "algorithms.algorithms.bit.bytes_int_conversion",
        "peekOfCode": "def int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:\n        bytestr.append(num & 0xff)\n        num >>= 8\n    return bytes(bytestr)\ndef bytes_big_endian_to_int(bytestr):\n    num = 0\n    for b in bytestr:\n        num <<= 8",
        "detail": "algorithms.algorithms.bit.bytes_int_conversion",
        "documentation": {}
    },
    {
        "label": "bytes_big_endian_to_int",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bytes_int_conversion",
        "description": "algorithms.algorithms.bit.bytes_int_conversion",
        "peekOfCode": "def bytes_big_endian_to_int(bytestr):\n    num = 0\n    for b in bytestr:\n        num <<= 8\n        num += b\n    return num\ndef bytes_little_endian_to_int(bytestr):\n    num = 0\n    e = 0\n    for b in bytestr:",
        "detail": "algorithms.algorithms.bit.bytes_int_conversion",
        "documentation": {}
    },
    {
        "label": "bytes_little_endian_to_int",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.bytes_int_conversion",
        "description": "algorithms.algorithms.bit.bytes_int_conversion",
        "peekOfCode": "def bytes_little_endian_to_int(bytestr):\n    num = 0\n    e = 0\n    for b in bytestr:\n        num += b << e\n        e += 8\n    return num",
        "detail": "algorithms.algorithms.bit.bytes_int_conversion",
        "documentation": {}
    },
    {
        "label": "count_flips_to_convert",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.count_flips_to_convert",
        "description": "algorithms.algorithms.bit.count_flips_to_convert",
        "peekOfCode": "def count_flips_to_convert(a, b):\n    diff = a ^ b\n    # count number of ones in diff\n    count = 0\n    while diff:\n        diff &= (diff - 1)\n        count += 1\n    return count",
        "detail": "algorithms.algorithms.bit.count_flips_to_convert",
        "documentation": {}
    },
    {
        "label": "count_ones_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.count_ones",
        "description": "algorithms.algorithms.bit.count_ones",
        "peekOfCode": "def count_ones_recur(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Recursive Approach)\"\"\"\n    if not n:\n        return 0\n    return 1 + count_ones_recur(n & (n-1))\ndef count_ones_iter(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Iterative Approach)\"\"\"\n    count = 0\n    while n:\n        n &= (n-1)",
        "detail": "algorithms.algorithms.bit.count_ones",
        "documentation": {}
    },
    {
        "label": "count_ones_iter",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.count_ones",
        "description": "algorithms.algorithms.bit.count_ones",
        "peekOfCode": "def count_ones_iter(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Iterative Approach)\"\"\"\n    count = 0\n    while n:\n        n &= (n-1)\n        count += 1\n    return count",
        "detail": "algorithms.algorithms.bit.count_ones",
        "documentation": {}
    },
    {
        "label": "find_difference",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.find_difference",
        "description": "algorithms.algorithms.bit.find_difference",
        "peekOfCode": "def find_difference(s, t):\n    ret = 0\n    for ch in s + t:\n        # ord(ch) return an integer representing the Unicode code point of that character\n        ret = ret ^ ord(ch)\n    # chr(i) Return the string representing a character whose Unicode code point is the integer i\n    return chr(ret)",
        "detail": "algorithms.algorithms.bit.find_difference",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "algorithms.algorithms.bit.find_difference",
        "description": "algorithms.algorithms.bit.find_difference",
        "peekOfCode": "s = \"abcd\"\nt = \"abecd\"\nOutput: 'e'\nExplanation:\n'e' is the letter that was added.\n\"\"\"\n\"\"\"\nWe use the characteristic equation of XOR.\nA xor B xor C = A xor C xor B\nIf A == C, then A xor C = 0",
        "detail": "algorithms.algorithms.bit.find_difference",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "algorithms.algorithms.bit.find_difference",
        "description": "algorithms.algorithms.bit.find_difference",
        "peekOfCode": "t = \"abecd\"\nOutput: 'e'\nExplanation:\n'e' is the letter that was added.\n\"\"\"\n\"\"\"\nWe use the characteristic equation of XOR.\nA xor B xor C = A xor C xor B\nIf A == C, then A xor C = 0\nand then, B xor 0 =  B",
        "detail": "algorithms.algorithms.bit.find_difference",
        "documentation": {}
    },
    {
        "label": "find_missing_number",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.find_missing_number",
        "description": "algorithms.algorithms.bit.find_missing_number",
        "peekOfCode": "def find_missing_number(nums):\n    missing = 0\n    for i, num in enumerate(nums):\n        missing ^= num\n        missing ^= i + 1\n    return missing\ndef find_missing_number2(nums):\n    num_sum = sum(nums)\n    n = len(nums)\n    total_sum = n*(n+1) // 2",
        "detail": "algorithms.algorithms.bit.find_missing_number",
        "documentation": {}
    },
    {
        "label": "find_missing_number2",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.find_missing_number",
        "description": "algorithms.algorithms.bit.find_missing_number",
        "peekOfCode": "def find_missing_number2(nums):\n    num_sum = sum(nums)\n    n = len(nums)\n    total_sum = n*(n+1) // 2\n    missing = total_sum - num_sum\n    return missing",
        "detail": "algorithms.algorithms.bit.find_missing_number",
        "documentation": {}
    },
    {
        "label": "flip_bit_longest_seq",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.flip_bit_longest_sequence",
        "description": "algorithms.algorithms.bit.flip_bit_longest_sequence",
        "peekOfCode": "def flip_bit_longest_seq(num):\n    curr_len = 0\n    prev_len = 0\n    max_len = 0\n    while num:\n        if num & 1 == 1:  # last digit is 1\n            curr_len += 1\n        elif num & 1 == 0:  # last digit is 0\n            if num & 2 == 0:  # second last digit is 0\n                prev_len = 0",
        "detail": "algorithms.algorithms.bit.flip_bit_longest_sequence",
        "documentation": {}
    },
    {
        "label": "has_alternative_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.has_alternative_bit",
        "description": "algorithms.algorithms.bit.has_alternative_bit",
        "peekOfCode": "def has_alternative_bit(n):\n    first_bit = 0\n    second_bit = 0\n    while n:\n        first_bit = n & 1\n        if n >> 1:\n            second_bit = (n >> 1) & 1\n            if not first_bit ^ second_bit:\n                return False\n        else:",
        "detail": "algorithms.algorithms.bit.has_alternative_bit",
        "documentation": {}
    },
    {
        "label": "has_alternative_bit_fast",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.has_alternative_bit",
        "description": "algorithms.algorithms.bit.has_alternative_bit",
        "peekOfCode": "def has_alternative_bit_fast(n):\n    mask1 = int('aaaaaaaa', 16)  # for bits ending with zero (...1010)\n    mask2 = int('55555555', 16)  # for bits ending with one  (...0101)\n    return mask1 == (n + (n ^ mask1)) or mask2 == (n + (n ^ mask2))",
        "detail": "algorithms.algorithms.bit.has_alternative_bit",
        "documentation": {}
    },
    {
        "label": "insert_one_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.insert_bit",
        "description": "algorithms.algorithms.bit.insert_bit",
        "peekOfCode": "def insert_one_bit(num, bit, i):\n    # Create mask\n    mask = num >> i\n    mask = (mask << 1) | bit\n    mask = mask << i\n    # Keep the bit from 0 position to i position\n    right = ((1 << i) - 1) & num\n    return right | mask\ndef insert_mult_bits(num, bits, len, i):\n    mask = num >> i",
        "detail": "algorithms.algorithms.bit.insert_bit",
        "documentation": {}
    },
    {
        "label": "insert_mult_bits",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.insert_bit",
        "description": "algorithms.algorithms.bit.insert_bit",
        "peekOfCode": "def insert_mult_bits(num, bits, len, i):\n    mask = num >> i\n    mask = (mask << len) | bits\n    mask = mask << i\n    right = ((1 << i) - 1) & num\n    return right | mask",
        "detail": "algorithms.algorithms.bit.insert_bit",
        "documentation": {}
    },
    {
        "label": "is_power_of_two",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.power_of_two",
        "description": "algorithms.algorithms.bit.power_of_two",
        "peekOfCode": "def is_power_of_two(n):\n    \"\"\"\n    :type n: int\n    :rtype: bool\n    \"\"\"\n    return n > 0 and not n & (n-1)",
        "detail": "algorithms.algorithms.bit.power_of_two",
        "documentation": {}
    },
    {
        "label": "remove_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.remove_bit",
        "description": "algorithms.algorithms.bit.remove_bit",
        "peekOfCode": "def remove_bit(num, i):\n    mask = num >> (i + 1)\n    mask = mask << i\n    right = ((1 << i) - 1) & num\n    return mask | right",
        "detail": "algorithms.algorithms.bit.remove_bit",
        "documentation": {}
    },
    {
        "label": "reverse_bits",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.reverse_bits",
        "description": "algorithms.algorithms.bit.reverse_bits",
        "peekOfCode": "def reverse_bits(n):\n    m = 0\n    i = 0\n    while i < 32:\n        m = (m << 1) + (n & 1)\n        n >>= 1\n        i += 1\n    return m",
        "detail": "algorithms.algorithms.bit.reverse_bits",
        "documentation": {}
    },
    {
        "label": "single_number",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.single_number",
        "description": "algorithms.algorithms.bit.single_number",
        "peekOfCode": "def single_number(nums):\n    \"\"\"\n    Returns single number, if found.\n    Else if all numbers appear twice, returns 0.\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    i = 0\n    for num in nums:\n        i ^= num",
        "detail": "algorithms.algorithms.bit.single_number",
        "documentation": {}
    },
    {
        "label": "single_number2",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.single_number2",
        "description": "algorithms.algorithms.bit.single_number2",
        "peekOfCode": "def single_number2(nums):\n    ones, twos = 0, 0\n    for i in range(len(nums)):\n        ones = (ones ^ nums[i]) & ~twos\n        twos = (twos ^ nums[i]) & ~ones\n    return ones",
        "detail": "algorithms.algorithms.bit.single_number2",
        "documentation": {}
    },
    {
        "label": "single_number3",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.single_number3",
        "description": "algorithms.algorithms.bit.single_number3",
        "peekOfCode": "def single_number3(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # isolate a^b from pairs using XOR\n    ab = 0\n    for n in nums:\n        ab ^= n\n    # isolate right most bit from a^b",
        "detail": "algorithms.algorithms.bit.single_number3",
        "documentation": {}
    },
    {
        "label": "subsets",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.subsets",
        "description": "algorithms.algorithms.bit.subsets",
        "peekOfCode": "def subsets(nums):\n    \"\"\"\n    :param nums: List[int]\n    :return: Set[tuple]\n    \"\"\"\n    n = len(nums)\n    total = 1 << n\n    res = set()\n    for i in range(total):\n        subset = tuple(num for j, num in enumerate(nums) if i & 1 << j)",
        "detail": "algorithms.algorithms.bit.subsets",
        "documentation": {}
    },
    {
        "label": "total",
        "kind": 5,
        "importPath": "algorithms.algorithms.bit.subsets",
        "description": "algorithms.algorithms.bit.subsets",
        "peekOfCode": "total = 2*2*2 = 2^3 = {{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}}\nLets assign bits to each outcome  ->\nFirst bit to 1 , Second bit to 2 and third bit to 3\nTake = 1\nDont take = 0\n0) 0 0 0  -> Dont take 3 , Dont take 2 , Dont take 1 = { }\n1) 0 0 1  -> Dont take 3 , Dont take 2 ,   take 1    = { 1 }\n2) 0 1 0  -> Dont take 3 ,    take 2   , Dont take 1 = { 2 }\n3) 0 1 1  -> Dont take 3 ,    take 2   ,   take 1    = { 1 , 2 }\n4) 1 0 0  ->    take 3   , Dont take 2 , Dont take 1 = { 3 }",
        "detail": "algorithms.algorithms.bit.subsets",
        "documentation": {}
    },
    {
        "label": "Take",
        "kind": 5,
        "importPath": "algorithms.algorithms.bit.subsets",
        "description": "algorithms.algorithms.bit.subsets",
        "peekOfCode": "Take = 1\nDont take = 0\n0) 0 0 0  -> Dont take 3 , Dont take 2 , Dont take 1 = { }\n1) 0 0 1  -> Dont take 3 , Dont take 2 ,   take 1    = { 1 }\n2) 0 1 0  -> Dont take 3 ,    take 2   , Dont take 1 = { 2 }\n3) 0 1 1  -> Dont take 3 ,    take 2   ,   take 1    = { 1 , 2 }\n4) 1 0 0  ->    take 3   , Dont take 2 , Dont take 1 = { 3 }\n5) 1 0 1  ->    take 3   , Dont take 2 ,   take 1    = { 1 , 3 }\n6) 1 1 0  ->    take 3   ,    take 2   , Dont take 1 = { 2 , 3 }\n7) 1 1 1  ->    take 3   ,    take 2   ,   take 1    = { 1 , 2 , 3 }",
        "detail": "algorithms.algorithms.bit.subsets",
        "documentation": {}
    },
    {
        "label": "swap_pair",
        "kind": 2,
        "importPath": "algorithms.algorithms.bit.swap_pair",
        "description": "algorithms.algorithms.bit.swap_pair",
        "peekOfCode": "def swap_pair(num):\n    # odd bit arithmetic right shift 1 bit\n    odd = (num & int('AAAAAAAA', 16)) >> 1\n    # even bit left shift 1 bit\n    even = (num & int('55555555', 16)) << 1\n    return odd | even",
        "detail": "algorithms.algorithms.bit.swap_pair",
        "documentation": {}
    },
    {
        "label": "binary",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "def binary(x,l=1):\n\tfmt = '{0:0%db}' % l\n\treturn fmt.format(x)\n# Calculates the unary number\ndef unary(x):\n\treturn (x-1)*'1'+'0'\ndef elias_generic(lencoding, x):\n\t\"\"\"\n\tThe compressed data is calculated in two parts. \n\tThe first part is the unary number of 1 + log2(x). ",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "unary",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "def unary(x):\n\treturn (x-1)*'1'+'0'\ndef elias_generic(lencoding, x):\n\t\"\"\"\n\tThe compressed data is calculated in two parts. \n\tThe first part is the unary number of 1 + log2(x). \n\tThe second part is the binary number of x - 2^(log2(x)).\n\tFor the final result we add these two parts.\n\t\"\"\"\n\tif x == 0: return '0'",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "elias_generic",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "def elias_generic(lencoding, x):\n\t\"\"\"\n\tThe compressed data is calculated in two parts. \n\tThe first part is the unary number of 1 + log2(x). \n\tThe second part is the binary number of x - 2^(log2(x)).\n\tFor the final result we add these two parts.\n\t\"\"\"\n\tif x == 0: return '0'\n\tfirst_part = 1 + int(log2(x))\n\ta = x - 2**(int(log2(x)))",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "elias_gamma",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "def elias_gamma(x):\n\t\"\"\"\n\tFor the first part we put the unary number of x.\n\t\"\"\"\n\treturn elias_generic(unary, x)\ndef elias_delta(x):\n\t\"\"\"\n\tFor the first part we put the elias_g of the number.\n\t\"\"\"\n\treturn elias_generic(elias_gamma,x)",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "elias_delta",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "def elias_delta(x):\n\t\"\"\"\n\tFor the first part we put the elias_g of the number.\n\t\"\"\"\n\treturn elias_generic(elias_gamma,x)",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "log2",
        "kind": 5,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "log2 = lambda x: log(x,2)\n# Calculates the binary number\ndef binary(x,l=1):\n\tfmt = '{0:0%db}' % l\n\treturn fmt.format(x)\n# Calculates the unary number\ndef unary(x):\n\treturn (x-1)*'1'+'0'\ndef elias_generic(lencoding, x):\n\t\"\"\"",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "\tfmt",
        "kind": 5,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "\tfmt = '{0:0%db}' % l\n\treturn fmt.format(x)\n# Calculates the unary number\ndef unary(x):\n\treturn (x-1)*'1'+'0'\ndef elias_generic(lencoding, x):\n\t\"\"\"\n\tThe compressed data is calculated in two parts. \n\tThe first part is the unary number of 1 + log2(x). \n\tThe second part is the binary number of x - 2^(log2(x)).",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "\tfirst_part",
        "kind": 5,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "\tfirst_part = 1 + int(log2(x))\n\ta = x - 2**(int(log2(x)))\n\tk = int(log2(x))\n\treturn lencoding(first_part) + binary(a,k)\ndef elias_gamma(x):\n\t\"\"\"\n\tFor the first part we put the unary number of x.\n\t\"\"\"\n\treturn elias_generic(unary, x)\ndef elias_delta(x):",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "\ta",
        "kind": 5,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "\ta = x - 2**(int(log2(x)))\n\tk = int(log2(x))\n\treturn lencoding(first_part) + binary(a,k)\ndef elias_gamma(x):\n\t\"\"\"\n\tFor the first part we put the unary number of x.\n\t\"\"\"\n\treturn elias_generic(unary, x)\ndef elias_delta(x):\n\t\"\"\"",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "\tk",
        "kind": 5,
        "importPath": "algorithms.algorithms.compression.elias",
        "description": "algorithms.algorithms.compression.elias",
        "peekOfCode": "\tk = int(log2(x))\n\treturn lencoding(first_part) + binary(a,k)\ndef elias_gamma(x):\n\t\"\"\"\n\tFor the first part we put the unary number of x.\n\t\"\"\"\n\treturn elias_generic(unary, x)\ndef elias_delta(x):\n\t\"\"\"\n\tFor the first part we put the elias_g of the number.",
        "detail": "algorithms.algorithms.compression.elias",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.compression.huffman_coding",
        "description": "algorithms.algorithms.compression.huffman_coding",
        "peekOfCode": "class Node:\n    def __init__(self, frequency=0, sign=None, left=None, right=None):\n        self.frequency = frequency\n        self.sign = sign\n        self.left = left\n        self.right = right\n    def __lt__(self, other):\n        return self.frequency < other.frequency\n    def __gt__(self, other):\n        return self.frequency > other.frequency",
        "detail": "algorithms.algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "HuffmanReader",
        "kind": 6,
        "importPath": "algorithms.algorithms.compression.huffman_coding",
        "description": "algorithms.algorithms.compression.huffman_coding",
        "peekOfCode": "class HuffmanReader:\n    def __init__(self, file):\n        self.file = file\n        self.buffer = []\n        self.is_last_byte = False\n    def get_number_of_additional_bits_in_the_last_byte(self) -> int:\n        bin_num = self.get_bit() + self.get_bit() + self.get_bit()\n        return int(bin_num, 2)\n    def load_tree(self) -> Node:\n        \"\"\"",
        "detail": "algorithms.algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "HuffmanWriter",
        "kind": 6,
        "importPath": "algorithms.algorithms.compression.huffman_coding",
        "description": "algorithms.algorithms.compression.huffman_coding",
        "peekOfCode": "class HuffmanWriter:\n    def __init__(self, file):\n        self.file = file\n        self.buffer = \"\"\n        self.saved_bits = 0\n    def write_char(self, char):\n        self.write_int(ord(char))\n    def write_int(self, num):\n        bin_int = \"{0:08b}\".format(num)\n        self.write_bits(bin_int)",
        "detail": "algorithms.algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "TreeFinder",
        "kind": 6,
        "importPath": "algorithms.algorithms.compression.huffman_coding",
        "description": "algorithms.algorithms.compression.huffman_coding",
        "peekOfCode": "class TreeFinder:\n    \"\"\"\n    Class to help find signs in tree\n    \"\"\"\n    def __init__(self, tree):\n        self.root = tree\n        self.current_node = tree\n        self.found = None\n    def find(self, bit):\n        \"\"\"",
        "detail": "algorithms.algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "HuffmanCoding",
        "kind": 6,
        "importPath": "algorithms.algorithms.compression.huffman_coding",
        "description": "algorithms.algorithms.compression.huffman_coding",
        "peekOfCode": "class HuffmanCoding:\n    def __init__(self):\n        pass\n    @staticmethod\n    def decode_file(file_in_name, file_out_name):\n        with open(file_in_name, \"rb\") as file_in, open(file_out_name, \"wb\") as file_out:\n            reader = HuffmanReader(file_in)\n            additional_bits = reader.get_number_of_additional_bits_in_the_last_byte()\n            tree = reader.load_tree()\n            HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits)",
        "detail": "algorithms.algorithms.compression.huffman_coding",
        "documentation": {}
    },
    {
        "label": "encode_rle",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.rle_compression",
        "description": "algorithms.algorithms.compression.rle_compression",
        "peekOfCode": "def encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not input: return ''\n    encoded_str = ''\n    prev_ch = ''",
        "detail": "algorithms.algorithms.compression.rle_compression",
        "documentation": {}
    },
    {
        "label": "decode_rle",
        "kind": 2,
        "importPath": "algorithms.algorithms.compression.rle_compression",
        "description": "algorithms.algorithms.compression.rle_compression",
        "peekOfCode": "def decode_rle(input):\n    \"\"\"\n    Gets a stream of data and decompresses it\n    under a Run-Length Decoding.\n    :param input: The data to be decoded.\n    :return: The decoded string.\n    \"\"\"\n    decode_str = ''\n    count = ''\n    for ch in input:",
        "detail": "algorithms.algorithms.compression.rle_compression",
        "documentation": {}
    },
    {
        "label": "get_factors",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.all_factors",
        "description": "algorithms.algorithms.dfs.all_factors",
        "peekOfCode": "def get_factors(n):\n    \"\"\"[summary]\n    Arguments:\n        n {[int]} -- [to analysed number]\n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function",
        "detail": "algorithms.algorithms.dfs.all_factors",
        "documentation": {}
    },
    {
        "label": "get_factors_iterative1",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.all_factors",
        "description": "algorithms.algorithms.dfs.all_factors",
        "peekOfCode": "def get_factors_iterative1(n):\n    \"\"\"[summary]\n    Computes all factors of n.\n    Translated the function get_factors(...) in\n    a call-stack modell.\n    Arguments:\n        n {[int]} -- [to analysed number]\n    Returns:\n        [list of lists] -- [all factors]\n    \"\"\"",
        "detail": "algorithms.algorithms.dfs.all_factors",
        "documentation": {}
    },
    {
        "label": "get_factors_iterative2",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.all_factors",
        "description": "algorithms.algorithms.dfs.all_factors",
        "peekOfCode": "def get_factors_iterative2(n):\n    \"\"\"[summary]\n    analog as above\n    Arguments:\n        n {[int]} -- [description]\n    Returns:\n        [list of lists] -- [all factors of n]\n    \"\"\"\n    ans, stack, x = [], [], 2\n    while True:",
        "detail": "algorithms.algorithms.dfs.all_factors",
        "documentation": {}
    },
    {
        "label": "8",
        "kind": 5,
        "importPath": "algorithms.algorithms.dfs.all_factors",
        "description": "algorithms.algorithms.dfs.all_factors",
        "peekOfCode": "8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\nExamples:\ninput: 1\noutput:\n[]",
        "detail": "algorithms.algorithms.dfs.all_factors",
        "documentation": {}
    },
    {
        "label": "8",
        "kind": 5,
        "importPath": "algorithms.algorithms.dfs.all_factors",
        "description": "algorithms.algorithms.dfs.all_factors",
        "peekOfCode": "8 = 2 x 2 x 2;\n  = 2 x 4.\nExamples:\ninput: 1\noutput:\n[]\ninput: 37\noutput:\n[]\ninput: 32",
        "detail": "algorithms.algorithms.dfs.all_factors",
        "documentation": {}
    },
    {
        "label": "num_islands",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.count_islands",
        "description": "algorithms.algorithms.dfs.count_islands",
        "peekOfCode": "def num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j, col in enumerate(grid[i]):\n            if col == 1:\n                dfs(grid, i, j)\n                count += 1\n    return count\ndef dfs(grid, i, j):\n    if (i < 0 or i >= len(grid)) or (j < 0 or j >= len(grid[0])):",
        "detail": "algorithms.algorithms.dfs.count_islands",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.count_islands",
        "description": "algorithms.algorithms.dfs.count_islands",
        "peekOfCode": "def dfs(grid, i, j):\n    if (i < 0 or i >= len(grid)) or (j < 0 or j >= len(grid[0])):\n        return\n    if grid[i][j] != 1:\n        return\n    grid[i][j] = 0\n    dfs(grid, i+1, j)\n    dfs(grid, i-1, j)\n    dfs(grid, i, j+1)\n    dfs(grid, i, j-1)",
        "detail": "algorithms.algorithms.dfs.count_islands",
        "documentation": {}
    },
    {
        "label": "find_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.maze_search",
        "description": "algorithms.algorithms.dfs.maze_search",
        "peekOfCode": "def find_path(maze):\n    cnt = dfs(maze, 0, 0, 0, -1)\n    return cnt\ndef dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth",
        "detail": "algorithms.algorithms.dfs.maze_search",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.maze_search",
        "description": "algorithms.algorithms.dfs.maze_search",
        "peekOfCode": "def dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        else:\n            if cnt > depth:\n                cnt = depth",
        "detail": "algorithms.algorithms.dfs.maze_search",
        "documentation": {}
    },
    {
        "label": "pacific_atlantic",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.pacific_atlantic",
        "description": "algorithms.algorithms.dfs.pacific_atlantic",
        "peekOfCode": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not n: return []\n    m = len(matrix[0])\n    if not m: return []\n    res = []",
        "detail": "algorithms.algorithms.dfs.pacific_atlantic",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.pacific_atlantic",
        "description": "algorithms.algorithms.dfs.pacific_atlantic",
        "peekOfCode": "def dfs(grid, matrix, height, i, j):\n    if i < 0 or i >= len(matrix) or j < 0 or  j >= len(matrix[0]):\n        return\n    if grid[i][j] or matrix[i][j] < height:\n        return\n    grid[i][j] = True\n    dfs(grid, matrix, matrix[i][j], i-1, j)\n    dfs(grid, matrix, matrix[i][j], i+1, j)\n    dfs(grid, matrix, matrix[i][j], i, j-1)\n    dfs(grid, matrix, matrix[i][j], i, j+1)",
        "detail": "algorithms.algorithms.dfs.pacific_atlantic",
        "documentation": {}
    },
    {
        "label": "Sudoku",
        "kind": 6,
        "importPath": "algorithms.algorithms.dfs.sudoku_solver",
        "description": "algorithms.algorithms.dfs.sudoku_solver",
        "peekOfCode": "class Sudoku: \n    def __init__ (self, board, row, col):\n        self.board = board\n        self.row = row\n        self.col = col\n        self.val = self.possible_values()\n    def possible_values(self):\n        a = \"123456789\"\n        d, val = {}, {}\n        for i in range(self.row):",
        "detail": "algorithms.algorithms.dfs.sudoku_solver",
        "documentation": {}
    },
    {
        "label": "walls_and_gates",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.walls_and_gates",
        "description": "algorithms.algorithms.dfs.walls_and_gates",
        "peekOfCode": "def walls_and_gates(rooms):\n    for i in range(len(rooms)):\n        for j in range(len(rooms[0])):\n            if rooms[i][j] == 0:\n                dfs(rooms, i, j, 0)\ndef dfs(rooms, i, j, depth):\n    if (i < 0 or i >= len(rooms)) or (j < 0 or j >= len(rooms[0])):\n        return  # out of bounds\n    if rooms[i][j] < depth:\n        return  # crossed",
        "detail": "algorithms.algorithms.dfs.walls_and_gates",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.dfs.walls_and_gates",
        "description": "algorithms.algorithms.dfs.walls_and_gates",
        "peekOfCode": "def dfs(rooms, i, j, depth):\n    if (i < 0 or i >= len(rooms)) or (j < 0 or j >= len(rooms[0])):\n        return  # out of bounds\n    if rooms[i][j] < depth:\n        return  # crossed\n    rooms[i][j] = depth\n    dfs(rooms, i+1, j, depth+1)\n    dfs(rooms, i-1, j, depth+1)\n    dfs(rooms, i, j+1, depth+1)\n    dfs(rooms, i, j-1, depth+1)",
        "detail": "algorithms.algorithms.dfs.walls_and_gates",
        "documentation": {}
    },
    {
        "label": "get_histogram",
        "kind": 2,
        "importPath": "algorithms.algorithms.distribution.histogram",
        "description": "algorithms.algorithms.distribution.histogram",
        "peekOfCode": "def get_histogram(input_list: list) -> dict:\n    \"\"\"\n    Get histogram representation\n    :param input_list: list with different and unordered values\n    :return histogram: dict with histogram of input_list\n    \"\"\"\n    # Create dict to store histogram\n    histogram = {}\n    # For each list value, add one to the respective histogram dict position\n    for i in input_list:",
        "detail": "algorithms.algorithms.distribution.histogram",
        "documentation": {}
    },
    {
        "label": "max_profit_naive",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.buy_sell_stock",
        "description": "algorithms.algorithms.dp.buy_sell_stock",
        "peekOfCode": "def max_profit_naive(prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    max_so_far = 0\n    for i in range(0, len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            max_so_far = max(max_so_far, prices[j] - prices[i])\n    return max_so_far",
        "detail": "algorithms.algorithms.dp.buy_sell_stock",
        "documentation": {}
    },
    {
        "label": "max_profit_optimized",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.buy_sell_stock",
        "description": "algorithms.algorithms.dp.buy_sell_stock",
        "peekOfCode": "def max_profit_optimized(prices):\n    \"\"\"\n    input: [7, 1, 5, 3, 6, 4]\n    diff : [X, -6, 4, -2, 3, -2]\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    cur_max, max_so_far = 0, 0\n    for i in range(1, len(prices)):\n        cur_max = max(0, cur_max + prices[i] - prices[i-1])",
        "detail": "algorithms.algorithms.dp.buy_sell_stock",
        "documentation": {}
    },
    {
        "label": "climb_stairs",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.climbing_stairs",
        "description": "algorithms.algorithms.dp.climbing_stairs",
        "peekOfCode": "def climb_stairs(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    arr = [1, 1]\n    for _ in range(1, n):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]\n# the above function can be optimized as:",
        "detail": "algorithms.algorithms.dp.climbing_stairs",
        "documentation": {}
    },
    {
        "label": "climb_stairs_optimized",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.climbing_stairs",
        "description": "algorithms.algorithms.dp.climbing_stairs",
        "peekOfCode": "def climb_stairs_optimized(n):\n    a = b = 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
        "detail": "algorithms.algorithms.dp.climbing_stairs",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.coin_change",
        "description": "algorithms.algorithms.dp.coin_change",
        "peekOfCode": "def count(coins, n):\n    # initialize dp array and set base case as 1\n    dp = [1] + [0] * n\n    # fill dp in a bottom up manner\n    for coin in coins:\n        for i in range(coin, n+1):\n            dp[i] += dp[i-coin]\n    return dp[n]",
        "detail": "algorithms.algorithms.dp.coin_change",
        "documentation": {}
    },
    {
        "label": "coins",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.coin_change",
        "description": "algorithms.algorithms.dp.coin_change",
        "peekOfCode": "coins = {S1, S2, .. , Sm} valued coins, how many ways can we make the change? \nThe order of coins doesn't matter.\nFor example, for n = 4 and coins = [1, 2, 3], there are four solutions: \n[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]. \nSo output should be 4. \nFor n = 10 and coins = [2, 5, 3, 6], there are five solutions: \n[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5]. \nSo the output should be 5.\nTime complexity: O(n * m) where n is the value and m is the number of coins\nSpace complexity: O(n)",
        "detail": "algorithms.algorithms.dp.coin_change",
        "documentation": {}
    },
    {
        "label": "helper_topdown",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.combination_sum",
        "description": "algorithms.algorithms.dp.combination_sum",
        "peekOfCode": "def helper_topdown(nums, target):\n    global dp\n    if dp[target] != -1:\n        return dp[target]\n    res = 0\n    for i in range(0, len(nums)):\n        if target >= nums[i]:\n            res += helper_topdown(nums, target - nums[i])\n    dp[target] = res\n    return res",
        "detail": "algorithms.algorithms.dp.combination_sum",
        "documentation": {}
    },
    {
        "label": "combination_sum_topdown",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.combination_sum",
        "description": "algorithms.algorithms.dp.combination_sum",
        "peekOfCode": "def combination_sum_topdown(nums, target):\n    global dp\n    dp = [-1] * (target + 1)\n    dp[0] = 1\n    return helper_topdown(nums, target)\n# EDIT: The above solution is top-down. How about a bottom-up one?\ndef combination_sum_bottom_up(nums, target):\n    comb = [0] * (target + 1)\n    comb[0] = 1\n    for i in range(0, len(comb)):",
        "detail": "algorithms.algorithms.dp.combination_sum",
        "documentation": {}
    },
    {
        "label": "combination_sum_bottom_up",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.combination_sum",
        "description": "algorithms.algorithms.dp.combination_sum",
        "peekOfCode": "def combination_sum_bottom_up(nums, target):\n    comb = [0] * (target + 1)\n    comb[0] = 1\n    for i in range(0, len(comb)):\n        for j in range(len(nums)):\n            if i - nums[j] >= 0:\n                comb[i] += comb[i - nums[j]]\n    return comb[target]",
        "detail": "algorithms.algorithms.dp.combination_sum",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.combination_sum",
        "description": "algorithms.algorithms.dp.combination_sum",
        "peekOfCode": "nums = [1, 2, 3]\ntarget = 4\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)",
        "detail": "algorithms.algorithms.dp.combination_sum",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.combination_sum",
        "description": "algorithms.algorithms.dp.combination_sum",
        "peekOfCode": "target = 4\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.",
        "detail": "algorithms.algorithms.dp.combination_sum",
        "documentation": {}
    },
    {
        "label": "dp",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.combination_sum",
        "description": "algorithms.algorithms.dp.combination_sum",
        "peekOfCode": "dp = None\ndef helper_topdown(nums, target):\n    global dp\n    if dp[target] != -1:\n        return dp[target]\n    res = 0\n    for i in range(0, len(nums)):\n        if target >= nums[i]:\n            res += helper_topdown(nums, target - nums[i])\n    dp[target] = res",
        "detail": "algorithms.algorithms.dp.combination_sum",
        "documentation": {}
    },
    {
        "label": "edit_distance",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.edit_distance",
        "description": "algorithms.algorithms.dp.edit_distance",
        "peekOfCode": "def edit_distance(A, B):\n    # Time: O(m*n)\n    # Space: O(m*n)\n    m, n = len(A) + 1, len(B) + 1\n    edit = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(1, m):\n        edit[i][0] = i\n    for j in range(1, n):\n        edit[0][j] = j\n    for i in range(1, m):",
        "detail": "algorithms.algorithms.dp.edit_distance",
        "documentation": {}
    },
    {
        "label": "egg_drop",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.egg_drop",
        "description": "algorithms.algorithms.dp.egg_drop",
        "peekOfCode": "def egg_drop(n, k):\n    # A 2D table where entery eggFloor[i][j] will represent minimum\n    # number of trials needed for i eggs and j floors.\n    egg_floor = [[0 for x in range(k+1)] for x in range(n+1)]\n    # We need one trial for one floor and 0 trials for 0 floors\n    for i in range(1, n+1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n    # We always need j trials for one egg and j floors.\n    for j in range(1, k+1):",
        "detail": "algorithms.algorithms.dp.egg_drop",
        "documentation": {}
    },
    {
        "label": "INT_MAX",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.egg_drop",
        "description": "algorithms.algorithms.dp.egg_drop",
        "peekOfCode": "INT_MAX = 32767\ndef egg_drop(n, k):\n    # A 2D table where entery eggFloor[i][j] will represent minimum\n    # number of trials needed for i eggs and j floors.\n    egg_floor = [[0 for x in range(k+1)] for x in range(n+1)]\n    # We need one trial for one floor and 0 trials for 0 floors\n    for i in range(1, n+1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n    # We always need j trials for one egg and j floors.",
        "detail": "algorithms.algorithms.dp.egg_drop",
        "documentation": {}
    },
    {
        "label": "fib_recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.fib",
        "description": "algorithms.algorithms.dp.fib",
        "peekOfCode": "def fib_recursive(n):\n    \"\"\"[summary]\n    Computes the n-th fibonacci number recursive.\n    Problem: This implementation is very slow.\n    approximate O(2^n)\n    Arguments:\n        n {[int]} -- [description]\n    Returns:\n        [int] -- [description]\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.fib",
        "documentation": {}
    },
    {
        "label": "fib_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.fib",
        "description": "algorithms.algorithms.dp.fib",
        "peekOfCode": "def fib_list(n):\n    \"\"\"[summary]\n    This algorithm computes the n-th fibbonacci number\n    very quick. approximate O(n)\n    The algorithm use dynamic programming.\n    Arguments:\n        n {[int]} -- [description]\n    Returns:\n        [int] -- [description]\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.fib",
        "documentation": {}
    },
    {
        "label": "fib_iter",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.fib",
        "description": "algorithms.algorithms.dp.fib",
        "peekOfCode": "def fib_iter(n):\n    \"\"\"[summary]\n    Works iterative approximate O(n)\n    Arguments:\n        n {[int]} -- [description]\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    # precondition\n    assert n >= 0, 'n must be positive integer'",
        "detail": "algorithms.algorithms.dp.fib",
        "documentation": {}
    },
    {
        "label": "hosoya",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.hosoya_triangle",
        "description": "algorithms.algorithms.dp.hosoya_triangle",
        "peekOfCode": "def hosoya(n, m): \n    if ((n == 0 and m == 0) or (n == 1 and m == 0) or\n        (n == 1 and m == 1) or (n == 2 and m == 1)): \n        return 1\n    if n > m: \n        return hosoya(n - 1, m) + hosoya(n - 2, m) \n    elif m == n: \n        return hosoya(n - 1, m - 1) + hosoya(n - 2, m - 2) \n    else: \n        return 0",
        "detail": "algorithms.algorithms.dp.hosoya_triangle",
        "documentation": {}
    },
    {
        "label": "print_hosoya",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.hosoya_triangle",
        "description": "algorithms.algorithms.dp.hosoya_triangle",
        "peekOfCode": "def print_hosoya(n): \n    for i in range(n): \n        for j in range(i + 1): \n            print(hosoya(i, j) , end = \" \") \n        print (\"\\n\", end = \"\")\ndef hosoya_testing(n):\n    x = []\n    for i in range(n): \n        for j in range(i + 1): \n            x.append(hosoya(i, j))",
        "detail": "algorithms.algorithms.dp.hosoya_triangle",
        "documentation": {}
    },
    {
        "label": "hosoya_testing",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.hosoya_triangle",
        "description": "algorithms.algorithms.dp.hosoya_triangle",
        "peekOfCode": "def hosoya_testing(n):\n    x = []\n    for i in range(n): \n        for j in range(i + 1): \n            x.append(hosoya(i, j))\n    return x",
        "detail": "algorithms.algorithms.dp.hosoya_triangle",
        "documentation": {}
    },
    {
        "label": "house_robber",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.house_robber",
        "description": "algorithms.algorithms.dp.house_robber",
        "peekOfCode": "def house_robber(houses):\n    last, now = 0, 0\n    for house in houses:\n        last, now = now, max(last + house, now)\n    return now",
        "detail": "algorithms.algorithms.dp.house_robber",
        "documentation": {}
    },
    {
        "label": "int_divide",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.int_divide",
        "description": "algorithms.algorithms.dp.int_divide",
        "peekOfCode": "def int_divide(n):\n    arr = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    arr[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i < j:\n                arr[i][j] = arr[i][i]\n            elif i == j:\n                arr[i][j] = 1 + arr[i][j - 1]\n            else:",
        "detail": "algorithms.algorithms.dp.int_divide",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": "algorithms.algorithms.dp.job_scheduling",
        "description": "algorithms.algorithms.dp.job_scheduling",
        "peekOfCode": "class Job:\n    def __init__(self, start, finish, profit):\n        self.start  = start\n        self.finish = finish\n        self.profit  = profit\n# A Binary Search based function to find the latest job\n# (before current job) that doesn't conflict with current\n# job.  \"index\" is index of the current job.  This function\n# returns -1 if all jobs before index conflict with it.\n# The array jobs[] is sorted in increasing order of finish",
        "detail": "algorithms.algorithms.dp.job_scheduling",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.job_scheduling",
        "description": "algorithms.algorithms.dp.job_scheduling",
        "peekOfCode": "def binary_search(job, start_index):\n    # Initialize 'lo' and 'hi' for Binary Search\n    lo = 0\n    hi = start_index - 1\n    # Perform binary Search iteratively\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                lo = mid + 1",
        "detail": "algorithms.algorithms.dp.job_scheduling",
        "documentation": {}
    },
    {
        "label": "schedule",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.job_scheduling",
        "description": "algorithms.algorithms.dp.job_scheduling",
        "peekOfCode": "def schedule(job):\n    # Sort jobs according to finish time\n    job = sorted(job, key = lambda j: j.finish)\n    # Create an array to store solutions of subproblems.  table[i]\n    # stores the profit for jobs till arr[i] (including arr[i])\n    n = len(job) \n    table = [0 for _ in range(n)]\n    table[0] = job[0].profit\n    # Fill entries in table[] using recursive property\n    for i in range(1, n):",
        "detail": "algorithms.algorithms.dp.job_scheduling",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "algorithms.algorithms.dp.knapsack",
        "description": "algorithms.algorithms.dp.knapsack",
        "peekOfCode": "class Item:\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\ndef get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity+1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]",
        "detail": "algorithms.algorithms.dp.knapsack",
        "documentation": {}
    },
    {
        "label": "get_maximum_value",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.knapsack",
        "description": "algorithms.algorithms.dp.knapsack",
        "peekOfCode": "def get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity+1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]",
        "detail": "algorithms.algorithms.dp.knapsack",
        "documentation": {}
    },
    {
        "label": "capacity",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.knapsack",
        "description": "algorithms.algorithms.dp.knapsack",
        "peekOfCode": "capacity = 5, items(value, weight) = [(60, 5), (50, 3), (70, 4), (30, 2)]\nresult = 80 (items valued 50 and 30 can both be fit in the knapsack)\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity.\n\"\"\"\nclass Item:\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\ndef get_maximum_value(items, capacity):",
        "detail": "algorithms.algorithms.dp.knapsack",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.knapsack",
        "description": "algorithms.algorithms.dp.knapsack",
        "peekOfCode": "result = 80 (items valued 50 and 30 can both be fit in the knapsack)\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity.\n\"\"\"\nclass Item:\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\ndef get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)",
        "detail": "algorithms.algorithms.dp.knapsack",
        "documentation": {}
    },
    {
        "label": "find_k_factor",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.k_factor",
        "description": "algorithms.algorithms.dp.k_factor",
        "peekOfCode": "def find_k_factor(n,k):\n    dp=[[[0 for i in range(4)]for j in range((n-1)//3+2)]for k in range(n+1)]\n    if(3*k+1>n):\n        return 0\n    #base cases\n    dp[1][0][0]=1;\n    dp[1][0][1]=0;\n    dp[1][0][2]=0;\n    dp[1][0][3]=25;\n    for i in range(2,n+1):",
        "detail": "algorithms.algorithms.dp.k_factor",
        "documentation": {}
    },
    {
        "label": "longest_common_subsequence",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.longest_common_subsequence",
        "description": "algorithms.algorithms.dp.longest_common_subsequence",
        "peekOfCode": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    :param s1: string\n    :param s2: string\n    :return: int\n    \"\"\"\n    m = len(s1)\n    n = len(s2)\n    dp = [[0] * (n + 1) for i in range(m + 1)]\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.longest_common_subsequence",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.longest_increasing",
        "description": "algorithms.algorithms.dp.longest_increasing",
        "peekOfCode": "def longest_increasing_subsequence(sequence):\n    \"\"\"\n    Dynamic Programming Algorithm for\n    counting the length of longest increasing subsequence\n    type sequence: list[int]\n    rtype: int\n    \"\"\"\n    length = len(sequence)\n    counts = [1 for _ in range(length)]\n    for i in range(1, length):",
        "detail": "algorithms.algorithms.dp.longest_increasing",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence_optimized",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.longest_increasing",
        "description": "algorithms.algorithms.dp.longest_increasing",
        "peekOfCode": "def longest_increasing_subsequence_optimized(sequence):\n    \"\"\"\n    Optimized dynamic programming algorithm for\n    couting the length of the longest increasing subsequence\n    using segment tree data structure to achieve better complexity\n    if max element is larger than 10^5 then use \n    longest_increasing_subsequence_optimied2() instead\n    type sequence: list[int]\n    rtype: int\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.longest_increasing",
        "documentation": {}
    },
    {
        "label": "longest_increasing_subsequence_optimized2",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.longest_increasing",
        "description": "algorithms.algorithms.dp.longest_increasing",
        "peekOfCode": "def longest_increasing_subsequence_optimized2(sequence):\n    \"\"\"\n    Optimized dynamic programming algorithm for\n    counting the length of the longest increasing subsequence\n    using segment tree data structure to achieve better complexity\n    type sequence: list[int]\n    rtype: int\n    \"\"\"\n    n = len(sequence)\n    tree = [0] * (n<<2)",
        "detail": "algorithms.algorithms.dp.longest_increasing",
        "documentation": {}
    },
    {
        "label": "matrix_chain_order",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.matrix_chain_order",
        "description": "algorithms.algorithms.dp.matrix_chain_order",
        "peekOfCode": "def matrix_chain_order(array):\n    n=len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2,n):\n        for a in range(1,n-chain_length+1):\n            b = a+chain_length-1\n            matrix[a][b] = INF\n            for c in range(a, b):\n                cost = matrix[a][c] + matrix[c+1][b] + array[a-1]*array[c]*array[b]",
        "detail": "algorithms.algorithms.dp.matrix_chain_order",
        "documentation": {}
    },
    {
        "label": "print_optimal_solution",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.matrix_chain_order",
        "description": "algorithms.algorithms.dp.matrix_chain_order",
        "peekOfCode": "def print_optimal_solution(optimal_solution,i,j):\n    if i==j:\n        print(\"A\" + str(i),end = \" \")\n    else:\n        print(\"(\",end = \" \")\n        print_optimal_solution(optimal_solution,i,optimal_solution[i][j])\n        print_optimal_solution(optimal_solution,optimal_solution[i][j]+1,j)\n        print(\")\",end = \" \")\ndef main():\n    array=[30,35,15,5,10,20,25]",
        "detail": "algorithms.algorithms.dp.matrix_chain_order",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.matrix_chain_order",
        "description": "algorithms.algorithms.dp.matrix_chain_order",
        "peekOfCode": "def main():\n    array=[30,35,15,5,10,20,25]\n    n=len(array)\n    #Size of matrix created from above array will be\n    # 30*35 35*15 15*5 5*10 10*20 20*25\n    matrix , optimal_solution = matrix_chain_order(array)\n    print(\"No. of Operation required: \"+str((matrix[1][n-1])))\n    print_optimal_solution(optimal_solution,1,n-1)\nif __name__ == '__main__':\n    main()",
        "detail": "algorithms.algorithms.dp.matrix_chain_order",
        "documentation": {}
    },
    {
        "label": "INF",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.matrix_chain_order",
        "description": "algorithms.algorithms.dp.matrix_chain_order",
        "peekOfCode": "INF = float(\"inf\")\ndef matrix_chain_order(array):\n    n=len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2,n):\n        for a in range(1,n-chain_length+1):\n            b = a+chain_length-1\n            matrix[a][b] = INF\n            for c in range(a, b):",
        "detail": "algorithms.algorithms.dp.matrix_chain_order",
        "documentation": {}
    },
    {
        "label": "max_product",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.max_product_subarray",
        "description": "algorithms.algorithms.dp.max_product_subarray",
        "peekOfCode": "def max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    lmin = lmax = gmax = nums[0]\n    for i in range(len(nums)):\n        t1 = nums[i] * lmax\n        t2 = nums[i] * lmin\n        lmax = max(max(t1, t2), nums[i])",
        "detail": "algorithms.algorithms.dp.max_product_subarray",
        "documentation": {}
    },
    {
        "label": "subarray_with_max_product",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.max_product_subarray",
        "description": "algorithms.algorithms.dp.max_product_subarray",
        "peekOfCode": "def subarray_with_max_product(arr):\n    ''' arr is list of positive/negative numbers '''\n    l = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n    for i in range(l):\n        max_product_end *= arr[i]\n        if arr[i] > 0:",
        "detail": "algorithms.algorithms.dp.max_product_subarray",
        "documentation": {}
    },
    {
        "label": "max_subarray",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.max_subarray",
        "description": "algorithms.algorithms.dp.max_subarray",
        "peekOfCode": "def max_subarray(array):\n    max_so_far = max_now = array[0]\n    for i in range(1, len(array)):\n        max_now = max(array[i], max_now + array[i])\n        max_so_far = max(max_so_far, max_now)\n    return max_so_far\na = [1, 2, -3, 4, 5, -7, 23]\nprint(a)\nprint(max_subarray(a))",
        "detail": "algorithms.algorithms.dp.max_subarray",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.max_subarray",
        "description": "algorithms.algorithms.dp.max_subarray",
        "peekOfCode": "a = [1, 2, -3, 4, 5, -7, 23]\nprint(a)\nprint(max_subarray(a))",
        "detail": "algorithms.algorithms.dp.max_subarray",
        "documentation": {}
    },
    {
        "label": "min_cost",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.min_cost_path",
        "description": "algorithms.algorithms.dp.min_cost_path",
        "peekOfCode": "def min_cost(cost):\n    n = len(cost)\n    # dist[i] stores minimum cost from 0 --> i.\n    dist = [INF] * n\n    dist[0] = 0   # cost from 0 --> 0 is zero.\n    for i in range(n):\n        for j in range(i+1,n):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n    return dist[n-1]\nif __name__ == '__main__':",
        "detail": "algorithms.algorithms.dp.min_cost_path",
        "documentation": {}
    },
    {
        "label": "INF",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.min_cost_path",
        "description": "algorithms.algorithms.dp.min_cost_path",
        "peekOfCode": "INF = float(\"inf\")\ndef min_cost(cost):\n    n = len(cost)\n    # dist[i] stores minimum cost from 0 --> i.\n    dist = [INF] * n\n    dist[0] = 0   # cost from 0 --> 0 is zero.\n    for i in range(n):\n        for j in range(i+1,n):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n    return dist[n-1]",
        "detail": "algorithms.algorithms.dp.min_cost_path",
        "documentation": {}
    },
    {
        "label": "num_decodings",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.num_decodings",
        "description": "algorithms.algorithms.dp.num_decodings",
        "peekOfCode": "def num_decodings(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not s or s[0] == \"0\":\n        return 0\n    wo_last, wo_last_two = 1, 1\n    for i in range(1, len(s)):\n        x = wo_last if s[i] != \"0\" else 0",
        "detail": "algorithms.algorithms.dp.num_decodings",
        "documentation": {}
    },
    {
        "label": "num_decodings2",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.num_decodings",
        "description": "algorithms.algorithms.dp.num_decodings",
        "peekOfCode": "def num_decodings2(s):\n    if not s or s.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(s)):\n        if s[i] == '0':\n            if s[i-1] == '0' or s[i-1] > '2':\n                # only '10', '20' is valid\n                return 0\n            stack.append(stack[-2])",
        "detail": "algorithms.algorithms.dp.num_decodings",
        "documentation": {}
    },
    {
        "label": "planting_trees",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.planting_trees",
        "description": "algorithms.algorithms.dp.planting_trees",
        "peekOfCode": "def planting_trees(trees, L, W):\n    \"\"\"\n    Returns the minimum distance that trees have to be moved before they are all in a valid state.\n        Parameters:\n            tree (list<int>): A sorted list of integers with all trees' position along the road.\n            L (int): An integer with the length of the road.\n            W (int): An integer with the width of the road.\n        Returns:\n            A float number with the total distance trees have been moved.\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.planting_trees",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "algorithms.algorithms.dp.regex_matching",
        "description": "algorithms.algorithms.dp.regex_matching",
        "peekOfCode": "class Solution(object):\n    def is_match(self, s, p):\n        m, n = len(s) + 1, len(p) + 1\n        matches = [[False] * n  for _ in range(m)]\n        # Match empty string with empty pattern\n        matches[0][0] = True\n        # Match empty string with .*\n        for i, element in enumerate(p[1:], 2):\n            matches[0][i] = matches[0][i - 2] and element == '*'\n        for i, ss in enumerate(s, 1):",
        "detail": "algorithms.algorithms.dp.regex_matching",
        "documentation": {}
    },
    {
        "label": "TestSolution",
        "kind": 6,
        "importPath": "algorithms.algorithms.dp.regex_matching",
        "description": "algorithms.algorithms.dp.regex_matching",
        "peekOfCode": "class TestSolution(unittest.TestCase):\n    def test_none_0(self):\n        s = \"\"\n        p = \"\"\n        self.assertTrue(Solution().is_match(s, p))\n    def test_none_1(self):\n        s = \"\"\n        p = \"a\"\n        self.assertFalse(Solution().is_match(s, p))\n    def test_no_symbol_equal(self):",
        "detail": "algorithms.algorithms.dp.regex_matching",
        "documentation": {}
    },
    {
        "label": "cut_rod",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.rod_cut",
        "description": "algorithms.algorithms.dp.rod_cut",
        "peekOfCode": "def cut_rod(price):\n    n = len(price)\n    val = [0]*(n+1)\n    # Build the table val[] in bottom up manner and return\n    # the last entry from the table\n    for i in range(1, n+1):\n        max_val = INT_MIN\n        for j in range(i):\n             max_val = max(max_val, price[j] + val[i-j-1])\n        val[i] = max_val",
        "detail": "algorithms.algorithms.dp.rod_cut",
        "documentation": {}
    },
    {
        "label": "INT_MIN",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.rod_cut",
        "description": "algorithms.algorithms.dp.rod_cut",
        "peekOfCode": "INT_MIN = -32767\n# Returns the best obtainable price for a rod of length n and\n# price[] as prices of different pieces\ndef cut_rod(price):\n    n = len(price)\n    val = [0]*(n+1)\n    # Build the table val[] in bottom up manner and return\n    # the last entry from the table\n    for i in range(1, n+1):\n        max_val = INT_MIN",
        "detail": "algorithms.algorithms.dp.rod_cut",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.rod_cut",
        "description": "algorithms.algorithms.dp.rod_cut",
        "peekOfCode": "arr = [1, 5, 8, 9, 10, 17, 17, 20]\nprint(\"Maximum Obtainable Value is \" + str(cut_rod(arr)))\n# This code is contributed by Bhavya Jain",
        "detail": "algorithms.algorithms.dp.rod_cut",
        "documentation": {}
    },
    {
        "label": "word_break",
        "kind": 2,
        "importPath": "algorithms.algorithms.dp.word_break",
        "description": "algorithms.algorithms.dp.word_break",
        "peekOfCode": "def word_break(s, word_dict):\n    \"\"\"\n    :type s: str\n    :type word_dict: Set[str]\n    :rtype: bool\n    \"\"\"\n    dp = [False] * (len(s)+1)\n    dp[0] = True\n    for i in range(1, len(s)+1):\n        for j in range(0, i):",
        "detail": "algorithms.algorithms.dp.word_break",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.word_break",
        "description": "algorithms.algorithms.dp.word_break",
        "peekOfCode": "s = \"leetcode\",\ndict = [\"leet\", \"code\"].\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\"\"\"\n\"\"\"\ns = abc word_dict = [\"a\",\"bc\"]\nTrue False False False\n\"\"\"\n# TC: O(N^2)  SC: O(N)\ndef word_break(s, word_dict):",
        "detail": "algorithms.algorithms.dp.word_break",
        "documentation": {}
    },
    {
        "label": "dict",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.word_break",
        "description": "algorithms.algorithms.dp.word_break",
        "peekOfCode": "dict = [\"leet\", \"code\"].\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\"\"\"\n\"\"\"\ns = abc word_dict = [\"a\",\"bc\"]\nTrue False False False\n\"\"\"\n# TC: O(N^2)  SC: O(N)\ndef word_break(s, word_dict):\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.word_break",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "algorithms.algorithms.dp.word_break",
        "description": "algorithms.algorithms.dp.word_break",
        "peekOfCode": "s = abc word_dict = [\"a\",\"bc\"]\nTrue False False False\n\"\"\"\n# TC: O(N^2)  SC: O(N)\ndef word_break(s, word_dict):\n    \"\"\"\n    :type s: str\n    :type word_dict: Set[str]\n    :rtype: bool\n    \"\"\"",
        "detail": "algorithms.algorithms.dp.word_break",
        "documentation": {}
    },
    {
        "label": "all_pairs_shortest_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.all_pairs_shortest_path",
        "description": "algorithms.algorithms.graph.all_pairs_shortest_path",
        "peekOfCode": "def all_pairs_shortest_path(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    for k in range(len(new_array)):\n        for i in range(len(new_array)):\n            for j in range(len(new_array)):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]           \n    return new_array",
        "detail": "algorithms.algorithms.graph.all_pairs_shortest_path",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.all_pairs_shortest_path",
        "description": "algorithms.algorithms.graph.all_pairs_shortest_path",
        "peekOfCode": "a = [[0, 0.1, 0.101, 0.142, 0.277], [0.465, 0, 0.191, 0.192, 0.587], [0.245, 0.554, 0, 0.333, 0.931], [1.032, 0.668, 0.656, 0, 0.151], [0.867, 0.119, 0.352, 0.398, 0]]\nresult \n[[0, 0.1, 0.101, 0.142, 0.277], [0.436, 0, 0.191, 0.192, 0.34299999999999997], [0.245, 0.345, 0, 0.333, 0.484], [0.706, 0.27, 0.46099999999999997, 0, 0.151], [0.5549999999999999, 0.119, 0.31, 0.311, 0]]\n\"\"\"\nimport copy\ndef all_pairs_shortest_path(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    for k in range(len(new_array)):\n        for i in range(len(new_array)):\n            for j in range(len(new_array)):",
        "detail": "algorithms.algorithms.graph.all_pairs_shortest_path",
        "documentation": {}
    },
    {
        "label": "bellman_ford",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.bellman_ford",
        "description": "algorithms.algorithms.graph.bellman_ford",
        "peekOfCode": "def bellman_ford(graph, source):\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for i in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node",
        "detail": "algorithms.algorithms.graph.bellman_ford",
        "documentation": {}
    },
    {
        "label": "initialize_single_source",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.bellman_ford",
        "description": "algorithms.algorithms.graph.bellman_ford",
        "peekOfCode": "def initialize_single_source(graph, source, weight, pre_node):\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
        "detail": "algorithms.algorithms.graph.bellman_ford",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.bellman_ford",
        "description": "algorithms.algorithms.graph.bellman_ford",
        "peekOfCode": "graph = {\n    'a': {'b': 6, 'e': 7},\n    'b': {'c': 5, 'd': -4, 'e': 8},\n    'c': {'b': -2},\n    'd': {'a': 2, 'c': 7},\n    'e': {'b': -3}\n}\n'''\ndef bellman_ford(graph, source):\n    weight = {}",
        "detail": "algorithms.algorithms.graph.bellman_ford",
        "documentation": {}
    },
    {
        "label": "check_bipartite",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.check_bipartite",
        "description": "algorithms.algorithms.graph.check_bipartite",
        "peekOfCode": "def check_bipartite(adj_list):\n    V = len(adj_list)\n    # Divide vertexes in the graph into set_type 1 and 2\n    # Initialize all set_types as -1\n    set_type = [-1 for v in range(V)]\n    set_type[0] = 0\n    q = [0]\n    while q:\n        v = q.pop(0)\n        # If there is a self-loop, it cannot be bipartite",
        "detail": "algorithms.algorithms.graph.check_bipartite",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "class Graph:\n\tdef __init__(self,v):\n\t\tself.v = v\n\t\tself.graph = defaultdict(list)\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self):\n\t\tvisited = [False] * self.v\n\t\tself.dfs_util(0,visited)\n\t\tif visited == [True]*self.v:",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "\t\tself.v",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "\t\tself.v = v\n\t\tself.graph = defaultdict(list)\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self):\n\t\tvisited = [False] * self.v\n\t\tself.dfs_util(0,visited)\n\t\tif visited == [True]*self.v:\n\t\t\treturn True\n\t\treturn False",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "\t\tself.graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "\t\tself.graph = defaultdict(list)\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self):\n\t\tvisited = [False] * self.v\n\t\tself.dfs_util(0,visited)\n\t\tif visited == [True]*self.v:\n\t\t\treturn True\n\t\treturn False\n\tdef dfs_util(self,i,visited):",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "\t\tvisited",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "\t\tvisited = [False] * self.v\n\t\tself.dfs_util(0,visited)\n\t\tif visited == [True]*self.v:\n\t\t\treturn True\n\t\treturn False\n\tdef dfs_util(self,i,visited):\n\t\tvisited[i] = True\n\t\tfor u in self.graph[i]:\n\t\t\tif not(visited[u]):\n\t\t\t\tself.dfs_util(u,visited)",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "\t\tvisited[i]",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "\t\tvisited[i] = True\n\t\tfor u in self.graph[i]:\n\t\t\tif not(visited[u]):\n\t\t\t\tself.dfs_util(u,visited)\n\tdef reverse_graph(self):\n\t\tg = Graph(self.v)\n\t\tfor i in range(len(self.graph)):\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tg.add_edge(j,i)\n\t\treturn g",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "\t\tg",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "\t\tg = Graph(self.v)\n\t\tfor i in range(len(self.graph)):\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tg.add_edge(j,i)\n\t\treturn g\n\tdef is_sc(self):\n\t\tif self.dfs():\n\t\t\tgr = self.reverse_graph()\n\t\t\tif gr.dfs():\n\t\t\t\treturn True",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "\t\t\tgr",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "\t\t\tgr = self.reverse_graph()\n\t\t\tif gr.dfs():\n\t\t\t\treturn True\n\t\treturn False\ng1 = Graph(5)\ng1.add_edge(0, 1)\ng1.add_edge(1, 2)\ng1.add_edge(2, 3)\ng1.add_edge(3, 0)\ng1.add_edge(2, 4)",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "g1",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "g1 = Graph(5)\ng1.add_edge(0, 1)\ng1.add_edge(1, 2)\ng1.add_edge(2, 3)\ng1.add_edge(3, 0)\ng1.add_edge(2, 4)\ng1.add_edge(4, 2)\nprint (\"Yes\") if g1.is_sc() else print(\"No\")\ng2 = Graph(4)\ng2.add_edge(0, 1)",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "g2",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "description": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "peekOfCode": "g2 = Graph(4)\ng2.add_edge(0, 1)\ng2.add_edge(1, 2)\ng2.add_edge(2, 3)\nprint (\"Yes\") if g2.is_sc() else print(\"No\")",
        "detail": "algorithms.algorithms.graph.check_digraph_strongly_connected",
        "documentation": {}
    },
    {
        "label": "UndirectedGraphNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.clone_graph",
        "description": "algorithms.algorithms.graph.clone_graph",
        "peekOfCode": "class UndirectedGraphNode:\n    def __init__(self, x):\n        self.label = x\n        self.neighbors = []\n# BFS\ndef clone_graph1(node):\n    if not node:\n        return\n    node_copy = UndirectedGraphNode(node.label)\n    dic = {node: node_copy}",
        "detail": "algorithms.algorithms.graph.clone_graph",
        "documentation": {}
    },
    {
        "label": "clone_graph1",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.clone_graph",
        "description": "algorithms.algorithms.graph.clone_graph",
        "peekOfCode": "def clone_graph1(node):\n    if not node:\n        return\n    node_copy = UndirectedGraphNode(node.label)\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:  # neighbor is not visited",
        "detail": "algorithms.algorithms.graph.clone_graph",
        "documentation": {}
    },
    {
        "label": "clone_graph2",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.clone_graph",
        "description": "algorithms.algorithms.graph.clone_graph",
        "peekOfCode": "def clone_graph2(node):\n    if not node:\n        return\n    node_copy = UndirectedGraphNode(node.label)\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:",
        "detail": "algorithms.algorithms.graph.clone_graph",
        "documentation": {}
    },
    {
        "label": "clone_graph",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.clone_graph",
        "description": "algorithms.algorithms.graph.clone_graph",
        "peekOfCode": "def clone_graph(node):\n    if not node:\n        return\n    node_copy = UndirectedGraphNode(node.label)\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy\ndef dfs(node, dic):\n    for neighbor in node.neighbors:\n        if neighbor not in dic:",
        "detail": "algorithms.algorithms.graph.clone_graph",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.clone_graph",
        "description": "algorithms.algorithms.graph.clone_graph",
        "peekOfCode": "def dfs(node, dic):\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = UndirectedGraphNode(neighbor.label)\n            dic[neighbor] = neighbor_copy\n            dic[node].neighbors.append(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].neighbors.append(dic[neighbor])",
        "detail": "algorithms.algorithms.graph.clone_graph",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.count_connected_number_of_component",
        "description": "algorithms.algorithms.graph.count_connected_number_of_component",
        "peekOfCode": "def dfs(source,visited,l):\n    ''' Function that performs DFS '''\n    visited[source] = True\n    for child in l[source]:\n        if not visited[child]:\n            dfs(child,visited,l)\ndef count_components(l,size):\n    ''' \n    Function that counts the Connected components on bases of DFS.\n    return type : int",
        "detail": "algorithms.algorithms.graph.count_connected_number_of_component",
        "documentation": {}
    },
    {
        "label": "count_components",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.count_connected_number_of_component",
        "description": "algorithms.algorithms.graph.count_connected_number_of_component",
        "peekOfCode": "def count_components(l,size):\n    ''' \n    Function that counts the Connected components on bases of DFS.\n    return type : int\n    '''\n    count = 0\n    visited = [False]*(size+1)\n    for i in range(1,size+1):\n        if not visited[i]:\n            dfs(i,visited,l)",
        "detail": "algorithms.algorithms.graph.count_connected_number_of_component",
        "documentation": {}
    },
    {
        "label": "TraversalState",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.cycle_detection",
        "description": "algorithms.algorithms.graph.cycle_detection",
        "peekOfCode": "class TraversalState(Enum):\n    WHITE = 0\n    GRAY = 1\n    BLACK = 2\nexample_graph_with_cycle = {'A': ['B', 'C'],\n                            'B': ['D'],\n                            'C': ['F'],\n                            'D': ['E', 'F'],\n                            'E': ['B'],\n                            'F': []}",
        "detail": "algorithms.algorithms.graph.cycle_detection",
        "documentation": {}
    },
    {
        "label": "is_in_cycle",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.cycle_detection",
        "description": "algorithms.algorithms.graph.cycle_detection",
        "peekOfCode": "def is_in_cycle(graph, traversal_states, vertex):\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY\n    for neighbor in graph[vertex]:\n        if is_in_cycle(graph, traversal_states, neighbor):\n            return True\n    traversal_states[vertex] = TraversalState.BLACK\n    return False\ndef contains_cycle(graph):",
        "detail": "algorithms.algorithms.graph.cycle_detection",
        "documentation": {}
    },
    {
        "label": "contains_cycle",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.cycle_detection",
        "description": "algorithms.algorithms.graph.cycle_detection",
        "peekOfCode": "def contains_cycle(graph):\n    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}\n    for vertex, state in traversal_states.items():\n        if (state == TraversalState.WHITE and\n           is_in_cycle(graph, traversal_states, vertex)):\n            return True\n    return False\nprint(contains_cycle(example_graph_with_cycle))\nprint(contains_cycle(example_graph_without_cycle))",
        "detail": "algorithms.algorithms.graph.cycle_detection",
        "documentation": {}
    },
    {
        "label": "example_graph_with_cycle",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.cycle_detection",
        "description": "algorithms.algorithms.graph.cycle_detection",
        "peekOfCode": "example_graph_with_cycle = {'A': ['B', 'C'],\n                            'B': ['D'],\n                            'C': ['F'],\n                            'D': ['E', 'F'],\n                            'E': ['B'],\n                            'F': []}\nexample_graph_without_cycle = {'A': ['B', 'C'],\n                               'B': ['D', 'E'],\n                               'C': ['F'],\n                               'D': ['E'],",
        "detail": "algorithms.algorithms.graph.cycle_detection",
        "documentation": {}
    },
    {
        "label": "example_graph_without_cycle",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.cycle_detection",
        "description": "algorithms.algorithms.graph.cycle_detection",
        "peekOfCode": "example_graph_without_cycle = {'A': ['B', 'C'],\n                               'B': ['D', 'E'],\n                               'C': ['F'],\n                               'D': ['E'],\n                               'E': [],\n                               'F': []}\ndef is_in_cycle(graph, traversal_states, vertex):\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY",
        "detail": "algorithms.algorithms.graph.cycle_detection",
        "documentation": {}
    },
    {
        "label": "Dijkstra",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.dijkstra",
        "description": "algorithms.algorithms.graph.dijkstra",
        "peekOfCode": "class Dijkstra():\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]\n    def min_distance(self, dist, min_dist_set):\n        min_dist = float(\"inf\")\n        for v in range(self.vertices):\n            if dist[v] < min_dist and min_dist_set[v] == False:\n                min_dist = dist[v]\n                min_index = v",
        "detail": "algorithms.algorithms.graph.dijkstra",
        "documentation": {}
    },
    {
        "label": "find_all_cliques",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.find_all_cliques",
        "description": "algorithms.algorithms.graph.find_all_cliques",
        "peekOfCode": "def find_all_cliques(edges):\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and not nays:\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)",
        "detail": "algorithms.algorithms.graph.find_all_cliques",
        "documentation": {}
    },
    {
        "label": "find_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.find_path",
        "description": "algorithms.algorithms.graph.find_path",
        "peekOfCode": "def find_path(graph, start, end, path=[]):\n    path = path + [start]\n    if (start == end):\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath",
        "detail": "algorithms.algorithms.graph.find_path",
        "documentation": {}
    },
    {
        "label": "find_all_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.find_path",
        "description": "algorithms.algorithms.graph.find_path",
        "peekOfCode": "def find_all_path(graph, start, end, path=[]):\n    path = path + [start]\n    if (start == end):\n        return [path]\n    if not start in graph:\n        return None\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_path(graph, node, end, path)",
        "detail": "algorithms.algorithms.graph.find_path",
        "documentation": {}
    },
    {
        "label": "find_shortest_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.find_path",
        "description": "algorithms.algorithms.graph.find_path",
        "peekOfCode": "def find_shortest_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)",
        "detail": "algorithms.algorithms.graph.find_path",
        "documentation": {}
    },
    {
        "label": "myGraph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.find_path",
        "description": "algorithms.algorithms.graph.find_path",
        "peekOfCode": "myGraph = {'A': ['B', 'C'],\n         'B': ['C', 'D'],\n         'C': ['D', 'F'],\n         'D': ['C'],\n         'E': ['F'],\n         'F': ['C']}\n# find path from start to end using recursion with backtracking\ndef find_path(graph, start, end, path=[]):\n    path = path + [start]\n    if (start == end):",
        "detail": "algorithms.algorithms.graph.find_path",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.graph",
        "description": "algorithms.algorithms.graph.graph",
        "peekOfCode": "class Node(object):\n    def __init__(self, name):\n        self.name = name\n    @staticmethod\n    def get_name(obj):\n        if isinstance(obj, Node):\n            return obj.name\n        elif isinstance(obj, str):\n            return obj\n        return''",
        "detail": "algorithms.algorithms.graph.graph",
        "documentation": {}
    },
    {
        "label": "DirectedEdge",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.graph",
        "description": "algorithms.algorithms.graph.graph",
        "peekOfCode": "class DirectedEdge(object):\n    def __init__(self, node_from, node_to):\n        self.nf = node_from\n        self.nt = node_to\n    def __eq__(self, obj):\n        if isinstance(obj, DirectedEdge):\n            return obj.nf == self.nf and obj.nt == self.nt\n        return False\n    def __repr__(self):\n        return '({0} -> {1})'.format(self.nf, self.nt)",
        "detail": "algorithms.algorithms.graph.graph",
        "documentation": {}
    },
    {
        "label": "DirectedGraph",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.graph",
        "description": "algorithms.algorithms.graph.graph",
        "peekOfCode": "class DirectedGraph(object):\n    def __init__(self, load_dict={}):\n        self.nodes = []\n        self.edges = []\n        self.adjmt = {}\n        if load_dict and type(load_dict) == dict:\n            for v in load_dict:\n                node_from = self.add_node(v)\n                self.adjmt[node_from] = []\n                for w in load_dict[v]:",
        "detail": "algorithms.algorithms.graph.graph",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.graph",
        "description": "algorithms.algorithms.graph.graph",
        "peekOfCode": "class Graph:\n    def __init__(self, vertices):\n        # No. of vertices\n        self.V = vertices\n        # default dictionary to store graph\n        self.graph = {}\n        # To store transitive closure\n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\n    # function to add an edge to graph\n    def add_edge(self, u, v):",
        "detail": "algorithms.algorithms.graph.graph",
        "documentation": {}
    },
    {
        "label": "#g",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.graph",
        "description": "algorithms.algorithms.graph.graph",
        "peekOfCode": "#g = Graph(4)\n#g.add_edge(0, 1)\n#g.add_edge(0, 2)\n#g.add_edge(1, 2)\n#g.add_edge(2, 0)\n#g.add_edge(2, 3)\n#g.add_edge(3, 3)",
        "detail": "algorithms.algorithms.graph.graph",
        "documentation": {}
    },
    {
        "label": "next_state",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.markov_chain",
        "description": "algorithms.algorithms.graph.markov_chain",
        "peekOfCode": "def next_state(chain, current_state):\n    next_state_map = chain.get(current_state)\n    next_state = __choose_state(next_state_map)\n    return next_state\ndef iterating_markov_chain(chain, state):\n    while True:\n        state = next_state(chain, state)\n        yield state",
        "detail": "algorithms.algorithms.graph.markov_chain",
        "documentation": {}
    },
    {
        "label": "iterating_markov_chain",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.markov_chain",
        "description": "algorithms.algorithms.graph.markov_chain",
        "peekOfCode": "def iterating_markov_chain(chain, state):\n    while True:\n        state = next_state(chain, state)\n        yield state",
        "detail": "algorithms.algorithms.graph.markov_chain",
        "documentation": {}
    },
    {
        "label": "my_chain",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.markov_chain",
        "description": "algorithms.algorithms.graph.markov_chain",
        "peekOfCode": "my_chain = {\n    'A': {'A': 0.6,\n          'E': 0.4},\n    'E': {'A': 0.7,\n          'E': 0.3}\n}\ndef __choose_state(state_map):\n    choice = random.random()\n    probability_reached = 0\n    for state, probability in state_map.items():",
        "detail": "algorithms.algorithms.graph.markov_chain",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow",
        "description": "algorithms.algorithms.graph.maximum_flow",
        "peekOfCode": "def dfs(capacity, flow, visit, vertices, idx, sink, current_flow = 1 << 63):\n    # DFS function for ford_fulkerson algorithm.\n    if idx == sink: \n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, min(current_flow, capacity[idx][nxt]-flow[idx][nxt]))\n            if tmp:\n                flow[idx][nxt] += tmp",
        "detail": "algorithms.algorithms.graph.maximum_flow",
        "documentation": {}
    },
    {
        "label": "ford_fulkerson",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow",
        "description": "algorithms.algorithms.graph.maximum_flow",
        "peekOfCode": "def ford_fulkerson(capacity, source, sink):\n    # Computes maximum flow from source to sink using DFS.\n    # Time Complexity : O(Ef)\n    # E is the number of edges and f is the maximum flow in the graph.\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0]*vertices for i in range(vertices)]\n    while True:\n        visit = [False for i in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)",
        "detail": "algorithms.algorithms.graph.maximum_flow",
        "documentation": {}
    },
    {
        "label": "edmonds_karp",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow",
        "description": "algorithms.algorithms.graph.maximum_flow",
        "peekOfCode": "def edmonds_karp(capacity, source, sink):\n    # Computes maximum flow from source to sink using BFS.\n    # Time complexity : O(V*E^2)\n    # V is the number of vertices and E is the number of edges.\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0]*vertices for i in range(vertices)]\n    while True:\n        tmp = 0\n        q = queue.Queue()",
        "detail": "algorithms.algorithms.graph.maximum_flow",
        "documentation": {}
    },
    {
        "label": "dinic_bfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow",
        "description": "algorithms.algorithms.graph.maximum_flow",
        "peekOfCode": "def dinic_bfs(capacity, flow, level, source, sink):\n    # BFS function for Dinic algorithm.\n    # Check whether sink is reachable only using edges that is not full.\n    vertices = len(capacity)\n    q = queue.Queue()\n    q.put(source)\n    level[source] = 0\n    while q.qsize():\n        front = q.get()\n        for nxt in range(vertices):",
        "detail": "algorithms.algorithms.graph.maximum_flow",
        "documentation": {}
    },
    {
        "label": "dinic_dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow",
        "description": "algorithms.algorithms.graph.maximum_flow",
        "peekOfCode": "def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow = 1 << 63):\n    # DFS function for Dinic algorithm.\n    # Finds new flow using edges that is not full.\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])) ",
        "detail": "algorithms.algorithms.graph.maximum_flow",
        "documentation": {}
    },
    {
        "label": "dinic",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow",
        "description": "algorithms.algorithms.graph.maximum_flow",
        "peekOfCode": "def dinic(capacity, source, sink):\n    # Computes maximum flow from source to sink using Dinic algorithm.\n    # Time complexity : O(V^2*E)\n    # V is the number of vertices and E is the number of edges.\n    vertices = len(capacity)\n    flow = [[0]*vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]",
        "detail": "algorithms.algorithms.graph.maximum_flow",
        "documentation": {}
    },
    {
        "label": "maximum_flow_bfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow_bfs",
        "description": "algorithms.algorithms.graph.maximum_flow_bfs",
        "peekOfCode": "def maximum_flow_bfs(adjacency_matrix):\n    #initial setting\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while(1):\n        #setting min to max_value\n        min = math.inf\n        #save visited nodes\n        visited = [0]*len(new_array)\n        #save parent nodes",
        "detail": "algorithms.algorithms.graph.maximum_flow_bfs",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.maximum_flow_bfs",
        "description": "algorithms.algorithms.graph.maximum_flow_bfs",
        "peekOfCode": "graph = [[0, 16, 13, 0, 0, 0], \n        [0, 0, 10, 12, 0, 0], \n        [0, 4, 0, 0, 14, 0], \n        [0, 0, 9, 0, 0, 20], \n        [0, 0, 0, 7, 0, 4], \n        [0, 0, 0, 0, 0, 0]] \nanswer should be\n23\n\"\"\"\nimport copy",
        "detail": "algorithms.algorithms.graph.maximum_flow_bfs",
        "documentation": {}
    },
    {
        "label": "maximum_flow_dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.maximum_flow_dfs",
        "description": "algorithms.algorithms.graph.maximum_flow_dfs",
        "peekOfCode": "def maximum_flow_dfs(adjacency_matrix):\n    #initial setting\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while(1):\n        #setting min to max_value\n        min = math.inf\n        #save visited nodes\n        visited = [0]*len(new_array)\n        #save parent nodes",
        "detail": "algorithms.algorithms.graph.maximum_flow_dfs",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.maximum_flow_dfs",
        "description": "algorithms.algorithms.graph.maximum_flow_dfs",
        "peekOfCode": "graph = [[0, 16, 13, 0, 0, 0], \n        [0, 0, 10, 12, 0, 0], \n        [0, 4, 0, 0, 14, 0], \n        [0, 0, 9, 0, 0, 20], \n        [0, 0, 0, 7, 0, 4], \n        [0, 0, 0, 0, 0, 0]] \nanswer should be\n23\n\"\"\"\nimport copy",
        "detail": "algorithms.algorithms.graph.maximum_flow_dfs",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.minimum_spanning_tree",
        "description": "algorithms.algorithms.graph.minimum_spanning_tree",
        "peekOfCode": "class Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\nclass DisjointSet:\n    def __init__(self, n):\n        # Args:\n        #   n (int): Number of vertices in the graph\n        self.parent = [None] * n # Contains wich node is the parent of the node at poisition <i>",
        "detail": "algorithms.algorithms.graph.minimum_spanning_tree",
        "documentation": {}
    },
    {
        "label": "DisjointSet",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.minimum_spanning_tree",
        "description": "algorithms.algorithms.graph.minimum_spanning_tree",
        "peekOfCode": "class DisjointSet:\n    def __init__(self, n):\n        # Args:\n        #   n (int): Number of vertices in the graph\n        self.parent = [None] * n # Contains wich node is the parent of the node at poisition <i>\n        self.size = [1] * n # Contains size of node at index <i>, used to optimize merge\n        for i in range(n):\n            self.parent[i] = i # Make all nodes his own parent, creating n sets.\n    def merge_set(self, a, b):\n        # Args:",
        "detail": "algorithms.algorithms.graph.minimum_spanning_tree",
        "documentation": {}
    },
    {
        "label": "kruskal",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.minimum_spanning_tree",
        "description": "algorithms.algorithms.graph.minimum_spanning_tree",
        "peekOfCode": "def kruskal(n, edges, ds):\n    # Args:\n    #   n (int): Number of vertices in the graph\n    #   edges (list of Edge): Edges of the graph\n    #   ds (DisjointSet): DisjointSet of the vertices\n    # Returns:\n    #   int: sum of weights of the minnimum spanning tree \n    #\n    # Kruskal algorithm:\n    #   This algorithm will find the optimal graph with less edges and less",
        "detail": "algorithms.algorithms.graph.minimum_spanning_tree",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "class Graph:\n\tdef __init__(self,v):\n\t\tself.v = v\n\t\tself.graph = defaultdict(list)\n\t\tself.has_path = False\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self,x,y):\n\t\tvisited = [False] * self.v\n\t\tself.dfsutil(visited,x,y,)",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\tself.v",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\tself.v = v\n\t\tself.graph = defaultdict(list)\n\t\tself.has_path = False\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self,x,y):\n\t\tvisited = [False] * self.v\n\t\tself.dfsutil(visited,x,y,)\n\tdef dfsutil(self,visited,x,y):\n\t\tvisited[x] = True",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\tself.graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\tself.graph = defaultdict(list)\n\t\tself.has_path = False\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self,x,y):\n\t\tvisited = [False] * self.v\n\t\tself.dfsutil(visited,x,y,)\n\tdef dfsutil(self,visited,x,y):\n\t\tvisited[x] = True\n\t\tfor i in self.graph[x]:",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\tself.has_path",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\tself.has_path = False\n\tdef add_edge(self,u,v):\n\t\tself.graph[u].append(v)\n\tdef dfs(self,x,y):\n\t\tvisited = [False] * self.v\n\t\tself.dfsutil(visited,x,y,)\n\tdef dfsutil(self,visited,x,y):\n\t\tvisited[x] = True\n\t\tfor i in self.graph[x]:\n\t\t\tif y in self.graph[x]:",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\tvisited",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\tvisited = [False] * self.v\n\t\tself.dfsutil(visited,x,y,)\n\tdef dfsutil(self,visited,x,y):\n\t\tvisited[x] = True\n\t\tfor i in self.graph[x]:\n\t\t\tif y in self.graph[x]:\n\t\t\t\tself.has_path = True\n\t\t\t\treturn\n\t\t\tif(not(visited[i])):\n\t\t\t\tself.dfsutil(visited,x,i)",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\tvisited[x]",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\tvisited[x] = True\n\t\tfor i in self.graph[x]:\n\t\t\tif y in self.graph[x]:\n\t\t\t\tself.has_path = True\n\t\t\t\treturn\n\t\t\tif(not(visited[i])):\n\t\t\t\tself.dfsutil(visited,x,i)\n\tdef is_reachable(self,x,y):\n\t\tself.has_path = False\n\t\tself.dfs(x,y)",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.has_path",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\t\t\tself.has_path = True\n\t\t\t\treturn\n\t\t\tif(not(visited[i])):\n\t\t\t\tself.dfsutil(visited,x,i)\n\tdef is_reachable(self,x,y):\n\t\tself.has_path = False\n\t\tself.dfs(x,y)\n\t\treturn self.has_path\n# Create a graph given in the above diagram\ng = Graph(4)",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "\t\tself.has_path",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "\t\tself.has_path = False\n\t\tself.dfs(x,y)\n\t\treturn self.has_path\n# Create a graph given in the above diagram\ng = Graph(4)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "g = Graph(4)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\nu =1; v = 3\nif g.is_reachable(u, v):\n    print(\"There is a path from %d to %d\" % (u,v))",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "u",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "description": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "peekOfCode": "u = 3; v = 1\nif g.is_reachable(u, v) :\n    print(\"There is a path from %d to %d\" % (u,v))\nelse :\n    print(\"There is no path from %d to %d\" % (u,v))",
        "detail": "algorithms.algorithms.graph.path_between_two_vertices_in_digraph",
        "documentation": {}
    },
    {
        "label": "prims_minimum_spanning",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.prims_minimum_spanning",
        "description": "algorithms.algorithms.graph.prims_minimum_spanning",
        "peekOfCode": "def prims_minimum_spanning(graph_used):\n    vis=[]\n    s=[[0,1]]\n    prim = []\n    mincost=0\n    while(len(s)>0):\n        v=heapq.heappop(s)\n        x=v[1]\n        if(x in vis):\n            continue",
        "detail": "algorithms.algorithms.graph.prims_minimum_spanning",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.prims_minimum_spanning",
        "description": "algorithms.algorithms.graph.prims_minimum_spanning",
        "peekOfCode": "graph = {\n    'a': [ [3, 'b'], [8,'c'] ],\n    'b': [ [3, 'a'], [5, 'd'] ],\n    'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n    'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n    'e': [ [4, 'c'], [6, 'd'] ]\n}\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)\n'''\nimport heapq  # for priority queue",
        "detail": "algorithms.algorithms.graph.prims_minimum_spanning",
        "documentation": {}
    },
    {
        "label": "dfs_transposed",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "def dfs_transposed(v, graph, order, vis):\n    vis[v] = True\n    for u in graph[v]:\n        if not vis[u]:\n            dfs_transposed(u, graph, order, vis)\n    order.append(v)\ndef dfs(v, current_comp, vertex_scc, graph, vis):\n    vis[v] = True\n    vertex_scc[v] = current_comp\n    for u in graph[v]:",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "def dfs(v, current_comp, vertex_scc, graph, vis):\n    vis[v] = True\n    vertex_scc[v] = current_comp\n    for u in graph[v]:\n        if not vis[u]:\n            dfs(u, current_comp, vertex_scc, graph, vis)\ndef add_edge(graph, vertex_from, vertex_to):\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "add_edge",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "def add_edge(graph, vertex_from, vertex_to):\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)\ndef scc(graph):\n    ''' Computes the strongly connected components of a graph '''\n    order = []\n    vis = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (v, neighbours) in graph.iteritems():",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "scc",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "def scc(graph):\n    ''' Computes the strongly connected components of a graph '''\n    order = []\n    vis = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (v, neighbours) in graph.iteritems():\n        for u in neighbours:\n            add_edge(graph_transposed, u, v)\n    for v in graph:\n        if not vis[v]:",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "build_graph",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "def build_graph(formula):\n    ''' Builds the implication graph from the formula '''\n    graph = {}\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[(lit, neg)] = []\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "solve_sat",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "def solve_sat(formula):\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n    for (var, _) in graph:\n        if vertex_scc[(var, False)] == vertex_scc[(var, True)]:\n            return None  # The formula is contradictory\n    comp_repr = {}  # An arbitrary representant from each component\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "formula",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.satisfiability",
        "description": "algorithms.algorithms.graph.satisfiability",
        "peekOfCode": "formula = [(('x', False), ('y', False)),\n           (('y', True), ('y', True)),\n           (('a', False), ('b', False)),\n           (('a', True), ('c', True)),\n           (('c', False), ('b', True))]\ndef dfs_transposed(v, graph, order, vis):\n    vis[v] = True\n    for u in graph[v]:\n        if not vis[u]:\n            dfs_transposed(u, graph, order, vis)",
        "detail": "algorithms.algorithms.graph.satisfiability",
        "documentation": {}
    },
    {
        "label": "Tarjan",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.tarjan",
        "description": "algorithms.algorithms.graph.tarjan",
        "peekOfCode": "class Tarjan(object):\n    def __init__(self, dict_graph):\n        self.graph = DirectedGraph(dict_graph)\n        self.index = 0\n        self.stack = []\n        # Runs Tarjan\n        # Set all node index to None\n        for v in self.graph.nodes:\n            v.index = None\n        self.sccs = []",
        "detail": "algorithms.algorithms.graph.tarjan",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "algorithms.algorithms.graph.transitive_closure_dfs",
        "description": "algorithms.algorithms.graph.transitive_closure_dfs",
        "peekOfCode": "class Graph:\n    def __init__(self, vertices):\n        # No. of vertices\n        self.V = vertices\n        # default dictionary to store graph\n        self.graph = {}\n        # To store transitive closure\n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\n    # function to add an edge to graph\n    def add_edge(self, u, v):",
        "detail": "algorithms.algorithms.graph.transitive_closure_dfs",
        "documentation": {}
    },
    {
        "label": "dfs_traverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.traversal",
        "description": "algorithms.algorithms.graph.traversal",
        "peekOfCode": "def dfs_traverse(graph, start):\n    visited, stack = set(), [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for nextNode in graph[node]:\n                if nextNode not in visited:\n                    stack.append(nextNode)\n    return visited",
        "detail": "algorithms.algorithms.graph.traversal",
        "documentation": {}
    },
    {
        "label": "bfs_traverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.traversal",
        "description": "algorithms.algorithms.graph.traversal",
        "peekOfCode": "def bfs_traverse(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for nextNode in graph[node]:\n                if nextNode not in visited:\n                    queue.append(nextNode)\n    return visited",
        "detail": "algorithms.algorithms.graph.traversal",
        "documentation": {}
    },
    {
        "label": "dfs_traverse_recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.graph.traversal",
        "description": "algorithms.algorithms.graph.traversal",
        "peekOfCode": "def dfs_traverse_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for nextNode in graph[start]:\n        if nextNode not in visited:\n            dfs_traverse_recursive(graph, nextNode, visited)\n    return visited\n# print(dfs_traverse_recursive(graph, 'A'))\n# def find_path(graph, start, end, visited=[]):",
        "detail": "algorithms.algorithms.graph.traversal",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "algorithms.algorithms.graph.traversal",
        "description": "algorithms.algorithms.graph.traversal",
        "peekOfCode": "graph = {'A': set(['B', 'C', 'F']),\n         'B': set(['A', 'D', 'E']),\n         'C': set(['A', 'F']),\n         'D': set(['B']),\n         'E': set(['B', 'F']),\n         'F': set(['A', 'C', 'E'])}\n# dfs and bfs are the ultimately same except that they are visiting nodes in\n# different order. To simulate this ordering we would use stack for dfs and\n# queue for bfs.\n#",
        "detail": "algorithms.algorithms.graph.traversal",
        "documentation": {}
    },
    {
        "label": "AbstractHeap",
        "kind": 6,
        "importPath": "algorithms.algorithms.heap.binary_heap",
        "description": "algorithms.algorithms.heap.binary_heap",
        "peekOfCode": "class AbstractHeap(metaclass=ABCMeta):\n    \"\"\"Abstract Class for Binary Heap.\"\"\"\n    def __init__(self):\n        pass\n    @abstractmethod\n    def perc_up(self, i):\n        pass\n    @abstractmethod\n    def insert(self, val):\n        pass",
        "detail": "algorithms.algorithms.heap.binary_heap",
        "documentation": {}
    },
    {
        "label": "BinaryHeap",
        "kind": 6,
        "importPath": "algorithms.algorithms.heap.binary_heap",
        "description": "algorithms.algorithms.heap.binary_heap",
        "peekOfCode": "class BinaryHeap(AbstractHeap):\n    def __init__(self):\n        self.currentSize = 0\n        self.heap = [(0)]\n    def perc_up(self, i):\n        while i // 2 > 0:\n            if self.heap[i] < self.heap[i // 2]:\n                # Swap value of child with value of its parent\n                self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i]\n            i = i // 2",
        "detail": "algorithms.algorithms.heap.binary_heap",
        "documentation": {}
    },
    {
        "label": "k_closest",
        "kind": 2,
        "importPath": "algorithms.algorithms.heap.k_closest_points",
        "description": "algorithms.algorithms.heap.k_closest_points",
        "peekOfCode": "def k_closest(points, k, origin=(0, 0)):\n    # Time: O(k+(n-k)logk)\n    # Space: O(k)\n    \"\"\"Initialize max heap with first k points.\n    Python does not support a max heap; thus we can use the default min heap where the keys (distance) are negated.\n    \"\"\"\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n    \"\"\"\n    For every point p in points[k:],",
        "detail": "algorithms.algorithms.heap.k_closest_points",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 2,
        "importPath": "algorithms.algorithms.heap.k_closest_points",
        "description": "algorithms.algorithms.heap.k_closest_points",
        "peekOfCode": "def distance(point, origin=(0, 0)):\n    return (point[0] - origin[0])**2 + (point[1] - origin[1])**2",
        "detail": "algorithms.algorithms.heap.k_closest_points",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "description": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef merge_k_lists(lists):\n    dummy = node = ListNode(0)\n    h = [(n.val, n) for n in lists if n]\n    heapify(h)\n    while h:\n        v, n = h[0]",
        "detail": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "documentation": {}
    },
    {
        "label": "merge_k_lists",
        "kind": 2,
        "importPath": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "description": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "peekOfCode": "def merge_k_lists(lists):\n    dummy = node = ListNode(0)\n    h = [(n.val, n) for n in lists if n]\n    heapify(h)\n    while h:\n        v, n = h[0]\n        if n.next is None:\n            heappop(h)  # only change heap size when necessary\n        else:\n            heapreplace(h, (n.next.val, n.next))",
        "detail": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "documentation": {}
    },
    {
        "label": "merge_k_lists",
        "kind": 2,
        "importPath": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "description": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "peekOfCode": "def merge_k_lists(lists):\n    dummy = ListNode(None)\n    curr = dummy\n    q = PriorityQueue()\n    for node in lists:\n        if node:\n            q.put((node.val, node))\n    while not q.empty():\n        curr.next = q.get()[1]  # These two lines seem to\n        curr = curr.next  # be equivalent to :-   curr = q.get()[1]",
        "detail": "algorithms.algorithms.heap.merge_sorted_k_lists",
        "documentation": {}
    },
    {
        "label": "get_skyline",
        "kind": 2,
        "importPath": "algorithms.algorithms.heap.skyline",
        "description": "algorithms.algorithms.heap.skyline",
        "peekOfCode": "def get_skyline(lrh):\n    \"\"\"\n    Wortst Time Complexity: O(NlogN)\n    :type buildings: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    skyline, live = [], []\n    i, n = 0, len(lrh)\n    while i < n or live:\n        if not live or i < n and lrh[i][0] <= -live[0][1]:",
        "detail": "algorithms.algorithms.heap.skyline",
        "documentation": {}
    },
    {
        "label": "max_sliding_window",
        "kind": 2,
        "importPath": "algorithms.algorithms.heap.sliding_window_max",
        "description": "algorithms.algorithms.heap.sliding_window_max",
        "peekOfCode": "def max_sliding_window(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return nums\n    queue = collections.deque()\n    res = []",
        "detail": "algorithms.algorithms.heap.sliding_window_max",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.add_two_numbers",
        "description": "algorithms.algorithms.linkedlist.add_two_numbers",
        "peekOfCode": "class Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef add_two_numbers(left: Node, right: Node) -> Node:\n    head = Node(0)\n    current = head\n    sum = 0\n    while left or right:\n        print(\"adding: \", left.val, right.val)",
        "detail": "algorithms.algorithms.linkedlist.add_two_numbers",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.add_two_numbers",
        "description": "algorithms.algorithms.linkedlist.add_two_numbers",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    \"\"\"\n        testsuite for the linked list structure and\n        the adding function, above.\n    \"\"\"\n    def test_convert_to_str(self):\n        number1 = Node(2)\n        number1.next = Node(4)\n        number1.next.next = Node(3)\n        self.assertEqual(\"243\", convert_to_str(number1))",
        "detail": "algorithms.algorithms.linkedlist.add_two_numbers",
        "documentation": {}
    },
    {
        "label": "add_two_numbers",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.add_two_numbers",
        "description": "algorithms.algorithms.linkedlist.add_two_numbers",
        "peekOfCode": "def add_two_numbers(left: Node, right: Node) -> Node:\n    head = Node(0)\n    current = head\n    sum = 0\n    while left or right:\n        print(\"adding: \", left.val, right.val)\n        sum //= 10\n        if left:\n            sum += left.val\n            left = left.next",
        "detail": "algorithms.algorithms.linkedlist.add_two_numbers",
        "documentation": {}
    },
    {
        "label": "convert_to_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.add_two_numbers",
        "description": "algorithms.algorithms.linkedlist.add_two_numbers",
        "peekOfCode": "def convert_to_list(number: int) -> Node:\n    \"\"\"\n        converts a positive integer into a (reversed) linked list.\n        for example: give 112\n        result 2 -> 1 -> 1\n    \"\"\"\n    if number >= 0:\n        head = Node(0)\n        current = head\n        remainder = number % 10",
        "detail": "algorithms.algorithms.linkedlist.add_two_numbers",
        "documentation": {}
    },
    {
        "label": "convert_to_str",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.add_two_numbers",
        "description": "algorithms.algorithms.linkedlist.add_two_numbers",
        "peekOfCode": "def convert_to_str(l: Node) -> str:\n    \"\"\"\n        converts the non-negative number list into a string.\n    \"\"\"\n    result = \"\"\n    while l:\n        result += str(l.val)\n        l = l.next\n    return result\nclass TestSuite(unittest.TestCase):",
        "detail": "algorithms.algorithms.linkedlist.add_two_numbers",
        "documentation": {}
    },
    {
        "label": "RandomListNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "description": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "peekOfCode": "class RandomListNode(object):\n    def __init__(self, label):\n        self.label = label\n        self.next = None\n        self.random = None\ndef copy_random_pointer_v1(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"",
        "detail": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "documentation": {}
    },
    {
        "label": "copy_random_pointer_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "description": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "peekOfCode": "def copy_random_pointer_v1(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next",
        "detail": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "documentation": {}
    },
    {
        "label": "copy_random_pointer_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "description": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "peekOfCode": "def copy_random_pointer_v2(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"\n    copy = defaultdict(lambda: RandomListNode(0))\n    copy[None] = None\n    node = head\n    while node:\n        copy[node].label = node.label",
        "detail": "algorithms.algorithms.linkedlist.copy_random_pointer",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.delete_node",
        "description": "algorithms.algorithms.linkedlist.delete_node",
        "peekOfCode": "class Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef delete_node(node):\n    if node is None or node.next is None:\n        raise ValueError\n    node.val = node.next.val\n    node.next = node.next.next\nclass TestSuite(unittest.TestCase):",
        "detail": "algorithms.algorithms.linkedlist.delete_node",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.delete_node",
        "description": "algorithms.algorithms.linkedlist.delete_node",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_delete_node(self):\n        # make linkedlist 1 -> 2 -> 3 -> 4\n        head = Node(1)\n        curr = head\n        for i in range(2, 6):\n            curr.next = Node(i)\n            curr = curr.next\n        # node3 = 3\n        node3 = head.next.next",
        "detail": "algorithms.algorithms.linkedlist.delete_node",
        "documentation": {}
    },
    {
        "label": "delete_node",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.delete_node",
        "description": "algorithms.algorithms.linkedlist.delete_node",
        "peekOfCode": "def delete_node(node):\n    if node is None or node.next is None:\n        raise ValueError\n    node.val = node.next.val\n    node.next = node.next.next\nclass TestSuite(unittest.TestCase):\n    def test_delete_node(self):\n        # make linkedlist 1 -> 2 -> 3 -> 4\n        head = Node(1)\n        curr = head",
        "detail": "algorithms.algorithms.linkedlist.delete_node",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "description": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "peekOfCode": "class Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef first_cyclic_node(head):\n    \"\"\"\n    :type head: Node\n    :rtype: Node\n    \"\"\"\n    runner = walker = head",
        "detail": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "description": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_first_cyclic_node(self):\n        # create linked list => A -> B -> C -> D -> E -> C\n        head = Node('A')\n        head.next = Node('B')\n        curr = head.next\n        cyclic_node = Node('C')\n        curr.next = cyclic_node\n        curr = curr.next\n        curr.next = Node('D')",
        "detail": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "documentation": {}
    },
    {
        "label": "first_cyclic_node",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "description": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "peekOfCode": "def first_cyclic_node(head):\n    \"\"\"\n    :type head: Node\n    :rtype: Node\n    \"\"\"\n    runner = walker = head\n    while runner and runner.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner is walker:",
        "detail": "algorithms.algorithms.linkedlist.first_cyclic_node",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.intersection",
        "description": "algorithms.algorithms.linkedlist.intersection",
        "peekOfCode": "class Node(object):\n    def __init__(self, val=None):\n        self.val = val\n        self.next = None\ndef intersection(h1, h2):\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n    while h1 or h2:",
        "detail": "algorithms.algorithms.linkedlist.intersection",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.intersection",
        "description": "algorithms.algorithms.linkedlist.intersection",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_intersection(self):\n        # create linked list as:\n        # 1 -> 3 -> 5\n        #            \\\n        #             7 -> 9 -> 11\n        #            /\n        # 2 -> 4 -> 6\n        a1 = Node(1)\n        b1 = Node(3)",
        "detail": "algorithms.algorithms.linkedlist.intersection",
        "documentation": {}
    },
    {
        "label": "intersection",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.intersection",
        "description": "algorithms.algorithms.linkedlist.intersection",
        "peekOfCode": "def intersection(h1, h2):\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n    while h1 or h2:\n        count += 1\n        if not flag and (h1.next is None or h2.next is None):\n            # We hit the end of one of the lists, set a flag for this\n            flag = (count, h1.next, h2.next)",
        "detail": "algorithms.algorithms.linkedlist.intersection",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.is_cyclic",
        "description": "algorithms.algorithms.linkedlist.is_cyclic",
        "peekOfCode": "class Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef is_cyclic(head):\n    \"\"\"\n    :type head: Node\n    :rtype: bool\n    \"\"\"\n    if not head:",
        "detail": "algorithms.algorithms.linkedlist.is_cyclic",
        "documentation": {}
    },
    {
        "label": "is_cyclic",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.is_cyclic",
        "description": "algorithms.algorithms.linkedlist.is_cyclic",
        "peekOfCode": "def is_cyclic(head):\n    \"\"\"\n    :type head: Node\n    :rtype: bool\n    \"\"\"\n    if not head:\n        return False\n    runner = head\n    walker = head\n    while runner.next and runner.next.next:",
        "detail": "algorithms.algorithms.linkedlist.is_cyclic",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.is_palindrome",
        "description": "algorithms.algorithms.linkedlist.is_palindrome",
        "peekOfCode": "def is_palindrome(head):\n    if not head:\n        return True\n    # split the list to two parts\n    fast, slow = head.next, head\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None  # Don't forget here! But forget still works!",
        "detail": "algorithms.algorithms.linkedlist.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome_stack",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.is_palindrome",
        "description": "algorithms.algorithms.linkedlist.is_palindrome",
        "peekOfCode": "def is_palindrome_stack(head):\n    if not head or not head.next:\n        return True\n    # 1. Get the midpoint (slow)\n    slow = fast = cur = head\n    while fast and fast.next:\n        fast, slow = fast.next.next, slow.next\n    # 2. Push the second half into the stack\n    stack = [slow.val]\n    while slow.next:",
        "detail": "algorithms.algorithms.linkedlist.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome_dict",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.is_palindrome",
        "description": "algorithms.algorithms.linkedlist.is_palindrome",
        "peekOfCode": "def is_palindrome_dict(head):\n    \"\"\"\n    This function builds up a dictionary where the keys are the values of the list,\n    and the values are the positions at which these values occur in the list.\n    We then iterate over the dict and if there is more than one key with an odd\n    number of occurrences, bail out and return False.\n    Otherwise, we want to ensure that the positions of occurrence sum to the\n    value of the length of the list - 1, working from the outside of the list inward.\n    For example:\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1",
        "detail": "algorithms.algorithms.linkedlist.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.is_sorted",
        "description": "algorithms.algorithms.linkedlist.is_sorted",
        "peekOfCode": "def is_sorted(head):\n    if not head:\n        return True\n    current = head\n    while current.next:\n        if current.val > current.next.val:\n            return False\n        current = current.next\n    return True",
        "detail": "algorithms.algorithms.linkedlist.is_sorted",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.kth_to_last",
        "description": "algorithms.algorithms.linkedlist.kth_to_last",
        "peekOfCode": "class Node():\n    def __init__(self, val=None):\n        self.val = val\n        self.next = None\ndef kth_to_last_eval(head, k):\n    \"\"\"\n    This is a suboptimal, hacky method using eval(), which is not\n     safe for user input. We guard against danger by ensuring k in an int\n    \"\"\"\n    if not isinstance(k, int) or not head.val:",
        "detail": "algorithms.algorithms.linkedlist.kth_to_last",
        "documentation": {}
    },
    {
        "label": "kth_to_last_eval",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.kth_to_last",
        "description": "algorithms.algorithms.linkedlist.kth_to_last",
        "peekOfCode": "def kth_to_last_eval(head, k):\n    \"\"\"\n    This is a suboptimal, hacky method using eval(), which is not\n     safe for user input. We guard against danger by ensuring k in an int\n    \"\"\"\n    if not isinstance(k, int) or not head.val:\n        return False\n    nexts = '.'.join(['next' for n in range(1, k+1)])\n    seeker = str('.'.join(['head', nexts]))\n    while head:",
        "detail": "algorithms.algorithms.linkedlist.kth_to_last",
        "documentation": {}
    },
    {
        "label": "kth_to_last_dict",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.kth_to_last",
        "description": "algorithms.algorithms.linkedlist.kth_to_last",
        "peekOfCode": "def kth_to_last_dict(head, k):\n    \"\"\"\n    This is a brute force method where we keep a dict the size of the list\n    Then we check it for the value we need. If the key is not in the dict,\n    our and statement will short circuit and return False\n    \"\"\"\n    if not (head and k > -1):\n        return False\n    d = dict()\n    count = 0",
        "detail": "algorithms.algorithms.linkedlist.kth_to_last",
        "documentation": {}
    },
    {
        "label": "kth_to_last",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.kth_to_last",
        "description": "algorithms.algorithms.linkedlist.kth_to_last",
        "peekOfCode": "def kth_to_last(head, k):\n    \"\"\"\n    This is an optimal method using iteration.\n    We move p1 k steps ahead into the list.\n    Then we move p1 and p2 together until p1 hits the end.\n    \"\"\"\n    if not (head or k > -1):\n        return False\n    p1 = head\n    p2 = head",
        "detail": "algorithms.algorithms.linkedlist.kth_to_last",
        "documentation": {}
    },
    {
        "label": "print_linked_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.kth_to_last",
        "description": "algorithms.algorithms.linkedlist.kth_to_last",
        "peekOfCode": "def print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += head.val + \" -> \"\n        head = head.next\n    string += head.val\n    print(string)\ndef test():\n    # def make_test_li\n    # A A B C D C F G",
        "detail": "algorithms.algorithms.linkedlist.kth_to_last",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.kth_to_last",
        "description": "algorithms.algorithms.linkedlist.kth_to_last",
        "peekOfCode": "def test():\n    # def make_test_li\n    # A A B C D C F G\n    a1 = Node(\"A\")\n    a2 = Node(\"A\")\n    b = Node(\"B\")\n    c1 = Node(\"C\")\n    d = Node(\"D\")\n    c2 = Node(\"C\")\n    f = Node(\"F\")",
        "detail": "algorithms.algorithms.linkedlist.kth_to_last",
        "documentation": {}
    },
    {
        "label": "DoublyLinkedListNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.linkedlist",
        "description": "algorithms.algorithms.linkedlist.linkedlist",
        "peekOfCode": "class DoublyLinkedListNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\nclass SinglyLinkedListNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None",
        "detail": "algorithms.algorithms.linkedlist.linkedlist",
        "documentation": {}
    },
    {
        "label": "SinglyLinkedListNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.linkedlist",
        "description": "algorithms.algorithms.linkedlist.linkedlist",
        "peekOfCode": "class SinglyLinkedListNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None",
        "detail": "algorithms.algorithms.linkedlist.linkedlist",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.merge_two_list",
        "description": "algorithms.algorithms.linkedlist.merge_two_list",
        "peekOfCode": "class Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef merge_two_list(l1, l2):\n    ret = cur = Node(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next",
        "detail": "algorithms.algorithms.linkedlist.merge_two_list",
        "documentation": {}
    },
    {
        "label": "merge_two_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.merge_two_list",
        "description": "algorithms.algorithms.linkedlist.merge_two_list",
        "peekOfCode": "def merge_two_list(l1, l2):\n    ret = cur = Node(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next",
        "detail": "algorithms.algorithms.linkedlist.merge_two_list",
        "documentation": {}
    },
    {
        "label": "merge_two_list_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.merge_two_list",
        "description": "algorithms.algorithms.linkedlist.merge_two_list",
        "peekOfCode": "def merge_two_list_recur(l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = merge_two_list_recur(l1.next, l2)\n        return l1\n    else:\n        l2.next = merge_two_list_recur(l1, l2.next)\n        return l2",
        "detail": "algorithms.algorithms.linkedlist.merge_two_list",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.partition",
        "description": "algorithms.algorithms.linkedlist.partition",
        "peekOfCode": "class Node():\n    def __init__(self, val=None):\n        self.val = int(val)\n        self.next = None\ndef print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += str(head.val) + \" -> \"\n        head = head.next\n    string += str(head.val)",
        "detail": "algorithms.algorithms.linkedlist.partition",
        "documentation": {}
    },
    {
        "label": "print_linked_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.partition",
        "description": "algorithms.algorithms.linkedlist.partition",
        "peekOfCode": "def print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += str(head.val) + \" -> \"\n        head = head.next\n    string += str(head.val)\n    print(string)\ndef partition(head, x):\n    left = None\n    right = None",
        "detail": "algorithms.algorithms.linkedlist.partition",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.partition",
        "description": "algorithms.algorithms.linkedlist.partition",
        "peekOfCode": "def partition(head, x):\n    left = None\n    right = None\n    prev = None\n    current = head\n    while current:\n        if int(current.val) >= x:\n            if not right:\n                right = current\n        else:",
        "detail": "algorithms.algorithms.linkedlist.partition",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.partition",
        "description": "algorithms.algorithms.linkedlist.partition",
        "peekOfCode": "def test():\n    a = Node(\"3\")\n    b = Node(\"5\")\n    c = Node(\"8\")\n    d = Node(\"5\")\n    e = Node(\"10\")\n    f = Node(\"2\")\n    g = Node(\"1\")\n    a.next = b\n    b.next = c",
        "detail": "algorithms.algorithms.linkedlist.partition",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "class Node():\n    def __init__(self, val = None):\n        self.val = val\n        self.next = None\ndef remove_dups(head):\n    \"\"\"\n    Time Complexity: O(N)\n    Space Complexity: O(N)\n    \"\"\"\n    hashset = set()",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "remove_dups",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "def remove_dups(head):\n    \"\"\"\n    Time Complexity: O(N)\n    Space Complexity: O(N)\n    \"\"\"\n    hashset = set()\n    prev = Node()\n    while head:\n        if head.val in hashset:\n            prev.next = head.next",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "remove_dups_wothout_set",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "def remove_dups_wothout_set(head):\n    \"\"\"\n    Time Complexity: O(N^2)\n    Space Complexity: O(1)\n    \"\"\"\n    current = head\n    while current:\n        runner = current\n        while runner.next:\n            if runner.next.val == current.val:",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "print_linked_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "def print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += head.val + \" -> \"\n        head = head.next\n    string += head.val\n    print(string)\n# A A B C D C F G\na1 = Node(\"A\")\na2 = Node(\"A\")",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "a1",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "a1 = Node(\"A\")\na2 = Node(\"A\")\nb = Node(\"B\")\nc1 = Node(\"C\")\nd = Node(\"D\")\nc2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "a2 = Node(\"A\")\nb = Node(\"B\")\nc1 = Node(\"C\")\nd = Node(\"D\")\nc2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "b = Node(\"B\")\nc1 = Node(\"C\")\nd = Node(\"D\")\nc2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "c1",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "c1 = Node(\"C\")\nd = Node(\"D\")\nc2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "d = Node(\"D\")\nc2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "c2",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "c2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "f = Node(\"F\")\ng = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "g = Node(\"G\")\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "a1.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "a1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "a2.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "a2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "b.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "b.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "c1.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "c1.next = d\nd.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "d.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "d.next = c2\nc2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "c2.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "c2.next = f\nf.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "f.next",
        "kind": 5,
        "importPath": "algorithms.algorithms.linkedlist.remove_duplicates",
        "description": "algorithms.algorithms.linkedlist.remove_duplicates",
        "peekOfCode": "f.next = g\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)",
        "detail": "algorithms.algorithms.linkedlist.remove_duplicates",
        "documentation": {}
    },
    {
        "label": "remove_range",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.remove_range",
        "description": "algorithms.algorithms.linkedlist.remove_range",
        "peekOfCode": "def remove_range(head, start, end):\n    assert(start <= end)\n    # Case: remove node at head\n    if start == 0:\n        for i in range(0, end+1):\n            if head != None:\n                head = head.next\n    else:\n        current = head\n        # Move pointer to start position",
        "detail": "algorithms.algorithms.linkedlist.remove_range",
        "documentation": {}
    },
    {
        "label": "reverse_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.reverse",
        "description": "algorithms.algorithms.linkedlist.reverse",
        "peekOfCode": "def reverse_list(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if not head or not head.next:\n        return head\n    prev = None\n    while head:\n        current = head",
        "detail": "algorithms.algorithms.linkedlist.reverse",
        "documentation": {}
    },
    {
        "label": "reverse_list_recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.reverse",
        "description": "algorithms.algorithms.linkedlist.reverse",
        "peekOfCode": "def reverse_list_recursive(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if head is None or head.next is None:\n        return head\n    p = head.next\n    head.next = None\n    revrest = reverse_list_recursive(p)",
        "detail": "algorithms.algorithms.linkedlist.reverse",
        "documentation": {}
    },
    {
        "label": "rotate_right",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.rotate_list",
        "description": "algorithms.algorithms.linkedlist.rotate_list",
        "peekOfCode": "def rotate_right(head, k):\n    \"\"\"\n    :type head: ListNode\n    :type k: int\n    :rtype: ListNode\n    \"\"\"\n    if not head or not head.next:\n        return head\n    current = head\n    length = 1",
        "detail": "algorithms.algorithms.linkedlist.rotate_list",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.linkedlist.swap_in_pairs",
        "description": "algorithms.algorithms.linkedlist.swap_in_pairs",
        "peekOfCode": "class Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef swap_pairs(head):\n    if not head:\n        return head\n    start = Node(0)\n    start.next = head\n    current = start",
        "detail": "algorithms.algorithms.linkedlist.swap_in_pairs",
        "documentation": {}
    },
    {
        "label": "swap_pairs",
        "kind": 2,
        "importPath": "algorithms.algorithms.linkedlist.swap_in_pairs",
        "description": "algorithms.algorithms.linkedlist.swap_in_pairs",
        "peekOfCode": "def swap_pairs(head):\n    if not head:\n        return head\n    start = Node(0)\n    start.next = head\n    current = start\n    while current.next and current.next.next:\n        first = current.next\n        second = current.next.next\n        first.next = second.next",
        "detail": "algorithms.algorithms.linkedlist.swap_in_pairs",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "algorithms.algorithms.map.hashtable",
        "description": "algorithms.algorithms.map.hashtable",
        "peekOfCode": "class HashTable(object):\n    \"\"\"\n    HashMap Data Type\n    HashMap() Create a new, empty map. It returns an empty map collection.\n    put(key, val) Add a new key-value pair to the map. If the key is already in the map then replace\n                    the old value with the new value.\n    get(key) Given a key, return the value stored in the map or None otherwise.\n    del_(key) or del map[key] Delete the key-value pair from the map using a statement of the form del map[key].\n    len() Return the number of key-value pairs stored in the map.\n    in Return True for a statement of the form key in map, if the given key is in the map, False otherwise.",
        "detail": "algorithms.algorithms.map.hashtable",
        "documentation": {}
    },
    {
        "label": "ResizableHashTable",
        "kind": 6,
        "importPath": "algorithms.algorithms.map.hashtable",
        "description": "algorithms.algorithms.map.hashtable",
        "peekOfCode": "class ResizableHashTable(HashTable):\n    MIN_SIZE = 8\n    def __init__(self):\n        super().__init__(self.MIN_SIZE)\n    def put(self, key, value):\n        rv = super().put(key, value)\n        # increase size of dict * 2 if filled >= 2/3 size (like python dict)\n        if len(self) >= (self.size * 2) / 3:\n            self.__resize()\n    def __resize(self):",
        "detail": "algorithms.algorithms.map.hashtable",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": "algorithms.algorithms.map.is_anagram",
        "description": "algorithms.algorithms.map.is_anagram",
        "peekOfCode": "def is_anagram(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    maps = {}\n    mapt = {}\n    for i in s:\n        maps[i] = maps.get(i, 0) + 1",
        "detail": "algorithms.algorithms.map.is_anagram",
        "documentation": {}
    },
    {
        "label": "is_isomorphic",
        "kind": 2,
        "importPath": "algorithms.algorithms.map.is_isomorphic",
        "description": "algorithms.algorithms.map.is_isomorphic",
        "peekOfCode": "def is_isomorphic(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()",
        "detail": "algorithms.algorithms.map.is_isomorphic",
        "documentation": {}
    },
    {
        "label": "max_common_sub_string",
        "kind": 2,
        "importPath": "algorithms.algorithms.map.longest_common_subsequence",
        "description": "algorithms.algorithms.map.longest_common_subsequence",
        "peekOfCode": "def max_common_sub_string(s1, s2):\n    # Assuming s2 has all unique chars\n    s2dic = {s2[i]: i for i in range(len(s2))}\n    maxr = 0\n    subs = ''\n    i = 0\n    while i < len(s1):\n        if s1[i] in s2dic:\n            j = s2dic[s1[i]]\n            k = i",
        "detail": "algorithms.algorithms.map.longest_common_subsequence",
        "documentation": {}
    },
    {
        "label": "longest_palindromic_subsequence",
        "kind": 2,
        "importPath": "algorithms.algorithms.map.longest_palindromic_subsequence",
        "description": "algorithms.algorithms.map.longest_palindromic_subsequence",
        "peekOfCode": "def longest_palindromic_subsequence(s):\n    k = len(s)\n    olist = [0] * k    # n\n    nList = [0] * k    # \n    logestSubStr = \"\"\n    logestLen = 0\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:",
        "detail": "algorithms.algorithms.map.longest_palindromic_subsequence",
        "documentation": {}
    },
    {
        "label": "RandomizedSet",
        "kind": 6,
        "importPath": "algorithms.algorithms.map.randomized_set",
        "description": "algorithms.algorithms.map.randomized_set",
        "peekOfCode": "class RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.idxs = {}\n    def insert(self, val):\n        if val not in self.idxs:\n            self.nums.append(val)\n            self.idxs[val] = len(self.nums)-1\n            return True\n        return False",
        "detail": "algorithms.algorithms.map.randomized_set",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.map.separate_chaining_hashtable",
        "description": "algorithms.algorithms.map.separate_chaining_hashtable",
        "peekOfCode": "class Node(object):\n    def __init__(self, key=None, value=None, next=None):\n        self.key = key\n        self.value = value\n        self.next = next\nclass SeparateChainingHashTable(object):\n    \"\"\"\n    HashTable Data Type:\n    By having each bucket contain a linked list of elements that are hashed to that bucket.\n    Usage:",
        "detail": "algorithms.algorithms.map.separate_chaining_hashtable",
        "documentation": {}
    },
    {
        "label": "SeparateChainingHashTable",
        "kind": 6,
        "importPath": "algorithms.algorithms.map.separate_chaining_hashtable",
        "description": "algorithms.algorithms.map.separate_chaining_hashtable",
        "peekOfCode": "class SeparateChainingHashTable(object):\n    \"\"\"\n    HashTable Data Type:\n    By having each bucket contain a linked list of elements that are hashed to that bucket.\n    Usage:\n    >>> table = SeparateChainingHashTable() # Create a new, empty map.\n    >>> table.put('hello', 'world') # Add a new key-value pair.\n    >>> len(table) # Return the number of key-value pairs stored in the map.\n    1\n    >>> table.get('hello') # Get value by key.",
        "detail": "algorithms.algorithms.map.separate_chaining_hashtable",
        "documentation": {}
    },
    {
        "label": "is_valid_sudoku",
        "kind": 2,
        "importPath": "algorithms.algorithms.map.valid_sudoku",
        "description": "algorithms.algorithms.map.valid_sudoku",
        "peekOfCode": "def is_valid_sudoku(self, board):\n    seen = []\n    for i, row in enumerate(board):\n        for j, c in enumerate(row):\n            if c != '.':\n                seen += [(c,j),(i,c),(i/3,j/3,c)]\n    return len(seen) == len(set(seen))",
        "detail": "algorithms.algorithms.map.valid_sudoku",
        "documentation": {}
    },
    {
        "label": "word_pattern",
        "kind": 2,
        "importPath": "algorithms.algorithms.map.word_pattern",
        "description": "algorithms.algorithms.map.word_pattern",
        "peekOfCode": "def word_pattern(pattern, str):\n    dict = {}\n    set_value = set()\n    list_str = str.split()\n    if len(list_str) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in dict:\n            if list_str[i] in set_value:\n                return False",
        "detail": "algorithms.algorithms.map.word_pattern",
        "documentation": {}
    },
    {
        "label": "Input:pattern",
        "kind": 5,
        "importPath": "algorithms.algorithms.map.word_pattern",
        "description": "algorithms.algorithms.map.word_pattern",
        "peekOfCode": "Input:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\nExample 3:\nInput: pattern = \"aaaa\", str = \"dog cat cat dog\"\nOutput: false\nExample 4:\nInput: pattern = \"abba\", str = \"dog dog dog dog\"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.",
        "detail": "algorithms.algorithms.map.word_pattern",
        "documentation": {}
    },
    {
        "label": "int_to_base",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.base_conversion",
        "description": "algorithms.algorithms.maths.base_conversion",
        "peekOfCode": "def int_to_base(n, base):\n    \"\"\"\n        :type n: int\n        :type base: int\n        :rtype: str\n    \"\"\"\n    is_negative = False\n    if n == 0:\n        return '0'\n    elif n < 0:",
        "detail": "algorithms.algorithms.maths.base_conversion",
        "documentation": {}
    },
    {
        "label": "base_to_int",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.base_conversion",
        "description": "algorithms.algorithms.maths.base_conversion",
        "peekOfCode": "def base_to_int(s, base):\n    \"\"\"\n        Note : You can use int() built-in function instead of this.\n        :type s: str\n        :type base: int\n        :rtype: int\n    \"\"\"\n    digit = {}\n    for i,c in enumerate(string.digits + string.ascii_uppercase):\n        digit[c] = i",
        "detail": "algorithms.algorithms.maths.base_conversion",
        "documentation": {}
    },
    {
        "label": "solve_chinese_remainder",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.chinese_remainder_theorem",
        "description": "algorithms.algorithms.maths.chinese_remainder_theorem",
        "peekOfCode": "def solve_chinese_remainder(num : List[int], rem : List[int]):\n    \"\"\"\n    Computes the smallest x that satisfies the chinese remainder theorem\n    for a system of equations.\n    The system of equations has the form:\n    x % num[0] = rem[0]\n    x % num[1] = rem[1]\n    ...\n    x % num[k - 1] = rem[k - 1]\n    Where k is the number of elements in num and rem, k > 0.",
        "detail": "algorithms.algorithms.maths.chinese_remainder_theorem",
        "documentation": {}
    },
    {
        "label": "combination",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.combination",
        "description": "algorithms.algorithms.maths.combination",
        "peekOfCode": "def combination(n, r):\n    \"\"\"This function calculates nCr.\"\"\"\n    if n == r or r == 0:\n        return 1\n    else:\n        return combination(n-1, r-1) + combination(n-1, r)\ndef combination_memo(n, r):\n    \"\"\"This function calculates nCr using memoization method.\"\"\"\n    memo = {}\n    def recur(n, r):",
        "detail": "algorithms.algorithms.maths.combination",
        "documentation": {}
    },
    {
        "label": "combination_memo",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.combination",
        "description": "algorithms.algorithms.maths.combination",
        "peekOfCode": "def combination_memo(n, r):\n    \"\"\"This function calculates nCr using memoization method.\"\"\"\n    memo = {}\n    def recur(n, r):\n        if n == r or r == 0:\n            return 1\n        if (n, r) not in memo:\n            memo[(n, r)] = recur(n - 1, r - 1) + recur(n - 1, r)\n        return memo[(n, r)]\n    return recur(n, r)",
        "detail": "algorithms.algorithms.maths.combination",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.cosine_similarity",
        "description": "algorithms.algorithms.maths.cosine_similarity",
        "peekOfCode": "def cosine_similarity(a, b):\n    \"\"\"\n    Calculate cosine similarity between given two vectors\n    :type a: list\n    :type b: list\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"The two vectors must be the same length. Got shape \" + str(len(a)) + \" and \" + str(len(b)))\n    norm_a = _l2_distance(a)\n    norm_b = _l2_distance(b)",
        "detail": "algorithms.algorithms.maths.cosine_similarity",
        "documentation": {}
    },
    {
        "label": "decimal_to_binary_util",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.decimal_to_binary_ip",
        "description": "algorithms.algorithms.maths.decimal_to_binary_ip",
        "peekOfCode": "def decimal_to_binary_util(val):\n    bits = [128, 64, 32, 16, 8, 4, 2, 1]\n    val = int(val)\n    binary_rep = ''\n    for bit in bits:\n        if val >= bit:\n            binary_rep += str(1)\n            val -= bit\n        else:\n            binary_rep += str(0)",
        "detail": "algorithms.algorithms.maths.decimal_to_binary_ip",
        "documentation": {}
    },
    {
        "label": "decimal_to_binary_ip",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.decimal_to_binary_ip",
        "description": "algorithms.algorithms.maths.decimal_to_binary_ip",
        "peekOfCode": "def decimal_to_binary_ip(ip):\n    values = ip.split('.')\n    binary_list = []\n    for val in values:\n        binary_list.append(decimal_to_binary_util(val))\n    return '.'.join(binary_list)",
        "detail": "algorithms.algorithms.maths.decimal_to_binary_ip",
        "documentation": {}
    },
    {
        "label": "prime_check",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def prime_check(n):\n    \"\"\"Return True if n is a prime number\n    Else return False.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "find_order",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def find_order(a, n):\n    if ((a == 1) & (n == 1)):\n        return 1\n        \"\"\" Exception Handeling :\n        1 is the order of of 1 \"\"\"\n    else:\n        if (math.gcd(a, n) != 1):\n            print (\"a and n should be relative prime!\")\n            return -1\n        else:",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "euler_totient",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n;\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "find_primitive_root",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def find_primitive_root(n):\n    if (n == 1):\n        return [0]\n        \"\"\" Exception Handeling :\n        0 is the only primitive root of 1 \"\"\"\n    else:\n        phi = euler_totient(n)\n        p_root_list = []\n        \"\"\" It will return every primitive roots of n. \"\"\"\n        for i in range (1, n):",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "alice_private_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def alice_private_key(p):\n    \"\"\"Alice determine her private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p-1)\ndef alice_public_key(a_pr_k, a, p):\n    \"\"\"Alice calculate her public key\n    with her private key.\n    This is open to public\"\"\"\n    return pow(a, a_pr_k) % p",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "alice_public_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def alice_public_key(a_pr_k, a, p):\n    \"\"\"Alice calculate her public key\n    with her private key.\n    This is open to public\"\"\"\n    return pow(a, a_pr_k) % p\ndef bob_private_key(p):\n    \"\"\"Bob determine his private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p-1)",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "bob_private_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def bob_private_key(p):\n    \"\"\"Bob determine his private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p-1)\ndef bob_public_key(b_pr_k, a, p):\n    \"\"\"Bob calculate his public key\n    with his private key.\n    This is open to public\"\"\"\n    return pow(a, b_pr_k) % p",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "bob_public_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def bob_public_key(b_pr_k, a, p):\n    \"\"\"Bob calculate his public key\n    with his private key.\n    This is open to public\"\"\"\n    return pow(a, b_pr_k) % p\ndef alice_shared_key(b_pu_k, a_pr_k, p):\n    \"\"\" Alice calculate secret key shared with Bob,\n    with her private key and Bob's public key.\n    This must be kept in secret\"\"\"\n    return pow(b_pu_k, a_pr_k) % p",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "alice_shared_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def alice_shared_key(b_pu_k, a_pr_k, p):\n    \"\"\" Alice calculate secret key shared with Bob,\n    with her private key and Bob's public key.\n    This must be kept in secret\"\"\"\n    return pow(b_pu_k, a_pr_k) % p\ndef bob_shared_key(a_pu_k, b_pr_k, p):\n    \"\"\" Bob calculate secret key shared with Alice,\n    with his private key and Alice's public key.\n    This must be kept in secret\"\"\"\n    return pow(a_pu_k, b_pr_k) % p",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "bob_shared_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def bob_shared_key(a_pu_k, b_pr_k, p):\n    \"\"\" Bob calculate secret key shared with Alice,\n    with his private key and Alice's public key.\n    This must be kept in secret\"\"\"\n    return pow(a_pu_k, b_pr_k) % p\ndef diffie_hellman_key_exchange(a, p, option = None):\n    if (option != None):\n        option = 1\n        \"\"\" Print explanation of process\n        when option parameter is given \"\"\"",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "diffie_hellman_key_exchange",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "description": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "peekOfCode": "def diffie_hellman_key_exchange(a, p, option = None):\n    if (option != None):\n        option = 1\n        \"\"\" Print explanation of process\n        when option parameter is given \"\"\"\n    if (prime_check(p) == False):\n        print(\"%d is not a prime number\" % p)\n        return False\n        \"\"\"p must be large prime number\"\"\"\n    else:",
        "detail": "algorithms.algorithms.maths.diffie_hellman_key_exchange",
        "documentation": {}
    },
    {
        "label": "euler_totient",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.euler_totient",
        "description": "algorithms.algorithms.maths.euler_totient",
        "peekOfCode": "def euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n;\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:",
        "detail": "algorithms.algorithms.maths.euler_totient",
        "documentation": {}
    },
    {
        "label": "extended_gcd",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.extended_gcd",
        "description": "algorithms.algorithms.maths.extended_gcd",
        "peekOfCode": "def extended_gcd(a, b):\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that a * s + b * t = GCD(a, b)\n    and s and t are co-prime.\n    \"\"\"\n    old_s, s = 1, 0\n    old_t, t = 0, 1\n    old_r, r = a, b\n    while r != 0:",
        "detail": "algorithms.algorithms.maths.extended_gcd",
        "documentation": {}
    },
    {
        "label": "factorial",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.factorial",
        "description": "algorithms.algorithms.maths.factorial",
        "peekOfCode": "def factorial(n, mod=None):\n    \"\"\"Calculates factorial iteratively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and not (isinstance(mod, int) and mod > 0):\n        raise ValueError(\"'mod' must be a positive integer\")\n    result = 1\n    if n == 0:",
        "detail": "algorithms.algorithms.maths.factorial",
        "documentation": {}
    },
    {
        "label": "factorial_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.factorial",
        "description": "algorithms.algorithms.maths.factorial",
        "peekOfCode": "def factorial_recur(n, mod=None):\n    \"\"\"Calculates factorial recursively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and not (isinstance(mod, int) and mod > 0):\n        raise ValueError(\"'mod' must be a positive integer\")\n    if n == 0:\n        return 1",
        "detail": "algorithms.algorithms.maths.factorial",
        "documentation": {}
    },
    {
        "label": "find_order",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.find_order_simple",
        "description": "algorithms.algorithms.maths.find_order_simple",
        "peekOfCode": "def find_order(a, n):\n    if ((a == 1) & (n == 1)):\n        return 1\n        \"\"\" Exception Handeling :\n        1 is the order of of 1 \"\"\"\n    else:\n        if (math.gcd(a, n) != 1):\n            print (\"a and n should be relative prime!\")\n            return -1\n        else:",
        "detail": "algorithms.algorithms.maths.find_order_simple",
        "documentation": {}
    },
    {
        "label": "find_order",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.find_primitive_root_simple",
        "description": "algorithms.algorithms.maths.find_primitive_root_simple",
        "peekOfCode": "def find_order(a, n):\n    if ((a == 1) & (n == 1)):\n        return 1\n        \"\"\" Exception Handeling :\n        1 is the order of of 1 \"\"\"\n    else:\n        if (math.gcd(a, n) != 1):\n            print (\"a and n should be relative prime!\")\n            return -1\n        else:",
        "detail": "algorithms.algorithms.maths.find_primitive_root_simple",
        "documentation": {}
    },
    {
        "label": "euler_totient",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.find_primitive_root_simple",
        "description": "algorithms.algorithms.maths.find_primitive_root_simple",
        "peekOfCode": "def euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n;\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:",
        "detail": "algorithms.algorithms.maths.find_primitive_root_simple",
        "documentation": {}
    },
    {
        "label": "find_primitive_root",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.find_primitive_root_simple",
        "description": "algorithms.algorithms.maths.find_primitive_root_simple",
        "peekOfCode": "def find_primitive_root(n):\n    if (n == 1):\n        return [0]\n        \"\"\" Exception Handeling :\n        0 is the only primitive root of 1 \"\"\"\n    else:\n        phi = euler_totient(n)\n        p_root_list = []\n        \"\"\" It will return every primitive roots of n. \"\"\"\n        for i in range (1, n):",
        "detail": "algorithms.algorithms.maths.find_primitive_root_simple",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.gcd",
        "description": "algorithms.algorithms.maths.gcd",
        "peekOfCode": "def gcd(a, b):\n    \"\"\"Computes the greatest common divisor of integers a and b using\n    Euclid's Algorithm.\n    gcd{,}=gcd{,}=gcd{,}=gcd{,}\n    See proof: https://proofwiki.org/wiki/GCD_for_Negative_Integers\n    \"\"\"\n    a_int = isinstance(a, int)\n    b_int = isinstance(b, int)\n    a = abs(a)\n    b = abs(b)",
        "detail": "algorithms.algorithms.maths.gcd",
        "documentation": {}
    },
    {
        "label": "lcm",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.gcd",
        "description": "algorithms.algorithms.maths.gcd",
        "peekOfCode": "def lcm(a, b):\n    \"\"\"Computes the lowest common multiple of integers a and b.\"\"\"\n    return abs(a) * abs(b) / gcd(a, b)\n\"\"\"\nGiven a positive integer x, computes the number of trailing zero of x.\nExample\nInput : 34(100010)\n           ~~~~~^\nOutput : 1\nInput : 40(101000)",
        "detail": "algorithms.algorithms.maths.gcd",
        "documentation": {}
    },
    {
        "label": "trailing_zero",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.gcd",
        "description": "algorithms.algorithms.maths.gcd",
        "peekOfCode": "def trailing_zero(x):\n    cnt = 0\n    while x and not x & 1:\n        cnt += 1\n        x >>= 1\n    return cnt\n\"\"\"\nGiven two non-negative integer a and b,\ncomputes the greatest common divisor of a and b using bitwise operator.\n\"\"\"",
        "detail": "algorithms.algorithms.maths.gcd",
        "documentation": {}
    },
    {
        "label": "gcd_bit",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.gcd",
        "description": "algorithms.algorithms.maths.gcd",
        "peekOfCode": "def gcd_bit(a, b):\n    tza = trailing_zero(a)\n    tzb = trailing_zero(b)\n    a >>= tza\n    b >>= tzb\n    while b:\n        if a < b:\n            a, b = b, a\n        a -= b\n        a >>= trailing_zero(a)",
        "detail": "algorithms.algorithms.maths.gcd",
        "documentation": {}
    },
    {
        "label": "gen_strobogrammatic",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.generate_strobogrammtic",
        "description": "algorithms.algorithms.maths.generate_strobogrammtic",
        "peekOfCode": "def gen_strobogrammatic(n):\n    \"\"\"\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n    return helper(n, n)\ndef helper(n, length):\n    if n == 0:\n        return [\"\"]\n    if n == 1:",
        "detail": "algorithms.algorithms.maths.generate_strobogrammtic",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.generate_strobogrammtic",
        "description": "algorithms.algorithms.maths.generate_strobogrammtic",
        "peekOfCode": "def helper(n, length):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"1\", \"0\", \"8\"]\n    middles = helper(n-2, length)\n    result = []\n    for middle in middles:\n        if n != length:\n            result.append(\"0\" + middle + \"0\")",
        "detail": "algorithms.algorithms.maths.generate_strobogrammtic",
        "documentation": {}
    },
    {
        "label": "strobogrammatic_in_range",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.generate_strobogrammtic",
        "description": "algorithms.algorithms.maths.generate_strobogrammtic",
        "peekOfCode": "def strobogrammatic_in_range(low, high):\n    \"\"\"\n    :type low: str\n    :type high: str\n    :rtype: int\n    \"\"\"\n    res = []\n    count = 0\n    low_len = len(low)\n    high_len = len(high)",
        "detail": "algorithms.algorithms.maths.generate_strobogrammtic",
        "documentation": {}
    },
    {
        "label": "helper2",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.generate_strobogrammtic",
        "description": "algorithms.algorithms.maths.generate_strobogrammtic",
        "peekOfCode": "def helper2(n, length):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"0\", \"8\", \"1\"]\n    mids = helper(n-2, length)\n    res = []\n    for mid in mids:\n        if n != length:\n            res.append(\"0\"+mid+\"0\")",
        "detail": "algorithms.algorithms.maths.generate_strobogrammtic",
        "documentation": {}
    },
    {
        "label": "hailstone",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.hailstone",
        "description": "algorithms.algorithms.maths.hailstone",
        "peekOfCode": "def hailstone(n):\n  \"\"\"Return the 'hailstone sequence' from n to 1\n     n: The starting point of the hailstone sequence\n  \"\"\"\n  sequence = [n]\n  while n > 1:\n    if n%2 != 0:\n      n = 3*n + 1\n    else: \n      n = int(n/2)",
        "detail": "algorithms.algorithms.maths.hailstone",
        "documentation": {}
    },
    {
        "label": "is_strobogrammatic",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.is_strobogrammatic",
        "description": "algorithms.algorithms.maths.is_strobogrammatic",
        "peekOfCode": "def is_strobogrammatic(num):\n    \"\"\"\n    :type num: str\n    :rtype: bool\n    \"\"\"\n    comb = \"00 11 88 69 96\"\n    i = 0\n    j = len(num) - 1\n    while i <= j:\n        x = comb.find(num[i]+num[j])",
        "detail": "algorithms.algorithms.maths.is_strobogrammatic",
        "documentation": {}
    },
    {
        "label": "is_strobogrammatic2",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.is_strobogrammatic",
        "description": "algorithms.algorithms.maths.is_strobogrammatic",
        "peekOfCode": "def is_strobogrammatic2(num: str):\n    \"\"\"Another implementation.\"\"\"\n    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')",
        "detail": "algorithms.algorithms.maths.is_strobogrammatic",
        "documentation": {}
    },
    {
        "label": "find_factorial",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.krishnamurthy_number",
        "description": "algorithms.algorithms.maths.krishnamurthy_number",
        "peekOfCode": "def find_factorial(n):\n    fact = 1\n    while n != 0:\n        fact *= n\n        n -= 1\n    return fact\ndef krishnamurthy_number(n):\n    if n == 0:\n        return False\n    sum_of_digits = 0   # will hold sum of FACTORIAL of digits",
        "detail": "algorithms.algorithms.maths.krishnamurthy_number",
        "documentation": {}
    },
    {
        "label": "krishnamurthy_number",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.krishnamurthy_number",
        "description": "algorithms.algorithms.maths.krishnamurthy_number",
        "peekOfCode": "def krishnamurthy_number(n):\n    if n == 0:\n        return False\n    sum_of_digits = 0   # will hold sum of FACTORIAL of digits\n    temp = n\n    while temp != 0:\n        # get the factorial of of the last digit of n and add it to sum_of_digits\n        sum_of_digits += find_factorial(temp % 10)\n        # replace value of temp by temp/10\n        # i.e. will remove the last digit from temp",
        "detail": "algorithms.algorithms.maths.krishnamurthy_number",
        "documentation": {}
    },
    {
        "label": "magic_number",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.magic_number",
        "description": "algorithms.algorithms.maths.magic_number",
        "peekOfCode": "def magic_number(n):\n    total_sum = 0\n    # will end when n becomes 0\n    # AND\n    # sum becomes single digit.\n    while n > 0 or total_sum > 9:\n        # when n becomes 0 but we have a total_sum,\n        # we update the value of n with the value of the sum digits\n        if n == 0:\n            n = total_sum  # only when sum of digits isn't single digit",
        "detail": "algorithms.algorithms.maths.magic_number",
        "documentation": {}
    },
    {
        "label": "modular_exponential",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.modular_exponential",
        "description": "algorithms.algorithms.maths.modular_exponential",
        "peekOfCode": "def modular_exponential(base, exponent, mod):\n    \"\"\"Computes (base ^ exponent) % mod.\n    Time complexity - O(log n)\n    Use similar to Python in-built function pow.\"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be positive.\")\n    base %= mod\n    result = 1\n    while exponent > 0:\n        # If the last bit is 1, add 2^k.",
        "detail": "algorithms.algorithms.maths.modular_exponential",
        "documentation": {}
    },
    {
        "label": "extended_gcd",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.modular_inverse",
        "description": "algorithms.algorithms.maths.modular_inverse",
        "peekOfCode": "def extended_gcd(a: int, b: int) -> [int, int, int]:\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that a * s + b * t = GCD(a, b)\n    and s and t are co-prime.\n    \"\"\"\n    old_s, s = 1, 0\n    old_t, t = 0, 1\n    old_r, r = a, b\n    while r != 0:",
        "detail": "algorithms.algorithms.maths.modular_inverse",
        "documentation": {}
    },
    {
        "label": "modular_inverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.modular_inverse",
        "description": "algorithms.algorithms.maths.modular_inverse",
        "peekOfCode": "def modular_inverse(a: int, m: int) -> int:\n    \"\"\"\n    Returns x such that a * x = 1 (mod m)\n    a and m must be coprime \n    \"\"\"\n    s, t, g = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError(\"a and m must be coprime\")\n    return s % m",
        "detail": "algorithms.algorithms.maths.modular_inverse",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.maths.next_bigger",
        "description": "algorithms.algorithms.maths.next_bigger",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_next_bigger(self):\n        self.assertEqual(next_bigger(38276), 38627)\n        self.assertEqual(next_bigger(12345), 12354)\n        self.assertEqual(next_bigger(1528452), 1528524)\n        self.assertEqual(next_bigger(138654), 143568)\n        self.assertEqual(next_bigger(54321), -1)\n        self.assertEqual(next_bigger(999), -1)\n        self.assertEqual(next_bigger(5), -1)\nif __name__ == '__main__':",
        "detail": "algorithms.algorithms.maths.next_bigger",
        "documentation": {}
    },
    {
        "label": "next_bigger",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.next_bigger",
        "description": "algorithms.algorithms.maths.next_bigger",
        "peekOfCode": "def next_bigger(num):\n    digits = [int(i) for i in str(num)]\n    idx = len(digits) - 1\n    while idx >= 1 and digits[idx-1] >= digits[idx]:\n        idx -= 1\n    if idx == 0:\n        return -1  # no such number exists\n    pivot = digits[idx-1]\n    swap_idx = len(digits) - 1\n    while pivot >= digits[swap_idx]:",
        "detail": "algorithms.algorithms.maths.next_bigger",
        "documentation": {}
    },
    {
        "label": "find_next_square",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.next_perfect_square",
        "description": "algorithms.algorithms.maths.next_perfect_square",
        "peekOfCode": "def find_next_square(sq):\n    root = sq ** 0.5\n    if root.is_integer():\n        return (root + 1)**2\n    return -1\n# Another way:\ndef find_next_square2(sq):\n    x = sq**0.5    \n    return -1 if x % 1 else (x+1)**2",
        "detail": "algorithms.algorithms.maths.next_perfect_square",
        "documentation": {}
    },
    {
        "label": "find_next_square2",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.next_perfect_square",
        "description": "algorithms.algorithms.maths.next_perfect_square",
        "peekOfCode": "def find_next_square2(sq):\n    x = sq**0.5    \n    return -1 if x % 1 else (x+1)**2",
        "detail": "algorithms.algorithms.maths.next_perfect_square",
        "documentation": {}
    },
    {
        "label": "find_nth_digit",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.nth_digit",
        "description": "algorithms.algorithms.maths.nth_digit",
        "peekOfCode": "def find_nth_digit(n):\n    \"\"\"find the nth digit of given number.\n    1. find the length of the number where the nth digit is from.\n    2. find the actual number where the nth digit is from\n    3. find the nth digit and return\n    \"\"\"\n    length = 1\n    count = 9\n    start = 1\n    while n > length * count:",
        "detail": "algorithms.algorithms.maths.nth_digit",
        "documentation": {}
    },
    {
        "label": "num_digits",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.num_digits",
        "description": "algorithms.algorithms.maths.num_digits",
        "peekOfCode": "def num_digits(n):\n  n=abs(n)\n  if(n==0):\n      return 1;\n  return int(math.log10(n))+1",
        "detail": "algorithms.algorithms.maths.num_digits",
        "documentation": {}
    },
    {
        "label": "Monomial",
        "kind": 6,
        "importPath": "algorithms.algorithms.maths.polynomial",
        "description": "algorithms.algorithms.maths.polynomial",
        "peekOfCode": "class Monomial:\n    \"\"\"\n    A simple Monomial class to\n    record the details of all variables\n    that a typical monomial is composed of.\n    \"\"\"\n    def __init__(self, variables: Dict[int, int], coeff: Union[int, float, Fraction, None]=None) -> None:\n        '''\n        Create a monomial in the given variables:\n        Examples:",
        "detail": "algorithms.algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "kind": 6,
        "importPath": "algorithms.algorithms.maths.polynomial",
        "description": "algorithms.algorithms.maths.polynomial",
        "peekOfCode": "class Polynomial:\n    \"\"\"\n    A simple implementation\n    of a polynomial class that\n    records the details about two polynomials\n    that are potentially comprised of multiple\n    variables.\n    \"\"\"\n    def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None:\n        '''",
        "detail": "algorithms.algorithms.maths.polynomial",
        "documentation": {}
    },
    {
        "label": "power",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.power",
        "description": "algorithms.algorithms.maths.power",
        "peekOfCode": "def power(a: int, n: int, r: int = None):\n    \"\"\"\n    Iterative version of binary exponentiation\n    Calculate a ^ n\n    if r is specified, return the result modulo r\n    Time Complexity :  O(log(n))\n    Space Complexity : O(1)\n    \"\"\"\n    ans = 1\n    while n:",
        "detail": "algorithms.algorithms.maths.power",
        "documentation": {}
    },
    {
        "label": "power_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.power",
        "description": "algorithms.algorithms.maths.power",
        "peekOfCode": "def power_recur(a: int, n: int, r: int = None):\n    \"\"\"\n    Recursive version of binary exponentiation\n    Calculate a ^ n\n    if r is specified, return the result modulo r\n    Time Complexity :  O(log(n))\n    Space Complexity : O(log(n))\n    \"\"\"\n    if n == 0:\n        ans = 1",
        "detail": "algorithms.algorithms.maths.power",
        "documentation": {}
    },
    {
        "label": "get_primes",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.primes_sieve_of_eratosthenes",
        "description": "algorithms.algorithms.maths.primes_sieve_of_eratosthenes",
        "peekOfCode": "def get_primes(n):\n    \"\"\"Return list of all primes less than n,\n    Using sieve of Eratosthenes.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    # If x is even, exclude x from list (-1):\n    sieve_size = (n // 2 - 1) if n % 2 == 0 else (n // 2)\n    sieve = [True for _ in range(sieve_size)]   # Sieve\n    primes = []      # List of Primes",
        "detail": "algorithms.algorithms.maths.primes_sieve_of_eratosthenes",
        "documentation": {}
    },
    {
        "label": "prime_check",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.prime_check",
        "description": "algorithms.algorithms.maths.prime_check",
        "peekOfCode": "def prime_check(n):\n    \"\"\"Return True if n is a prime number\n    Else return False.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False",
        "detail": "algorithms.algorithms.maths.prime_check",
        "documentation": {}
    },
    {
        "label": "pythagoras",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.pythagoras",
        "description": "algorithms.algorithms.maths.pythagoras",
        "peekOfCode": "def pythagoras(opposite,adjacent,hypotenuse):\n    try:\n        if opposite == str(\"?\"):\n            return (\"Opposite = \" + str(((hypotenuse**2) - (adjacent**2))**0.5))\n        elif adjacent == str(\"?\"):\n            return (\"Adjacent = \" + str(((hypotenuse**2) - (opposite**2))**0.5))\n        elif hypotenuse == str(\"?\"):\n            return (\"Hypotenuse = \" + str(((opposite**2) + (adjacent**2))**0.5))\n        else:\n            return \"You already know the answer!\"",
        "detail": "algorithms.algorithms.maths.pythagoras",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.rabin_miller",
        "description": "algorithms.algorithms.maths.rabin_miller",
        "peekOfCode": "def is_prime(n, k):\n    def pow2_factor(num):\n        \"\"\"factor n into a power of 2 times an odd number\"\"\"\n        power = 0\n        while num % 2 == 0:\n            num /= 2\n            power += 1\n        return power, num\n    def valid_witness(a):\n        \"\"\"",
        "detail": "algorithms.algorithms.maths.rabin_miller",
        "documentation": {}
    },
    {
        "label": "recursive_binomial_coefficient",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.recursive_binomial_coefficient",
        "description": "algorithms.algorithms.maths.recursive_binomial_coefficient",
        "peekOfCode": "def recursive_binomial_coefficient(n,k):\n    \"\"\"Calculates the binomial coefficient, C(n,k), with n>=k using recursion\n    Time complexity is O(k), so can calculate fairly quickly for large values of k.\n    >>> recursive_binomial_coefficient(5,0)\n    1\n    >>> recursive_binomial_coefficient(8,2)\n    28\n    >>> recursive_binomial_coefficient(500,300)\n    5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640\n    \"\"\"",
        "detail": "algorithms.algorithms.maths.recursive_binomial_coefficient",
        "documentation": {}
    },
    {
        "label": "generate_key",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.rsa",
        "description": "algorithms.algorithms.maths.rsa",
        "peekOfCode": "def generate_key(k, seed=None):\n    \"\"\"\n    the RSA key generating algorithm\n    k is the number of bits in n\n    \"\"\"\n    def modinv(a, m):\n        \"\"\"calculate the inverse of a mod m\n        that is, find b such that (a * b) % m == 1\"\"\"\n        b = 1\n        while not (a * b) % m == 1:",
        "detail": "algorithms.algorithms.maths.rsa",
        "documentation": {}
    },
    {
        "label": "encrypt",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.rsa",
        "description": "algorithms.algorithms.maths.rsa",
        "peekOfCode": "def encrypt(data, e, n):\n    return pow(int(data), int(e), int(n))\ndef decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))\n# sample usage:\n# n,e,d = generate_key(16)\n# data = 20\n# encrypted = pow(data,e,n)\n# decrypted = pow(encrypted,d,n)\n# assert decrypted == data",
        "detail": "algorithms.algorithms.maths.rsa",
        "documentation": {}
    },
    {
        "label": "decrypt",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.rsa",
        "description": "algorithms.algorithms.maths.rsa",
        "peekOfCode": "def decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))\n# sample usage:\n# n,e,d = generate_key(16)\n# data = 20\n# encrypted = pow(data,e,n)\n# decrypted = pow(encrypted,d,n)\n# assert decrypted == data",
        "detail": "algorithms.algorithms.maths.rsa",
        "documentation": {}
    },
    {
        "label": "square_root",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.sqrt_precision_factor",
        "description": "algorithms.algorithms.maths.sqrt_precision_factor",
        "peekOfCode": "def square_root(n, epsilon=0.001):\n    \"\"\"Return square root of n, with maximum absolute error epsilon\"\"\"\n    guess = n / 2\n    while abs(guess * guess - n) > epsilon:\n        guess = (guess + (n / guess)) / 2\n    return guess",
        "detail": "algorithms.algorithms.maths.sqrt_precision_factor",
        "documentation": {}
    },
    {
        "label": "sum_dig_pow",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.summing_digits",
        "description": "algorithms.algorithms.maths.summing_digits",
        "peekOfCode": "def sum_dig_pow(a, b):  \n    result = []\n    for number in range(a, b + 1):\n        exponent = 1  # set to 1\n        summation = 0    # set to 1\n        number_as_string = str(number)\n        tokens = list(map(int, number_as_string))  # parse the string into individual digits\n        for k in tokens:\n            summation = summation + (k ** exponent)\n            exponent += 1",
        "detail": "algorithms.algorithms.maths.summing_digits",
        "documentation": {}
    },
    {
        "label": "cycle_product",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "description": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "peekOfCode": "def cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    \"\"\"\n    Given two monomials (from the\n    cycle index of a symmetry group),\n    compute the resultant monomial\n    in the cartesian product\n    corresponding to their merging.\n    \"\"\"\n    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)\n    A = m1.variables",
        "detail": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "documentation": {}
    },
    {
        "label": "cycle_product_for_two_polynomials",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "description": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "peekOfCode": "def cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:\n    \"\"\"\n    Compute the product of\n    given cycle indices p1,\n    and p2 and evaluate it at q.\n    \"\"\"\n    ans = Fraction(0, 1)\n    for m1 in p1.monomials:\n        for m2 in p2.monomials:\n            ans += cycle_product(m1, m2).substitute(q)",
        "detail": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "documentation": {}
    },
    {
        "label": "cycle_index_sym_helper",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "description": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "peekOfCode": "def cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:\n    \"\"\"\n    A helper for the dp-style evaluation\n    of the cycle index.\n    The recurrence is given in:\n    https://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    ans = Polynomial([Monomial({}, Fraction(0, 1))])",
        "detail": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "documentation": {}
    },
    {
        "label": "get_cycle_index_sym",
        "kind": 2,
        "importPath": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "description": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "peekOfCode": "def get_cycle_index_sym(n: int) -> Polynomial:\n    \"\"\"\n    Compute the cycle index\n    of S_n, i.e. the symmetry\n    group of n symbols.\n    \"\"\"\n    if n < 0:\n    \traise ValueError('n should be a non-negative integer.')\n    memo = {\n        0: Polynomial([",
        "detail": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "documentation": {}
    },
    {
        "label": "\t\ts1",
        "kind": 5,
        "importPath": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "description": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "peekOfCode": "\t\ts1 = get_cycle_index_sym(w)\n\t    s2 = get_cycle_index_sym(h)\n\t    result = cycle_product_for_two_polynomials(s1, s2, s)\n\t    return str(result)\n\"\"\"\ndef cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    \"\"\"\n    Given two monomials (from the\n    cycle index of a symmetry group),\n    compute the resultant monomial",
        "detail": "algorithms.algorithms.maths.symmetry_group_cycle_index",
        "documentation": {}
    },
    {
        "label": "TestBombEnemy",
        "kind": 6,
        "importPath": "algorithms.algorithms.matrix.bomb_enemy",
        "description": "algorithms.algorithms.matrix.bomb_enemy",
        "peekOfCode": "class TestBombEnemy(unittest.TestCase):\n    def test_3x4(self):\n        grid1 = [[\"0\",\"E\",\"0\",\"0\"],\n                [\"E\",\"0\",\"W\",\"E\"],\n                [\"0\",\"E\",\"0\",\"0\"]]\n        self.assertEqual(3,max_killed_enemies(grid1))\n    def test_4x4(self):\n        grid1 = [\n                [\"0\", \"E\", \"0\", \"E\"],\n                [\"E\", \"E\", \"E\", \"0\"],",
        "detail": "algorithms.algorithms.matrix.bomb_enemy",
        "documentation": {}
    },
    {
        "label": "max_killed_enemies",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.bomb_enemy",
        "description": "algorithms.algorithms.matrix.bomb_enemy",
        "peekOfCode": "def max_killed_enemies(grid):\n    if not grid: return 0\n    m, n = len(grid), len(grid[0])\n    max_killed = 0\n    row_e, col_e = 0, [0] * n\n    # iterates over all cells in the grid\n    for i in range(m):\n        for j in range(n):\n            # makes sure we are next to a wall.\n            if j == 0 or grid[i][j-1] == 'W':",
        "detail": "algorithms.algorithms.matrix.bomb_enemy",
        "documentation": {}
    },
    {
        "label": "row_kills",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.bomb_enemy",
        "description": "algorithms.algorithms.matrix.bomb_enemy",
        "peekOfCode": "def row_kills(grid, i, j):\n    num = 0\n    len_row = len(grid[0])\n    while j < len_row and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        j += 1\n    return num\n# calculate killed enemies for  column j from row i\ndef col_kills(grid, i, j):",
        "detail": "algorithms.algorithms.matrix.bomb_enemy",
        "documentation": {}
    },
    {
        "label": "col_kills",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.bomb_enemy",
        "description": "algorithms.algorithms.matrix.bomb_enemy",
        "peekOfCode": "def col_kills(grid, i, j):\n    num = 0\n    len_col = len(grid)\n    while i < len_col and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        i += 1\n    return num\n# ----------------- TESTS -------------------------\n\"\"\"",
        "detail": "algorithms.algorithms.matrix.bomb_enemy",
        "documentation": {}
    },
    {
        "label": "cholesky_decomposition",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.cholesky_matrix_decomposition",
        "description": "algorithms.algorithms.matrix.cholesky_matrix_decomposition",
        "peekOfCode": "def cholesky_decomposition(A):\n    \"\"\"\n    :param A: Hermitian positive-definite matrix of type List[List[float]]\n    :return: matrix of type List[List[float]] if A can be decomposed, otherwise None\n    \"\"\"\n    n = len(A)\n    for ai in A:\n        if len(ai) != n:\n            return None\n    V = [[0.0] * n for _ in range(n)]",
        "detail": "algorithms.algorithms.matrix.cholesky_matrix_decomposition",
        "documentation": {}
    },
    {
        "label": "rotate_clockwise",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.copy_transform",
        "description": "algorithms.algorithms.matrix.copy_transform",
        "peekOfCode": "def rotate_clockwise(matrix):\n    new = []\n    for row in reversed(matrix):\n        for i, elem in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
        "detail": "algorithms.algorithms.matrix.copy_transform",
        "documentation": {}
    },
    {
        "label": "rotate_counterclockwise",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.copy_transform",
        "description": "algorithms.algorithms.matrix.copy_transform",
        "peekOfCode": "def rotate_counterclockwise(matrix):\n    new = []\n    for row in matrix:\n        for i, elem in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
        "detail": "algorithms.algorithms.matrix.copy_transform",
        "documentation": {}
    },
    {
        "label": "top_left_invert",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.copy_transform",
        "description": "algorithms.algorithms.matrix.copy_transform",
        "peekOfCode": "def top_left_invert(matrix):\n    new = []\n    for row in matrix:\n        for i, elem in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
        "detail": "algorithms.algorithms.matrix.copy_transform",
        "documentation": {}
    },
    {
        "label": "bottom_left_invert",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.copy_transform",
        "description": "algorithms.algorithms.matrix.copy_transform",
        "peekOfCode": "def bottom_left_invert(matrix):\n    new = []\n    for row in reversed(matrix):\n        for i, elem in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
        "detail": "algorithms.algorithms.matrix.copy_transform",
        "documentation": {}
    },
    {
        "label": "count_paths",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.count_paths",
        "description": "algorithms.algorithms.matrix.count_paths",
        "peekOfCode": "def count_paths(m, n):\n    if m < 1 or n < 1:\n        return -1\n    count = [[None for j in range(n)] for i in range(m)]\n    # Taking care of the edge cases- matrix of size 1xn or mx1\n    for i in range(n):\n        count[0][i] = 1\n    for j in range(m):\n        count[j][0] = 1\n    for i in range(1, m):",
        "detail": "algorithms.algorithms.matrix.count_paths",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.count_paths",
        "description": "algorithms.algorithms.matrix.count_paths",
        "peekOfCode": "def main():\n    m, n = map(int, input('Enter two positive integers: ').split())\n    count_paths(m, n)\nif __name__ == '__main__':\n    main()",
        "detail": "algorithms.algorithms.matrix.count_paths",
        "documentation": {}
    },
    {
        "label": "crout_matrix_decomposition",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "description": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "peekOfCode": "def crout_matrix_decomposition(A):\n    n = len(A)\n    L = [[0.0] * n for i in range(n)]\n    U = [[0.0] * n for i in range(n)]\n    for j in range(n):\n        U[j][j] = 1.0\n        for i in range(j, n):\n            alpha = float(A[i][j])\n            for k in range(j):\n                alpha -= L[i][k]*U[k][j]",
        "detail": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "description": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "peekOfCode": "L = [1.0,  0.0, 0.0]\n    [3.0, -2.0, 0.0]\n    [6.0, -5.0, 0.0]\nU = [1.0,  2.0, 3.0]\n    [0.0,  1.0, 2.0]\n    [0.0,  0.0, 1.0]\nWe can check that L * U = A.\nI think the complexity should be O(n^3).\n\"\"\"\ndef crout_matrix_decomposition(A):",
        "detail": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "documentation": {}
    },
    {
        "label": "U",
        "kind": 5,
        "importPath": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "description": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "peekOfCode": "U = [1.0,  2.0, 3.0]\n    [0.0,  1.0, 2.0]\n    [0.0,  0.0, 1.0]\nWe can check that L * U = A.\nI think the complexity should be O(n^3).\n\"\"\"\ndef crout_matrix_decomposition(A):\n    n = len(A)\n    L = [[0.0] * n for i in range(n)]\n    U = [[0.0] * n for i in range(n)]",
        "detail": "algorithms.algorithms.matrix.crout_matrix_decomposition",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_exponentiation",
        "description": "algorithms.algorithms.matrix.matrix_exponentiation",
        "peekOfCode": "def multiply(matA: list, matB: list) -> list:\n    \"\"\"\n    Multiplies two square matrices matA and matB od size n x n\n    Time Complexity: O(n^3)\n    \"\"\"\n    n = len(matA)\n    matC = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):",
        "detail": "algorithms.algorithms.matrix.matrix_exponentiation",
        "documentation": {}
    },
    {
        "label": "identity",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_exponentiation",
        "description": "algorithms.algorithms.matrix.matrix_exponentiation",
        "peekOfCode": "def identity(n: int) -> list:\n    \"\"\"\n    Returns the Identity matrix of size n x n\n    Time Complexity: O(n^2)\n    \"\"\"\n    I = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        I[i][i] = 1\n    return I\ndef matrix_exponentiation(mat: list, n: int) -> list:",
        "detail": "algorithms.algorithms.matrix.matrix_exponentiation",
        "documentation": {}
    },
    {
        "label": "matrix_exponentiation",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_exponentiation",
        "description": "algorithms.algorithms.matrix.matrix_exponentiation",
        "peekOfCode": "def matrix_exponentiation(mat: list, n: int) -> list:\n    \"\"\"\n    Calculates mat^n by repeated squaring\n    Time Complexity: O(d^3 log(n))\n                     d: dimension of the square matrix mat\n                     n: power the matrix is raised to\n    \"\"\"\n    if n == 0:\n        return identity(len(mat))\n    elif n % 2 == 1:",
        "detail": "algorithms.algorithms.matrix.matrix_exponentiation",
        "documentation": {}
    },
    {
        "label": "invert_matrix",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_inversion",
        "description": "algorithms.algorithms.matrix.matrix_inversion",
        "peekOfCode": "def invert_matrix(m):\n    \"\"\"invert an n x n matrix\"\"\"\n    # Error conditions\n    if not array_is_matrix(m):\n        print(\"Invalid matrix: array is not a matrix\")\n        return [[-1]]\n    elif len(m) != len(m[0]):\n        print(\"Invalid matrix: matrix is not square\")\n        return [[-2]]\n    elif len(m) < 2:",
        "detail": "algorithms.algorithms.matrix.matrix_inversion",
        "documentation": {}
    },
    {
        "label": "get_determinant",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_inversion",
        "description": "algorithms.algorithms.matrix.matrix_inversion",
        "peekOfCode": "def get_determinant(m):\n    \"\"\"recursively calculate the determinant of an n x n matrix, n >= 2\"\"\"\n    if len(m) == 2:\n        # trivial case\n        return (m[0][0] * m[1][1]) - (m[0][1] * m[1][0])\n    else:\n        sign = 1\n        det = 0\n        for i in range(len(m)):\n            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))",
        "detail": "algorithms.algorithms.matrix.matrix_inversion",
        "documentation": {}
    },
    {
        "label": "get_matrix_of_minors",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_inversion",
        "description": "algorithms.algorithms.matrix.matrix_inversion",
        "peekOfCode": "def get_matrix_of_minors(m):\n    \"\"\"get the matrix of minors and alternate signs\"\"\"\n    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]\n    for row in range(len(m)):\n        for col in range(len(m[0])):\n            if (row + col) % 2 == 0:\n                sign = 1\n            else:\n                sign = -1\n            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))",
        "detail": "algorithms.algorithms.matrix.matrix_inversion",
        "documentation": {}
    },
    {
        "label": "get_minor",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_inversion",
        "description": "algorithms.algorithms.matrix.matrix_inversion",
        "peekOfCode": "def get_minor(m, row, col):\n    \"\"\"\n    get the minor of the matrix position m[row][col]\n    (all values m[r][c] where r != row and c != col)\n    \"\"\"\n    minors = []\n    for i in range(len(m)):\n        if i != row:\n            new_row = m[i][:col]\n            new_row.extend(m[i][col + 1:])",
        "detail": "algorithms.algorithms.matrix.matrix_inversion",
        "documentation": {}
    },
    {
        "label": "transpose_and_multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_inversion",
        "description": "algorithms.algorithms.matrix.matrix_inversion",
        "peekOfCode": "def transpose_and_multiply(m, multiplier=1):\n    \"\"\"swap values along diagonal, optionally adding multiplier\"\"\"\n    for row in range(len(m)):\n        for col in range(row + 1):\n            temp = m[row][col] * multiplier\n            m[row][col] = m[col][row] * multiplier\n            m[col][row] = temp\n    return m\ndef array_is_matrix(m):\n    if len(m) == 0:",
        "detail": "algorithms.algorithms.matrix.matrix_inversion",
        "documentation": {}
    },
    {
        "label": "array_is_matrix",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.matrix_inversion",
        "description": "algorithms.algorithms.matrix.matrix_inversion",
        "peekOfCode": "def array_is_matrix(m):\n    if len(m) == 0:\n        return False\n    first_col = len(m[0])\n    for row in m:\n        if len(row) != first_col:\n            return False\n    return True",
        "detail": "algorithms.algorithms.matrix.matrix_inversion",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.multiply",
        "description": "algorithms.algorithms.matrix.multiply",
        "peekOfCode": "def multiply(multiplicand: list, multiplier: list) -> list:\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    multiplicand_row, multiplicand_col = len(\n        multiplicand), len(multiplicand[0])\n    multiplier_row, multiplier_col = len(multiplier), len(multiplier[0])\n    if(multiplicand_col != multiplier_row):",
        "detail": "algorithms.algorithms.matrix.multiply",
        "documentation": {}
    },
    {
        "label": "rotate",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.rotate_image",
        "description": "algorithms.algorithms.matrix.rotate_image",
        "peekOfCode": "def rotate(mat):\n    if not mat:\n        return mat\n    mat.reverse()\n    for i in range(len(mat)):\n        for j in range(i):\n            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]\n    return mat\nif __name__ == \"__main__\":\n    mat = [[1,2,3],",
        "detail": "algorithms.algorithms.matrix.rotate_image",
        "documentation": {}
    },
    {
        "label": "search_in_a_sorted_matrix",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.search_in_sorted_matrix",
        "description": "algorithms.algorithms.matrix.search_in_sorted_matrix",
        "peekOfCode": "def search_in_a_sorted_matrix(mat, m, n, key):\n    i, j = m-1, 0\n    while i >= 0 and j < n:\n        if key == mat[i][j]:\n            print ('Key %s found at row- %s column- %s' % (key, i+1, j+1))\n            return\n        if key < mat[i][j]:\n            i -= 1\n        else:\n            j += 1",
        "detail": "algorithms.algorithms.matrix.search_in_sorted_matrix",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.search_in_sorted_matrix",
        "description": "algorithms.algorithms.matrix.search_in_sorted_matrix",
        "peekOfCode": "def main():\n    mat = [\n           [2, 5, 7],\n           [4, 8, 13],\n           [9, 11, 15],\n           [12, 17, 20]\n          ]\n    key = 13\n    print (mat)\n    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), key)",
        "detail": "algorithms.algorithms.matrix.search_in_sorted_matrix",
        "documentation": {}
    },
    {
        "label": "sort_diagonally",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sort_matrix_diagonally",
        "description": "algorithms.algorithms.matrix.sort_matrix_diagonally",
        "peekOfCode": "def sort_diagonally(mat: List[List[int]]) -> List[List[int]]:\n    # If the input is a vector, return the vector\n    if len(mat) == 1 or len(mat[0]) == 1:\n        return mat\n    # Rows + columns - 1\n    # The -1 helps you to not repeat a column\n    for i in range(len(mat)+len(mat[0])-1):\n        # Process the rows\n        if i+1 < len(mat):\n            #Initialize heap, set row and column",
        "detail": "algorithms.algorithms.matrix.sort_matrix_diagonally",
        "documentation": {}
    },
    {
        "label": "mat",
        "kind": 5,
        "importPath": "algorithms.algorithms.matrix.sort_matrix_diagonally",
        "description": "algorithms.algorithms.matrix.sort_matrix_diagonally",
        "peekOfCode": "mat = [\n    [3,3,1,1],\n    [2,2,1,2],\n    [1,1,1,2]\n]\nShould return:\n[\n    [1,1,1,1],\n    [1,2,2,2],\n    [1,2,3,3]",
        "detail": "algorithms.algorithms.matrix.sort_matrix_diagonally",
        "documentation": {}
    },
    {
        "label": "vector_to_index_value_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sparse_dot_vector",
        "description": "algorithms.algorithms.matrix.sparse_dot_vector",
        "peekOfCode": "def vector_to_index_value_list(vector):\n    return [(i, v) for i, v in enumerate(vector) if v != 0.0]\ndef dot_product(iv_list1, iv_list2):\n    product = 0\n    p1 = len(iv_list1) - 1\n    p2 = len(iv_list2) - 1\n    while p1 >= 0 and p2 >= 0:\n        i1, v1 = iv_list1[p1]\n        i2, v2 = iv_list2[p2]\n        if i1 < i2:",
        "detail": "algorithms.algorithms.matrix.sparse_dot_vector",
        "documentation": {}
    },
    {
        "label": "dot_product",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sparse_dot_vector",
        "description": "algorithms.algorithms.matrix.sparse_dot_vector",
        "peekOfCode": "def dot_product(iv_list1, iv_list2):\n    product = 0\n    p1 = len(iv_list1) - 1\n    p2 = len(iv_list2) - 1\n    while p1 >= 0 and p2 >= 0:\n        i1, v1 = iv_list1[p1]\n        i2, v2 = iv_list2[p2]\n        if i1 < i2:\n            p1 -= 1\n        elif i2 < i1:",
        "detail": "algorithms.algorithms.matrix.sparse_dot_vector",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sparse_mul",
        "description": "algorithms.algorithms.matrix.sparse_mul",
        "peekOfCode": "def multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None: return None\n    m, n, l = len(a), len(b[0]), len(b[0])\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")",
        "detail": "algorithms.algorithms.matrix.sparse_mul",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sparse_mul",
        "description": "algorithms.algorithms.matrix.sparse_mul",
        "peekOfCode": "def multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None: return None\n    m, n, l = len(a), len(a[0]), len(b[0])\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")",
        "detail": "algorithms.algorithms.matrix.sparse_mul",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sparse_mul",
        "description": "algorithms.algorithms.matrix.sparse_mul",
        "peekOfCode": "def multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None: return None\n    m, n = len(a), len(b[0])\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")",
        "detail": "algorithms.algorithms.matrix.sparse_mul",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "algorithms.algorithms.matrix.sparse_mul",
        "description": "algorithms.algorithms.matrix.sparse_mul",
        "peekOfCode": "A = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\nB = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |",
        "detail": "algorithms.algorithms.matrix.sparse_mul",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": "algorithms.algorithms.matrix.sparse_mul",
        "description": "algorithms.algorithms.matrix.sparse_mul",
        "peekOfCode": "B = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |\n\"\"\"\n# Python solution without table (~156ms):",
        "detail": "algorithms.algorithms.matrix.sparse_mul",
        "documentation": {}
    },
    {
        "label": "AB",
        "kind": 5,
        "importPath": "algorithms.algorithms.matrix.sparse_mul",
        "description": "algorithms.algorithms.matrix.sparse_mul",
        "peekOfCode": "AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |\n\"\"\"\n# Python solution without table (~156ms):\ndef multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"",
        "detail": "algorithms.algorithms.matrix.sparse_mul",
        "documentation": {}
    },
    {
        "label": "spiral_traversal",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.spiral_traversal",
        "description": "algorithms.algorithms.matrix.spiral_traversal",
        "peekOfCode": "def spiral_traversal(matrix):\n    res = []\n    if len(matrix) == 0:\n        return res\n    row_begin = 0\n    row_end = len(matrix) - 1\n    col_begin = 0\n    col_end = len(matrix[0]) - 1\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end+1):",
        "detail": "algorithms.algorithms.matrix.spiral_traversal",
        "documentation": {}
    },
    {
        "label": "valid_solution_hashtable",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sudoku_validator",
        "description": "algorithms.algorithms.matrix.sudoku_validator",
        "peekOfCode": "def valid_solution_hashtable(board):\n    for i in range(len(board)):\n        dict_row = defaultdict(int)\n        dict_col = defaultdict(int)\n        for j in range(len(board[0])):\n            value_row = board[i][j]\n            value_col = board[j][i]\n            if not value_row or value_col == 0:\n                return False\n            if value_row in dict_row:",
        "detail": "algorithms.algorithms.matrix.sudoku_validator",
        "documentation": {}
    },
    {
        "label": "valid_solution",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sudoku_validator",
        "description": "algorithms.algorithms.matrix.sudoku_validator",
        "peekOfCode": "def valid_solution(board):\n    correct = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # check rows\n    for row in board:\n        if sorted(row) != correct:\n            return False\n    # check columns\n    for column in zip(*board):\n        if sorted(column) != correct:\n            return False",
        "detail": "algorithms.algorithms.matrix.sudoku_validator",
        "documentation": {}
    },
    {
        "label": "valid_solution_se",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sudoku_validator",
        "description": "algorithms.algorithms.matrix.sudoku_validator",
        "peekOfCode": "def valid_solution_set (board):\n    valid = set(range(1, 10))\n    for row in board:\n        if set(row) != valid:\n            return False\n    for col in [[row[i] for row in board] for i in range(9)]:\n        if set(col) != valid:\n            return False\n    for x in range(3):\n        for y in range(3):",
        "detail": "algorithms.algorithms.matrix.sudoku_validator",
        "documentation": {}
    },
    {
        "label": "sum_sub_squares",
        "kind": 2,
        "importPath": "algorithms.algorithms.matrix.sum_sub_squares",
        "description": "algorithms.algorithms.matrix.sum_sub_squares",
        "peekOfCode": "def sum_sub_squares(matrix, k):\n    n = len(matrix)\n    result = [[0 for i in range(k)] for j in range(k)]\n    if k > n:\n        return\n    for i in range(n - k + 1):\n        l = 0 \n        for j in range(n - k + 1):\n            sum = 0\n            # Calculate and print sum of current sub-square ",
        "detail": "algorithms.algorithms.matrix.sum_sub_squares",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 2,
        "importPath": "algorithms.algorithms.ml.nearest_neighbor",
        "description": "algorithms.algorithms.ml.nearest_neighbor",
        "peekOfCode": "def distance(x,y):\n    \"\"\"[summary]\n    HELPER-FUNCTION\n    calculates the (eulidean) distance between vector x and y.\n    Arguments:\n        x {[tuple]} -- [vector]\n        y {[tuple]} -- [vector]\n    \"\"\"\n    assert len(x) == len(y), \"The vector must have same length\"\n    result = ()",
        "detail": "algorithms.algorithms.ml.nearest_neighbor",
        "documentation": {}
    },
    {
        "label": "nearest_neighbor",
        "kind": 2,
        "importPath": "algorithms.algorithms.ml.nearest_neighbor",
        "description": "algorithms.algorithms.ml.nearest_neighbor",
        "peekOfCode": "def nearest_neighbor(x, tSet):\n    \"\"\"[summary]\n    Implements the nearest neighbor algorithm\n    Arguments:\n        x {[tupel]} -- [vector]\n        tSet {[dict]} -- [training set]\n    Returns:\n        [type] -- [result of the AND-function]\n    \"\"\"\n    assert isinstance(x, tuple) and isinstance(tSet, dict)",
        "detail": "algorithms.algorithms.ml.nearest_neighbor",
        "documentation": {}
    },
    {
        "label": "max_sliding_window",
        "kind": 2,
        "importPath": "algorithms.algorithms.queues.max_sliding_window",
        "description": "algorithms.algorithms.queues.max_sliding_window",
        "peekOfCode": "def max_sliding_window(arr, k):\n    qi = collections.deque()  # queue storing indexes of elements\n    result = []\n    for i, n in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:",
        "detail": "algorithms.algorithms.queues.max_sliding_window",
        "documentation": {}
    },
    {
        "label": "MovingAverage",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.moving_average",
        "description": "algorithms.algorithms.queues.moving_average",
        "peekOfCode": "class MovingAverage(object):\n    def __init__(self, size):\n        \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n        self.queue = deque(maxlen=size)\n    def next(self, val):\n        \"\"\"\n        :type val: int",
        "detail": "algorithms.algorithms.queues.moving_average",
        "documentation": {}
    },
    {
        "label": "PriorityQueueNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.priority_queue",
        "description": "algorithms.algorithms.queues.priority_queue",
        "peekOfCode": "class PriorityQueueNode:\n    def __init__(self, data, priority):\n        self.data = data\n        self.priority = priority\n    def __repr__(self):\n        return \"{}: {}\".format(self.data, self.priority)\nclass PriorityQueue:\n    def __init__(self, items=None, priorities=None):\n        \"\"\"Create a priority queue with items (list or iterable).\n        If items is not passed, create empty priority queue.\"\"\"",
        "detail": "algorithms.algorithms.queues.priority_queue",
        "documentation": {}
    },
    {
        "label": "PriorityQueue",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.priority_queue",
        "description": "algorithms.algorithms.queues.priority_queue",
        "peekOfCode": "class PriorityQueue:\n    def __init__(self, items=None, priorities=None):\n        \"\"\"Create a priority queue with items (list or iterable).\n        If items is not passed, create empty priority queue.\"\"\"\n        self.priority_queue_list = []\n        if items is None:\n            return\n        if priorities is None:\n            priorities = itertools.repeat(None)\n        for item, priority in zip(items, priorities):",
        "detail": "algorithms.algorithms.queues.priority_queue",
        "documentation": {}
    },
    {
        "label": "AbstractQueue",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.queue",
        "description": "algorithms.algorithms.queues.queue",
        "peekOfCode": "class AbstractQueue(metaclass=ABCMeta):\n    def __init__(self):\n        self._size = 0\n    def __len__(self):\n        return self._size\n    def is_empty(self):\n        return self._size == 0\n    @abstractmethod\n    def enqueue(self, value):\n        pass",
        "detail": "algorithms.algorithms.queues.queue",
        "documentation": {}
    },
    {
        "label": "ArrayQueue",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.queue",
        "description": "algorithms.algorithms.queues.queue",
        "peekOfCode": "class ArrayQueue(AbstractQueue):\n    def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0",
        "detail": "algorithms.algorithms.queues.queue",
        "documentation": {}
    },
    {
        "label": "QueueNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.queue",
        "description": "algorithms.algorithms.queues.queue",
        "peekOfCode": "class QueueNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nclass LinkedListQueue(AbstractQueue):\n    def __init__(self):\n        super().__init__()\n        self._front = None\n        self._rear = None\n    def __iter__(self):",
        "detail": "algorithms.algorithms.queues.queue",
        "documentation": {}
    },
    {
        "label": "LinkedListQueue",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.queue",
        "description": "algorithms.algorithms.queues.queue",
        "peekOfCode": "class LinkedListQueue(AbstractQueue):\n    def __init__(self):\n        super().__init__()\n        self._front = None\n        self._rear = None\n    def __iter__(self):\n        probe = self._front\n        while True:\n            if probe is None:\n                return",
        "detail": "algorithms.algorithms.queues.queue",
        "documentation": {}
    },
    {
        "label": "reconstruct_queue",
        "kind": 2,
        "importPath": "algorithms.algorithms.queues.reconstruct_queue",
        "description": "algorithms.algorithms.queues.reconstruct_queue",
        "peekOfCode": "def reconstruct_queue(people):\n    \"\"\"\n    :type people: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for h, k in people:\n        queue.insert(k, [h, k])\n    return queue",
        "detail": "algorithms.algorithms.queues.reconstruct_queue",
        "documentation": {}
    },
    {
        "label": "ZigZagIterator",
        "kind": 6,
        "importPath": "algorithms.algorithms.queues.zigzagiterator",
        "description": "algorithms.algorithms.queues.zigzagiterator",
        "peekOfCode": "class ZigZagIterator:\n    def __init__(self, v1, v2):\n        \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n        self.queue=[_ for _ in (v1,v2) if _]\n        print(self.queue)\n    def next(self):",
        "detail": "algorithms.algorithms.queues.zigzagiterator",
        "documentation": {}
    },
    {
        "label": "l1",
        "kind": 5,
        "importPath": "algorithms.algorithms.queues.zigzagiterator",
        "description": "algorithms.algorithms.queues.zigzagiterator",
        "peekOfCode": "l1 = [1, 2]\nl2 = [3, 4, 5, 6]\nit = ZigZagIterator(l1, l2)\nwhile it.has_next():\n    print(it.next())",
        "detail": "algorithms.algorithms.queues.zigzagiterator",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "algorithms.algorithms.queues.zigzagiterator",
        "description": "algorithms.algorithms.queues.zigzagiterator",
        "peekOfCode": "l2 = [3, 4, 5, 6]\nit = ZigZagIterator(l1, l2)\nwhile it.has_next():\n    print(it.next())",
        "detail": "algorithms.algorithms.queues.zigzagiterator",
        "documentation": {}
    },
    {
        "label": "it",
        "kind": 5,
        "importPath": "algorithms.algorithms.queues.zigzagiterator",
        "description": "algorithms.algorithms.queues.zigzagiterator",
        "peekOfCode": "it = ZigZagIterator(l1, l2)\nwhile it.has_next():\n    print(it.next())",
        "detail": "algorithms.algorithms.queues.zigzagiterator",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.binary_search",
        "description": "algorithms.algorithms.search.binary_search",
        "peekOfCode": "def binary_search(array, query):\n    lo, hi = 0, len(array) - 1\n    while lo <= hi:\n        mid = (hi + lo) // 2\n        val = array[mid]\n        if val == query:\n            return mid\n        elif val < query:\n            lo = mid + 1\n        else:",
        "detail": "algorithms.algorithms.search.binary_search",
        "documentation": {}
    },
    {
        "label": "binary_search_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.binary_search",
        "description": "algorithms.algorithms.search.binary_search",
        "peekOfCode": "def binary_search_recur(array, low, high, val):\n    if low > high:       # error case\n        return -1\n    mid = (low + high) // 2\n    if val < array[mid]:\n        return binary_search_recur(array, low, mid - 1, val)\n    elif val > array[mid]:\n        return binary_search_recur(array, mid + 1, high, val)\n    else:\n        return mid",
        "detail": "algorithms.algorithms.search.binary_search",
        "documentation": {}
    },
    {
        "label": "find_min_rotate",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.find_min_rotate",
        "description": "algorithms.algorithms.search.find_min_rotate",
        "peekOfCode": "def find_min_rotate(array):\n    low = 0\n    high = len(array) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return array[low]",
        "detail": "algorithms.algorithms.search.find_min_rotate",
        "documentation": {}
    },
    {
        "label": "find_min_rotate_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.find_min_rotate",
        "description": "algorithms.algorithms.search.find_min_rotate",
        "peekOfCode": "def find_min_rotate_recur(array, low, high):\n    mid = (low + high) // 2\n    if mid == low:\n        return array[low]\n    elif array[mid] > array[high]:\n        return find_min_rotate_recur(array, mid + 1, high)\n    else:\n        return find_min_rotate_recur(array, low, mid)",
        "detail": "algorithms.algorithms.search.find_min_rotate",
        "documentation": {}
    },
    {
        "label": "first_occurrence",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.first_occurrence",
        "description": "algorithms.algorithms.search.first_occurrence",
        "peekOfCode": "def first_occurrence(array, query):\n    lo, hi = 0, len(array) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        #print(\"lo: \", lo, \" hi: \", hi, \" mid: \", mid)\n        if lo == hi:\n            break\n        if array[mid] < query:\n            lo = mid + 1\n        else:",
        "detail": "algorithms.algorithms.search.first_occurrence",
        "documentation": {}
    },
    {
        "label": "interpolation_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.interpolation_search",
        "description": "algorithms.algorithms.search.interpolation_search",
        "peekOfCode": "def interpolation_search(array: List[int], search_key: int) -> int:\n    \"\"\"\n    :param array: The array to be searched.\n    :param search_key: The key to be searched in the array.\n    :returns: Index of search_key in array if found, else -1.\n    Examples:\n    >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)\n    2\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)\n    -1",
        "detail": "algorithms.algorithms.search.interpolation_search",
        "documentation": {}
    },
    {
        "label": "jump_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.jump_search",
        "description": "algorithms.algorithms.search.jump_search",
        "peekOfCode": "def jump_search(arr,target):\n    \"\"\"Jump Search\n        Worst-case Complexity: O(n) (root(n))\n        All items in list must be sorted like binary search\n        Find block that contains target value and search it linearly in that block\n        It returns a first target value in array\n        reference: https://en.wikipedia.org/wiki/Jump_search\n    \"\"\"\n    n = len(arr)\n    block_size = int(math.sqrt(n))",
        "detail": "algorithms.algorithms.search.jump_search",
        "documentation": {}
    },
    {
        "label": "last_occurrence",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.last_occurrence",
        "description": "algorithms.algorithms.search.last_occurrence",
        "peekOfCode": "def last_occurrence(array, query):\n    lo, hi = 0, len(array) - 1\n    while lo <= hi:\n        mid = (hi + lo) // 2\n        if (array[mid] == query and mid == len(array)-1) or \\\n           (array[mid] == query and array[mid+1] > query):\n            return mid\n        elif (array[mid] <= query):\n            lo = mid + 1\n        else:",
        "detail": "algorithms.algorithms.search.last_occurrence",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.linear_search",
        "description": "algorithms.algorithms.search.linear_search",
        "peekOfCode": "def linear_search(array, query):\n    for i in range(len(array)):\n        if array[i] == query:\n            return i\n    return -1",
        "detail": "algorithms.algorithms.search.linear_search",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "def next_greatest_letter(letters, target):\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]\n\"\"\"\nUsing binary search: complexity O(logN)\n\"\"\"\ndef next_greatest_letter_v1(letters, target):\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "def next_greatest_letter_v1(letters, target):\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    left, right = 0, len(letters) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if  letters[mid] > target:\n            right = mid - 1",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "next_greatest_letter_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "def next_greatest_letter_v2(letters, target):\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "letters = ['a', 'b'], the answer is 'a'.\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\nInput:",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "letters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "target = \"a\"\nOutput: \"c\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "letters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/\n'''\nimport bisect",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "target = \"c\"\nOutput: \"f\"\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/\n'''\nimport bisect\n\"\"\"",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "letters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/\n'''\nimport bisect\n\"\"\"\nUsing bisect libarary\n\"\"\"\ndef next_greatest_letter(letters, target):",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.next_greatest_letter",
        "description": "algorithms.algorithms.search.next_greatest_letter",
        "peekOfCode": "target = \"d\"\nOutput: \"f\"\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/\n'''\nimport bisect\n\"\"\"\nUsing bisect libarary\n\"\"\"\ndef next_greatest_letter(letters, target):\n    index = bisect.bisect(letters, target)",
        "detail": "algorithms.algorithms.search.next_greatest_letter",
        "documentation": {}
    },
    {
        "label": "search_insert",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.search_insert",
        "description": "algorithms.algorithms.search.search_insert",
        "peekOfCode": "def search_insert(array, val):\n    low = 0\n    high = len(array) - 1\n    while low <=  high:\n        mid = low + (high - low) // 2\n        if val > array[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low",
        "detail": "algorithms.algorithms.search.search_insert",
        "documentation": {}
    },
    {
        "label": "search_range",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.search_range",
        "description": "algorithms.algorithms.search.search_range",
        "peekOfCode": "def search_range(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = low + (high - low) // 2",
        "detail": "algorithms.algorithms.search.search_range",
        "documentation": {}
    },
    {
        "label": "search_rotate",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.search_rotate",
        "description": "algorithms.algorithms.search.search_rotate",
        "peekOfCode": "def search_rotate(array, val):\n    low, high = 0, len(array) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if val == array[mid]:\n            return mid\n        if array[low] <= array[mid]:\n            if array[low] <= val <= array[mid]:\n                high = mid - 1\n            else:",
        "detail": "algorithms.algorithms.search.search_rotate",
        "documentation": {}
    },
    {
        "label": "search_rotate_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.search_rotate",
        "description": "algorithms.algorithms.search.search_rotate",
        "peekOfCode": "def search_rotate_recur(array, low, high, val):\n    if low >= high:\n        return -1\n    mid = (low + high) // 2\n    if val == array[mid]:       # found element\n        return mid\n    if array[low] <= array[mid]:\n        if array[low] <= val <= array[mid]:\n            return search_rotate_recur(array, low, mid - 1, val)    # Search left\n        else:",
        "detail": "algorithms.algorithms.search.search_rotate",
        "documentation": {}
    },
    {
        "label": "ternary_search",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "def ternary_search(l, r, key, arr):\n\twhile r >= l:\n\t\tmid1 = l + (r-l) // 3\n\t\tmid2 = r - (r-l) // 3\n\t\tif key == arr[mid1]:\n\t\t\treturn mid1\n\t\tif key == mid2:\n\t\t\treturn mid2\n\t\tif key < arr[mid1]:\n            # key lies between l and mid1",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "mid1",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "mid1 = l + (r-l)/3 \nmid2 = r  (r-l)/3 \nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3\n\"\"\"\ndef ternary_search(l, r, key, arr):\n\twhile r >= l:\n\t\tmid1 = l + (r-l) // 3\n\t\tmid2 = r - (r-l) // 3",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "mid2",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "mid2 = r  (r-l)/3 \nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3\n\"\"\"\ndef ternary_search(l, r, key, arr):\n\twhile r >= l:\n\t\tmid1 = l + (r-l) // 3\n\t\tmid2 = r - (r-l) // 3\n\t\tif key == arr[mid1]:",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "T(N)",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "T(N) = O(log3(N))\nlog3 = log base 3\n\"\"\"\ndef ternary_search(l, r, key, arr):\n\twhile r >= l:\n\t\tmid1 = l + (r-l) // 3\n\t\tmid2 = r - (r-l) // 3\n\t\tif key == arr[mid1]:\n\t\t\treturn mid1\n\t\tif key == mid2:",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "log3",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "log3 = log base 3\n\"\"\"\ndef ternary_search(l, r, key, arr):\n\twhile r >= l:\n\t\tmid1 = l + (r-l) // 3\n\t\tmid2 = r - (r-l) // 3\n\t\tif key == arr[mid1]:\n\t\t\treturn mid1\n\t\tif key == mid2:\n\t\t\treturn mid2",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "\t\tmid1",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "\t\tmid1 = l + (r-l) // 3\n\t\tmid2 = r - (r-l) // 3\n\t\tif key == arr[mid1]:\n\t\t\treturn mid1\n\t\tif key == mid2:\n\t\t\treturn mid2\n\t\tif key < arr[mid1]:\n            # key lies between l and mid1\n\t\t\tr = mid1 - 1\n\t\telif key > arr[mid2]:",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "\t\tmid2",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "\t\tmid2 = r - (r-l) // 3\n\t\tif key == arr[mid1]:\n\t\t\treturn mid1\n\t\tif key == mid2:\n\t\t\treturn mid2\n\t\tif key < arr[mid1]:\n            # key lies between l and mid1\n\t\t\tr = mid1 - 1\n\t\telif key > arr[mid2]:\n            # key lies between mid2 and r",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "\t\t\tr",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "\t\t\tr = mid1 - 1\n\t\telif key > arr[mid2]:\n            # key lies between mid2 and r\n\t\t\tl = mid2 + 1\n\t\telse:\n            # key lies between mid1 and mid2\n\t\t\tl = mid1 + 1\n\t\t\tr = mid2 - 1\n    # key not found \n\treturn -1",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "\t\t\tl",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "\t\t\tl = mid2 + 1\n\t\telse:\n            # key lies between mid1 and mid2\n\t\t\tl = mid1 + 1\n\t\t\tr = mid2 - 1\n    # key not found \n\treturn -1",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "\t\t\tl",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "\t\t\tl = mid1 + 1\n\t\t\tr = mid2 - 1\n    # key not found \n\treturn -1",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "\t\t\tr",
        "kind": 5,
        "importPath": "algorithms.algorithms.search.ternary_search",
        "description": "algorithms.algorithms.search.ternary_search",
        "peekOfCode": "\t\t\tr = mid2 - 1\n    # key not found \n\treturn -1",
        "detail": "algorithms.algorithms.search.ternary_search",
        "documentation": {}
    },
    {
        "label": "two_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.two_sum",
        "description": "algorithms.algorithms.search.two_sum",
        "peekOfCode": "def two_sum(numbers, target):\n    for i in range(len(numbers)):\n        second_val = target - numbers[i]\n        low, high = i+1, len(numbers)-1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if second_val == numbers[mid]:\n                return [i + 1, mid + 1]\n            elif second_val > numbers[mid]:\n                low = mid + 1",
        "detail": "algorithms.algorithms.search.two_sum",
        "documentation": {}
    },
    {
        "label": "two_sum1",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.two_sum",
        "description": "algorithms.algorithms.search.two_sum",
        "peekOfCode": "def two_sum1(numbers, target):\n    dic = {}\n    for i, num in enumerate(numbers):\n        if target - num in dic:\n            return [dic[target - num] + 1, i + 1]\n        dic[num] = i\n# Using two pointers\ndef two_sum2(numbers, target):\n    p1 = 0                      # pointer 1 holds from left of array numbers\n    p2 = len(numbers) - 1       # pointer 2 holds from right of array numbers",
        "detail": "algorithms.algorithms.search.two_sum",
        "documentation": {}
    },
    {
        "label": "two_sum2",
        "kind": 2,
        "importPath": "algorithms.algorithms.search.two_sum",
        "description": "algorithms.algorithms.search.two_sum",
        "peekOfCode": "def two_sum2(numbers, target):\n    p1 = 0                      # pointer 1 holds from left of array numbers\n    p2 = len(numbers) - 1       # pointer 2 holds from right of array numbers\n    while p1 < p2:\n        s = numbers[p1] + numbers[p2]\n        if s == target:\n            return [p1 + 1, p2 + 1]\n        elif s > target:\n            p2 = p2 - 1\n        else:",
        "detail": "algorithms.algorithms.search.two_sum",
        "documentation": {}
    },
    {
        "label": "find_keyboard_row",
        "kind": 2,
        "importPath": "algorithms.algorithms.set.find_keyboard_row",
        "description": "algorithms.algorithms.set.find_keyboard_row",
        "peekOfCode": "def find_keyboard_row(words):\n    \"\"\"\n    :type words: List[str]\n    :rtype: List[str]\n    \"\"\"\n    keyboard = [\n        set('qwertyuiop'),\n        set('asdfghjkl'),\n        set('zxcvbnm'),\n    ]",
        "detail": "algorithms.algorithms.set.find_keyboard_row",
        "documentation": {}
    },
    {
        "label": "RandomizedSet",
        "kind": 6,
        "importPath": "algorithms.algorithms.set.randomized_set",
        "description": "algorithms.algorithms.set.randomized_set",
        "peekOfCode": "class RandomizedSet():\n    \"\"\"\n    idea: shoot\n    \"\"\"\n    def __init__(self):\n        self.elements = []\n        self.index_map = {}  # element -> index\n    def insert(self, new_one):\n        if new_one in self.index_map:\n            return",
        "detail": "algorithms.algorithms.set.randomized_set",
        "documentation": {}
    },
    {
        "label": "powerset",
        "kind": 2,
        "importPath": "algorithms.algorithms.set.set_covering",
        "description": "algorithms.algorithms.set.set_covering",
        "peekOfCode": "def powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html#itertools-recipes\n    \"\"\"\n    \"list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\ndef optimal_set_cover(universe, subsets, costs):",
        "detail": "algorithms.algorithms.set.set_covering",
        "documentation": {}
    },
    {
        "label": "optimal_set_cover",
        "kind": 2,
        "importPath": "algorithms.algorithms.set.set_covering",
        "description": "algorithms.algorithms.set.set_covering",
        "peekOfCode": "def optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None",
        "detail": "algorithms.algorithms.set.set_covering",
        "documentation": {}
    },
    {
        "label": "greedy_set_cover",
        "kind": 2,
        "importPath": "algorithms.algorithms.set.set_covering",
        "description": "algorithms.algorithms.set.set_covering",
        "peekOfCode": "def greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set(e for s in subsets.keys() for e in subsets[s])\n    # elements don't cover universe -> invalid input for set cover",
        "detail": "algorithms.algorithms.set.set_covering",
        "documentation": {}
    },
    {
        "label": "bitonic_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.bitonic_sort",
        "description": "algorithms.algorithms.sort.bitonic_sort",
        "peekOfCode": "def bitonic_sort(arr, reverse=False):\n    \"\"\"\n    bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process\n    It can sort only array that sizes power of 2\n    It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)\n    Worst-case in parallel: O(log(n)^2)\n    Worst-case in non-parallel: O(nlog(n)^2)\n    reference: https://en.wikipedia.org/wiki/Bitonic_sorter\n    \"\"\"\n    def compare(arr, reverse):",
        "detail": "algorithms.algorithms.sort.bitonic_sort",
        "documentation": {}
    },
    {
        "label": "bogo_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.bogo_sort",
        "description": "algorithms.algorithms.sort.bogo_sort",
        "peekOfCode": "def bogo_sort(arr, simulation=False):\n    \"\"\"Bogo Sort\n        Best Case Complexity: O(n)\n        Worst Case Complexity: O()\n        Average Case Complexity: O(n(n-1)!)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    def is_sorted(arr):",
        "detail": "algorithms.algorithms.sort.bogo_sort",
        "documentation": {}
    },
    {
        "label": "bubble_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.bubble_sort",
        "description": "algorithms.algorithms.sort.bubble_sort",
        "peekOfCode": "def bubble_sort(arr, simulation=False):\n    def swap(i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n    n = len(arr)\n    swapped = True\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    x = -1\n    while swapped:",
        "detail": "algorithms.algorithms.sort.bubble_sort",
        "documentation": {}
    },
    {
        "label": "bucket_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.bucket_sort",
        "description": "algorithms.algorithms.sort.bucket_sort",
        "peekOfCode": "def bucket_sort(arr):\n    ''' Bucket Sort\n        Complexity: O(n^2)\n        The complexity is dominated by nextSort\n    '''\n    # The number of buckets and make buckets\n    num_buckets = len(arr)\n    buckets = [[] for bucket in range(num_buckets)]\n    # Assign values into bucket_sort\n    for value in arr:",
        "detail": "algorithms.algorithms.sort.bucket_sort",
        "documentation": {}
    },
    {
        "label": "next_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.bucket_sort",
        "description": "algorithms.algorithms.sort.bucket_sort",
        "peekOfCode": "def next_sort(arr):\n    # We will use insertion sort here.\n    for i in range(1, len(arr)):\n        j = i - 1\n        key = arr[i]\n        while arr[j] > key and j >= 0:\n            arr[j+1] = arr[j]\n            j = j - 1\n        arr[j + 1] = key\n    return arr",
        "detail": "algorithms.algorithms.sort.bucket_sort",
        "documentation": {}
    },
    {
        "label": "cocktail_shaker_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.cocktail_shaker_sort",
        "description": "algorithms.algorithms.sort.cocktail_shaker_sort",
        "peekOfCode": "def cocktail_shaker_sort(arr):\n    \"\"\"\n    Cocktail_shaker_sort\n    Sorting a given array\n    mutation of bubble sort\n    reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n    Worst-case performance: O(N^2)\n    \"\"\"\n    def swap(i, j):\n        arr[i], arr[j] = arr[j], arr[i]",
        "detail": "algorithms.algorithms.sort.cocktail_shaker_sort",
        "documentation": {}
    },
    {
        "label": "comb_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.comb_sort",
        "description": "algorithms.algorithms.sort.comb_sort",
        "peekOfCode": "def comb_sort(arr):\n    def swap(i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap > 1:",
        "detail": "algorithms.algorithms.sort.comb_sort",
        "documentation": {}
    },
    {
        "label": "counting_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.counting_sort",
        "description": "algorithms.algorithms.sort.counting_sort",
        "peekOfCode": "def counting_sort(arr):\n    \"\"\"\n    Counting_sort\n    Sorting a array which has no element greater than k\n    Creating a new temp_arr,where temp_arr[i] contain the number of\n    element less than or equal to i in the arr\n    Then placing the number i into a correct position in the result_arr\n    return the result_arr\n    Complexity: 0(n)\n    \"\"\"",
        "detail": "algorithms.algorithms.sort.counting_sort",
        "documentation": {}
    },
    {
        "label": "cycle_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.cycle_sort",
        "description": "algorithms.algorithms.sort.cycle_sort",
        "peekOfCode": "def cycle_sort(arr):\n    \"\"\"\n    cycle_sort\n    This is based on the idea that the permutations to be sorted\n    can be decomposed into cycles,\n    and the results can be individually sorted by cycling.\n    reference: https://en.wikipedia.org/wiki/Cycle_sort\n    Average time complexity : O(N^2)\n    Worst case time complexity : O(N^2)\n    \"\"\"",
        "detail": "algorithms.algorithms.sort.cycle_sort",
        "documentation": {}
    },
    {
        "label": "gnome_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.gnome_sort",
        "description": "algorithms.algorithms.sort.gnome_sort",
        "peekOfCode": "def gnome_sort(arr):\n    n = len(arr)\n    index = 0\n    while index < n:\n        if index == 0 or arr[index] >= arr[index-1]:\n            index = index + 1\n        else:\n            arr[index], arr[index-1] = arr[index-1], arr[index]\n            index = index - 1\n    return arr",
        "detail": "algorithms.algorithms.sort.gnome_sort",
        "documentation": {}
    },
    {
        "label": "max_heap_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.heap_sort",
        "description": "algorithms.algorithms.sort.heap_sort",
        "peekOfCode": "def max_heap_sort(arr, simulation=False):\n    \"\"\" Heap Sort that uses a max heap to sort an array in ascending order\n        Complexity: O(n log(n))\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    for i in range(len(arr) - 1, 0, -1):\n        iteration = max_heapify(arr, i, simulation, iteration)\n    if simulation:",
        "detail": "algorithms.algorithms.sort.heap_sort",
        "documentation": {}
    },
    {
        "label": "max_heapify",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.heap_sort",
        "description": "algorithms.algorithms.sort.heap_sort",
        "peekOfCode": "def max_heapify(arr, end, simulation, iteration):\n    \"\"\" Max heapify helper for max_heap_sort\n    \"\"\"\n    last_parent = (end - 1) // 2\n    # Iterate from last parent to first\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        # Iterate from current_parent to last_parent\n        while current_parent <= last_parent:\n            # Find greatest child of current_parent",
        "detail": "algorithms.algorithms.sort.heap_sort",
        "documentation": {}
    },
    {
        "label": "min_heap_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.heap_sort",
        "description": "algorithms.algorithms.sort.heap_sort",
        "peekOfCode": "def min_heap_sort(arr, simulation=False):\n    \"\"\" Heap Sort that uses a min heap to sort an array in ascending order\n        Complexity: O(n log(n))\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    for i in range(0, len(arr) - 1):\n        iteration = min_heapify(arr, i, simulation, iteration)\n    return arr",
        "detail": "algorithms.algorithms.sort.heap_sort",
        "documentation": {}
    },
    {
        "label": "min_heapify",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.heap_sort",
        "description": "algorithms.algorithms.sort.heap_sort",
        "peekOfCode": "def min_heapify(arr, start, simulation, iteration):\n    \"\"\" Min heapify helper for min_heap_sort\n    \"\"\"\n    # Offset last_parent by the start (last_parent calculated as if start index was 0)\n    # All array accesses need to be offset by start\n    end = len(arr) - 1\n    last_parent = (end - start - 1) // 2\n    # Iterate from last parent to first\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent",
        "detail": "algorithms.algorithms.sort.heap_sort",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.insertion_sort",
        "description": "algorithms.algorithms.sort.insertion_sort",
        "peekOfCode": "def insertion_sort(arr, simulation=False):\n    \"\"\" Insertion Sort\n        Complexity: O(n^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    for i in range(len(arr)):\n        cursor = arr[i]\n        pos = i",
        "detail": "algorithms.algorithms.sort.insertion_sort",
        "documentation": {}
    },
    {
        "label": "can_attend_meetings",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.meeting_rooms",
        "description": "algorithms.algorithms.sort.meeting_rooms",
        "peekOfCode": "def can_attend_meetings(intervals):\n    \"\"\"\n    :type intervals: List[Interval]\n    :rtype: bool\n    \"\"\"\n    intervals = sorted(intervals, key=lambda x: x.start)\n    for i in range(1, len(intervals)):\n        if intervals[i].start < intervals[i - 1].end:\n            return False\n    return True",
        "detail": "algorithms.algorithms.sort.meeting_rooms",
        "documentation": {}
    },
    {
        "label": "merge_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.merge_sort",
        "description": "algorithms.algorithms.sort.merge_sort",
        "peekOfCode": "def merge_sort(arr):\n    \"\"\" Merge Sort\n        Complexity: O(n log(n))\n    \"\"\"\n    # Our recursive base case\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    # Perform merge_sort recursively on both halves\n    left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:])",
        "detail": "algorithms.algorithms.sort.merge_sort",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.merge_sort",
        "description": "algorithms.algorithms.sort.merge_sort",
        "peekOfCode": "def merge(left, right, merged):\n    \"\"\" Merge helper\n        Complexity: O(n)\n    \"\"\"\n    left_cursor, right_cursor = 0, 0\n    while left_cursor < len(left) and right_cursor < len(right):\n        # Sort each one and place into the result\n        if left[left_cursor] <= right[right_cursor]:\n            merged[left_cursor+right_cursor]=left[left_cursor]\n            left_cursor += 1",
        "detail": "algorithms.algorithms.sort.merge_sort",
        "documentation": {}
    },
    {
        "label": "pancake_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.pancake_sort",
        "description": "algorithms.algorithms.sort.pancake_sort",
        "peekOfCode": "def pancake_sort(arr):\n    \"\"\"\n    Pancake_sort\n    Sorting a given array\n    mutation of selection sort\n    reference: https://www.geeksforgeeks.org/pancake-sorting/\n    Overall time complexity : O(N^2)\n    \"\"\"\n    len_arr = len(arr)\n    if len_arr <= 1:",
        "detail": "algorithms.algorithms.sort.pancake_sort",
        "documentation": {}
    },
    {
        "label": "pigeonhole_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.pigeonhole_sort",
        "description": "algorithms.algorithms.sort.pigeonhole_sort",
        "peekOfCode": "def pigeonhole_sort(arr):\n    Max = max(arr)\n    Min = min(arr)\n    size = Max - Min + 1\n    holes = [0]*size\n    for i in arr:\n        holes[i-Min] += 1\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:",
        "detail": "algorithms.algorithms.sort.pigeonhole_sort",
        "documentation": {}
    },
    {
        "label": "quick_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.quick_sort",
        "description": "algorithms.algorithms.sort.quick_sort",
        "peekOfCode": "def quick_sort(arr, simulation=False):\n    \"\"\" Quick sort\n        Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    arr, _ = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)\n    return arr\ndef quick_sort_recur(arr, first, last, iteration, simulation):",
        "detail": "algorithms.algorithms.sort.quick_sort",
        "documentation": {}
    },
    {
        "label": "quick_sort_recur",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.quick_sort",
        "description": "algorithms.algorithms.sort.quick_sort",
        "peekOfCode": "def quick_sort_recur(arr, first, last, iteration, simulation):\n    if first < last:\n        pos = partition(arr, first, last)\n        # Start our two recursive calls\n        if simulation:\n            iteration = iteration + 1\n            print(\"iteration\",iteration,\":\",*arr)\n        _, iteration = quick_sort_recur(arr, first, pos - 1, iteration, simulation)\n        _, iteration = quick_sort_recur(arr, pos + 1, last, iteration, simulation)\n    return arr, iteration",
        "detail": "algorithms.algorithms.sort.quick_sort",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.quick_sort",
        "description": "algorithms.algorithms.sort.quick_sort",
        "peekOfCode": "def partition(arr, first, last):\n    wall = first\n    for pos in range(first, last):\n        if arr[pos] < arr[last]:  # last is the pivot\n            arr[pos], arr[wall] = arr[wall], arr[pos]\n            wall += 1\n    arr[wall], arr[last] = arr[last], arr[wall]\n    return wall",
        "detail": "algorithms.algorithms.sort.quick_sort",
        "documentation": {}
    },
    {
        "label": "radix_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.radix_sort",
        "description": "algorithms.algorithms.sort.radix_sort",
        "peekOfCode": "def radix_sort(arr, simulation=False):\n    position = 1\n    max_number = max(arr)\n    iteration = 0\n    if simulation:\n        print(\"iteration\", iteration, \":\", *arr)\n    while position <= max_number:\n        queue_list = [list() for _ in range(10)]\n        for num in arr:\n            digit_number = num // position % 10",
        "detail": "algorithms.algorithms.sort.radix_sort",
        "documentation": {}
    },
    {
        "label": "selection_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.selection_sort",
        "description": "algorithms.algorithms.sort.selection_sort",
        "peekOfCode": "def selection_sort(arr, simulation=False):\n    \"\"\" Selection Sort\n        Complexity: O(n^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    for i in range(len(arr)):\n        minimum = i\n        for j in range(i + 1, len(arr)):",
        "detail": "algorithms.algorithms.sort.selection_sort",
        "documentation": {}
    },
    {
        "label": "shell_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.shell_sort",
        "description": "algorithms.algorithms.sort.shell_sort",
        "peekOfCode": "def shell_sort(arr):\n    ''' Shell Sort\n        Complexity: O(n^2)\n    '''\n    n = len(arr)\n    # Initialize size of the gap\n    gap = n//2\n    while gap > 0:\n        y_index = gap\n        while y_index < len(arr):",
        "detail": "algorithms.algorithms.sort.shell_sort",
        "documentation": {}
    },
    {
        "label": "sort_colors",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.sort_colors",
        "description": "algorithms.algorithms.sort.sort_colors",
        "peekOfCode": "def sort_colors(nums):\n    i = j = 0\n    for k in range(len(nums)):\n        v = nums[k]\n        nums[k] = 2\n        if v < 2:\n            nums[j] = 1\n            j += 1\n        if v == 0:\n            nums[i] = 0",
        "detail": "algorithms.algorithms.sort.sort_colors",
        "documentation": {}
    },
    {
        "label": "stoogesort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.stooge_sort",
        "description": "algorithms.algorithms.sort.stooge_sort",
        "peekOfCode": "def stoogesort(arr, l, h): \n    if l >= h: \n        return\n    # If first element is smaller \n    # than last, swap them \n    if arr[l]>arr[h]: \n        t = arr[l] \n        arr[l] = arr[h] \n        arr[h] = t \n    # If there are more than 2 elements in ",
        "detail": "algorithms.algorithms.sort.stooge_sort",
        "documentation": {}
    },
    {
        "label": "top_sort_recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.top_sort",
        "description": "algorithms.algorithms.sort.top_sort",
        "peekOfCode": "def top_sort_recursive(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    order, enter, state = [], set(graph), {}\n    def dfs(node):\n        state[node] = GRAY\n        #print(node)\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)",
        "detail": "algorithms.algorithms.sort.top_sort",
        "documentation": {}
    },
    {
        "label": "top_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.top_sort",
        "description": "algorithms.algorithms.sort.top_sort",
        "peekOfCode": "def top_sort(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    order, enter, state = [], set(graph), {}\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:",
        "detail": "algorithms.algorithms.sort.top_sort",
        "documentation": {}
    },
    {
        "label": "wiggle_sort",
        "kind": 2,
        "importPath": "algorithms.algorithms.sort.wiggle_sort",
        "description": "algorithms.algorithms.sort.wiggle_sort",
        "peekOfCode": "def wiggle_sort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i-1] > nums[i]):\n            nums[i-1], nums[i] = nums[i], nums[i-1]\nif __name__ == \"__main__\":\n    array = [3, 5, 2, 1, 6, 4]\n    print(array)\n    wiggle_sort(array)\n    print(array)",
        "detail": "algorithms.algorithms.sort.wiggle_sort",
        "documentation": {}
    },
    {
        "label": "first_is_consecutive",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.is_consecutive",
        "description": "algorithms.algorithms.stack.is_consecutive",
        "peekOfCode": "def first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:                # Case odd number of values in stack\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1: # Not consecutive\n            return False\n        stack.append(second_value)          # Backup second value",
        "detail": "algorithms.algorithms.stack.is_consecutive",
        "documentation": {}
    },
    {
        "label": "second_is_consecutive",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.is_consecutive",
        "description": "algorithms.algorithms.stack.is_consecutive",
        "peekOfCode": "def second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:                # Case odd number of values in stack\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1: # Not consecutive\n            return False\n        stack.append(second_value)          # Backup second value",
        "detail": "algorithms.algorithms.stack.is_consecutive",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.is_sorted",
        "description": "algorithms.algorithms.stack.is_sorted",
        "peekOfCode": "def is_sorted(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        if len(stack) == 0:\n            break\n        first_val = stack.pop()\n        if len(stack) == 0:\n            break\n        second_val = stack.pop()\n        if first_val < second_val:",
        "detail": "algorithms.algorithms.stack.is_sorted",
        "documentation": {}
    },
    {
        "label": "length_longest_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.longest_abs_path",
        "description": "algorithms.algorithms.stack.longest_abs_path",
        "peekOfCode": "def length_longest_path(input):\n    \"\"\"\n    :type input: str\n    :rtype: int\n    \"\"\"\n    curr_len, max_len = 0, 0    # running length and max length\n    stack = []    # keep track of the name length\n    for s in input.split('\\n'):\n        print(\"---------\")\n        print(\"<path>:\", s)",
        "detail": "algorithms.algorithms.stack.longest_abs_path",
        "documentation": {}
    },
    {
        "label": "st2",
        "kind": 5,
        "importPath": "algorithms.algorithms.stack.longest_abs_path",
        "description": "algorithms.algorithms.stack.longest_abs_path",
        "peekOfCode": "st2 = \"a\\n\\tb1\\n\\t\\tf1.txt\\n\\taaaaa\\n\\t\\tf2.txt\"\nprint(\"path:\", st2)\nprint(\"answer:\", length_longest_path(st2))",
        "detail": "algorithms.algorithms.stack.longest_abs_path",
        "documentation": {}
    },
    {
        "label": "OrderedStack",
        "kind": 6,
        "importPath": "algorithms.algorithms.stack.ordered_stack",
        "description": "algorithms.algorithms.stack.ordered_stack",
        "peekOfCode": "class OrderedStack:\n     def __init__(self):\n         self.items = []\n     def is_empty(self):\n         return self.items == []\n     def push_t(self, item):\n         self.items.append(item)\n     def push(self, item): #push method to maintain order when pushing new elements\n         temp_stack = OrderedStack()\n         if self.is_empty() or item > self.peek():",
        "detail": "algorithms.algorithms.stack.ordered_stack",
        "documentation": {}
    },
    {
        "label": "remove_min",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.remove_min",
        "description": "algorithms.algorithms.stack.remove_min",
        "peekOfCode": "def remove_min(stack):\n    storage_stack = []\n    if len(stack) == 0:  # Stack is empty\n        return stack\n    # Find the smallest value\n    min = stack.pop()\n    stack.append(min)\n    for i in range(len(stack)):\n        val = stack.pop()\n        if val <= min:",
        "detail": "algorithms.algorithms.stack.remove_min",
        "documentation": {}
    },
    {
        "label": "simplify_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.simplify_path",
        "description": "algorithms.algorithms.stack.simplify_path",
        "peekOfCode": "def simplify_path(path):\n    \"\"\"\n    :type path: str\n    :rtype: str\n    \"\"\"\n    skip = {'..', '.', ''}\n    stack = []\n    paths = path.split('/')\n    for tok in paths:\n        if tok == '..':",
        "detail": "algorithms.algorithms.stack.simplify_path",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "algorithms.algorithms.stack.simplify_path",
        "description": "algorithms.algorithms.stack.simplify_path",
        "peekOfCode": "path = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\n    In this case, you should ignore redundant slashes and return \"/home/foo\".\n\"\"\"\ndef simplify_path(path):\n    \"\"\"\n    :type path: str",
        "detail": "algorithms.algorithms.stack.simplify_path",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "algorithms.algorithms.stack.simplify_path",
        "description": "algorithms.algorithms.stack.simplify_path",
        "peekOfCode": "path = \"/a/./b/../../c/\", => \"/c\"\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\n    In this case, you should ignore redundant slashes and return \"/home/foo\".\n\"\"\"\ndef simplify_path(path):\n    \"\"\"\n    :type path: str\n    :rtype: str",
        "detail": "algorithms.algorithms.stack.simplify_path",
        "documentation": {}
    },
    {
        "label": "AbstractStack",
        "kind": 6,
        "importPath": "algorithms.algorithms.stack.stack",
        "description": "algorithms.algorithms.stack.stack",
        "peekOfCode": "class AbstractStack(metaclass=ABCMeta):\n    \"\"\"Abstract Class for Stacks.\"\"\"\n    def __init__(self):\n        self._top = -1\n    def __len__(self):\n        return self._top + 1\n    def __str__(self):\n        result = \" \".join(map(str, self))\n        return 'Top-> ' + result\n    def is_empty(self):",
        "detail": "algorithms.algorithms.stack.stack",
        "documentation": {}
    },
    {
        "label": "ArrayStack",
        "kind": 6,
        "importPath": "algorithms.algorithms.stack.stack",
        "description": "algorithms.algorithms.stack.stack",
        "peekOfCode": "class ArrayStack(AbstractStack):\n    def __init__(self, size=10):\n        \"\"\"\n        Initialize python List with size of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * size\n    def __iter__(self):",
        "detail": "algorithms.algorithms.stack.stack",
        "documentation": {}
    },
    {
        "label": "StackNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.stack.stack",
        "description": "algorithms.algorithms.stack.stack",
        "peekOfCode": "class StackNode:\n    \"\"\"Represents a single stack node.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nclass LinkedListStack(AbstractStack):\n    def __init__(self):\n        super().__init__()\n        self.head = None\n    def __iter__(self):",
        "detail": "algorithms.algorithms.stack.stack",
        "documentation": {}
    },
    {
        "label": "LinkedListStack",
        "kind": 6,
        "importPath": "algorithms.algorithms.stack.stack",
        "description": "algorithms.algorithms.stack.stack",
        "peekOfCode": "class LinkedListStack(AbstractStack):\n    def __init__(self):\n        super().__init__()\n        self.head = None\n    def __iter__(self):\n        probe = self.head\n        while True:\n            if probe is None:\n                return\n            yield probe.value",
        "detail": "algorithms.algorithms.stack.stack",
        "documentation": {}
    },
    {
        "label": "first_stutter",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.stutter",
        "description": "algorithms.algorithms.stack.stutter",
        "peekOfCode": "def first_stutter(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack\ndef second_stutter(stack):",
        "detail": "algorithms.algorithms.stack.stutter",
        "documentation": {}
    },
    {
        "label": "second_stutter",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.stutter",
        "description": "algorithms.algorithms.stack.stutter",
        "peekOfCode": "def second_stutter(stack):\n    q = collections.deque()\n    # Put all values into queue from stack\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    # Put values back into stack from queue\n    for i in range(len(q)):\n        stack.append(q.pop())\n    # Now, stack is reverse, put all values into queue from stack\n    for i in range(len(stack)):",
        "detail": "algorithms.algorithms.stack.stutter",
        "documentation": {}
    },
    {
        "label": "first_switch_pairs",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.switch_pairs",
        "description": "algorithms.algorithms.stack.switch_pairs",
        "peekOfCode": "def first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:    # case: odd number of values in stack\n            stack.append(first)",
        "detail": "algorithms.algorithms.stack.switch_pairs",
        "documentation": {}
    },
    {
        "label": "second_switch_pairs",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.switch_pairs",
        "description": "algorithms.algorithms.stack.switch_pairs",
        "peekOfCode": "def second_switch_pairs(stack):\n    q = collections.deque()\n    # Put all values into queue from stack\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    # Put values back into stack from queue\n    for i in range(len(q)):\n        stack.append(q.pop())\n    # Now, stack is reverse, put all values into queue from stack\n    for i in range(len(stack)):",
        "detail": "algorithms.algorithms.stack.switch_pairs",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "kind": 2,
        "importPath": "algorithms.algorithms.stack.valid_parenthesis",
        "description": "algorithms.algorithms.stack.valid_parenthesis",
        "peekOfCode": "def is_valid(s: str) -> bool:\n    stack = []\n    dic = {\")\": \"(\",\n           \"}\": \"{\",\n           \"]\": \"[\"}\n    for char in s:\n        if char in dic.values():\n            stack.append(char)\n        elif char in dic:\n            if not stack or dic[char] != stack.pop():",
        "detail": "algorithms.algorithms.stack.valid_parenthesis",
        "documentation": {}
    },
    {
        "label": "misras_gries",
        "kind": 2,
        "importPath": "algorithms.algorithms.streaming.misra_gries",
        "description": "algorithms.algorithms.streaming.misra_gries",
        "peekOfCode": "def misras_gries(array,k=2):\n  keys = {}\n  for i in range(len(array)):\n    val = str(array[i])\n    if val in keys:\n      keys[val] = keys[val] + 1\n    elif len(keys) < k - 1:\n      keys[val] = 1\n    else:\n      for key in list(keys):",
        "detail": "algorithms.algorithms.streaming.misra_gries",
        "documentation": {}
    },
    {
        "label": "one_sparse",
        "kind": 2,
        "importPath": "algorithms.algorithms.streaming.one_sparse_recovery",
        "description": "algorithms.algorithms.streaming.one_sparse_recovery",
        "peekOfCode": "def one_sparse(array):\n  sum_signs = 0 \n  bitsum = [0]*32 \n  sum_values = 0 \n  for val,sign in array: \n    if sign == \"+\": \n      sum_signs += 1\n      sum_values += val\n    else:\n      sum_signs -= 1 ",
        "detail": "algorithms.algorithms.streaming.one_sparse_recovery",
        "documentation": {}
    },
    {
        "label": "add_binary",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.add_binary",
        "description": "algorithms.algorithms.strings.add_binary",
        "peekOfCode": "def add_binary(a, b):\n    s = \"\"\n    c, i, j = 0, len(a)-1, len(b)-1\n    zero = ord('0')\n    while (i >= 0 or j >= 0 or c == 1):\n        if (i >= 0):\n            c += ord(a[i]) - zero\n            i -= 1\n        if (j >= 0):\n            c += ord(b[j]) - zero",
        "detail": "algorithms.algorithms.strings.add_binary",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.add_binary",
        "description": "algorithms.algorithms.strings.add_binary",
        "peekOfCode": "a = \"11\"\nb = \"1\"\nReturn \"100\".\n\"\"\"\ndef add_binary(a, b):\n    s = \"\"\n    c, i, j = 0, len(a)-1, len(b)-1\n    zero = ord('0')\n    while (i >= 0 or j >= 0 or c == 1):\n        if (i >= 0):",
        "detail": "algorithms.algorithms.strings.add_binary",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.add_binary",
        "description": "algorithms.algorithms.strings.add_binary",
        "peekOfCode": "b = \"1\"\nReturn \"100\".\n\"\"\"\ndef add_binary(a, b):\n    s = \"\"\n    c, i, j = 0, len(a)-1, len(b)-1\n    zero = ord('0')\n    while (i >= 0 or j >= 0 or c == 1):\n        if (i >= 0):\n            c += ord(a[i]) - zero",
        "detail": "algorithms.algorithms.strings.add_binary",
        "documentation": {}
    },
    {
        "label": "atbash",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.atbash_cipher",
        "description": "algorithms.algorithms.strings.atbash_cipher",
        "peekOfCode": "def atbash(s):\n    translated = \"\"\n    for i in range(len(s)):\n        n = ord(s[i])\n        if s[i].isalpha():\n            if s[i].isupper():\n                x = n - ord('A')\n                translated += chr(ord('Z') - x)\n            if s[i].islower():\n                x = n - ord('a')",
        "detail": "algorithms.algorithms.strings.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.strings.breaking_bad",
        "description": "algorithms.algorithms.strings.breaking_bad",
        "peekOfCode": "class TreeNode:\n    def __init__(self):\n        self.c = dict()\n        self.sym = None\ndef bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:",
        "detail": "algorithms.algorithms.strings.breaking_bad",
        "documentation": {}
    },
    {
        "label": "match_symbol",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.breaking_bad",
        "description": "algorithms.algorithms.strings.breaking_bad",
        "peekOfCode": "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, \"[{}]\".format(s), c))\n    return combined\ndef match_symbol_1(words, symbols):",
        "detail": "algorithms.algorithms.strings.breaking_bad",
        "documentation": {}
    },
    {
        "label": "match_symbol_1",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.breaking_bad",
        "description": "algorithms.algorithms.strings.breaking_bad",
        "peekOfCode": "def match_symbol_1(words, symbols):\n    res = []\n    # reversely sort the symbols according to their lengths.\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            # once match, append the `word_replaced` to res, process next word\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')",
        "detail": "algorithms.algorithms.strings.breaking_bad",
        "documentation": {}
    },
    {
        "label": "bracket",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.breaking_bad",
        "description": "algorithms.algorithms.strings.breaking_bad",
        "peekOfCode": "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()",
        "detail": "algorithms.algorithms.strings.breaking_bad",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.caesar_cipher",
        "description": "algorithms.algorithms.strings.caesar_cipher",
        "peekOfCode": "def caesar_cipher(s, k):\n    result = \"\"\n    for char in s:\n        n = ord(char)\n        if 64 < n < 91:\n            n = ((n - 65 + k) % 26) + 65\n        if 96 < n < 123:\n            n = ((n - 97 + k) % 26) + 97\n        result = result + chr(n)\n    return result",
        "detail": "algorithms.algorithms.strings.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "check_pangram",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.check_pangram",
        "description": "algorithms.algorithms.strings.check_pangram",
        "peekOfCode": "def check_pangram(input_string):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True",
        "detail": "algorithms.algorithms.strings.check_pangram",
        "documentation": {}
    },
    {
        "label": "contain_string",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.contain_string",
        "description": "algorithms.algorithms.strings.contain_string",
        "peekOfCode": "def contain_string(haystack, needle):\n    if len(needle) == 0:\n        return 0\n    if len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack)):\n        if len(haystack) - i < len(needle):\n            return -1\n        if haystack[i:i+len(needle)] == needle:\n            return i",
        "detail": "algorithms.algorithms.strings.contain_string",
        "documentation": {}
    },
    {
        "label": "count_binary_substring",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.count_binary_substring",
        "description": "algorithms.algorithms.strings.count_binary_substring",
        "peekOfCode": "def count_binary_substring(s):\n    cur = 1\n    pre = 0\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            count = count + min(pre, cur)\n            pre = cur\n            cur = 1\n        else:",
        "detail": "algorithms.algorithms.strings.count_binary_substring",
        "documentation": {}
    },
    {
        "label": "decode_string",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.decode_string",
        "description": "algorithms.algorithms.strings.decode_string",
        "peekOfCode": "def decode_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    stack = []; cur_num = 0; cur_string = ''\n    for c in s:\n        if c == '[':\n            stack.append((cur_string, cur_num))\n            cur_string = ''",
        "detail": "algorithms.algorithms.strings.decode_string",
        "documentation": {}
    },
    {
        "label": "delete_reoccurring_characters",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.delete_reoccurring",
        "description": "algorithms.algorithms.strings.delete_reoccurring",
        "peekOfCode": "def delete_reoccurring_characters(string):\n    seen_characters = set()\n    output_string = ''\n    for char in string:\n        if char not in seen_characters:\n            seen_characters.add(char)\n            output_string += char\n    return output_string",
        "detail": "algorithms.algorithms.strings.delete_reoccurring",
        "documentation": {}
    },
    {
        "label": "domain_name_1",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.domain_extractor",
        "description": "algorithms.algorithms.strings.domain_extractor",
        "peekOfCode": "def domain_name_1(url):\n\t#grab only the non http(s) part\n    full_domain_name = url.split('//')[-1] \n    #grab the actual one depending on the len of the list  \n    actual_domain = full_domain_name.split('.')  \n    # case when www is in the url\n    if (len(actual_domain) > 2):\n        return actual_domain[1]    \n    # case when www is not in the url\n    return actual_domain[0]",
        "detail": "algorithms.algorithms.strings.domain_extractor",
        "documentation": {}
    },
    {
        "label": "domain_name_2",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.domain_extractor",
        "description": "algorithms.algorithms.strings.domain_extractor",
        "peekOfCode": "def domain_name_2(url):\n    return url.split(\"//\")[-1].split(\"www.\")[-1].split(\".\")[0]",
        "detail": "algorithms.algorithms.strings.domain_extractor",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.encode_decode",
        "description": "algorithms.algorithms.strings.encode_decode",
        "peekOfCode": "def encode(strs):\n    \"\"\"Encodes a list of strings to a single string.\n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + \":\" + string\n    return res\ndef decode(s):",
        "detail": "algorithms.algorithms.strings.encode_decode",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.encode_decode",
        "description": "algorithms.algorithms.strings.encode_decode",
        "peekOfCode": "def decode(s):\n    \"\"\"Decodes a single string to a list of strings.\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    strs = []\n    i = 0\n    while i < len(s):\n        index = s.find(\":\", i)\n        size = int(s[i:index])",
        "detail": "algorithms.algorithms.strings.encode_decode",
        "documentation": {}
    },
    {
        "label": "first_unique_char",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.first_unique_char",
        "description": "algorithms.algorithms.strings.first_unique_char",
        "peekOfCode": "def first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if (len(s) == 1):\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all(s[i] != s[k] for k in range(i + 1, len(s))) == True and s[i] not in ban:",
        "detail": "algorithms.algorithms.strings.first_unique_char",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.first_unique_char",
        "description": "algorithms.algorithms.strings.first_unique_char",
        "peekOfCode": "s = \"leetcode\"\nreturn 0.\ns = \"loveleetcode\",\nreturn 2.\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/\n\"\"\"\ndef first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int",
        "detail": "algorithms.algorithms.strings.first_unique_char",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.first_unique_char",
        "description": "algorithms.algorithms.strings.first_unique_char",
        "peekOfCode": "s = \"loveleetcode\",\nreturn 2.\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/\n\"\"\"\ndef first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if (len(s) == 1):",
        "detail": "algorithms.algorithms.strings.first_unique_char",
        "documentation": {}
    },
    {
        "label": "fizzbuzz",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.fizzbuzz",
        "description": "algorithms.algorithms.strings.fizzbuzz",
        "peekOfCode": "def fizzbuzz(n):\n    # Validate the input\n    if n < 1:\n        raise ValueError('n cannot be less than one')\n    if n is None:\n        raise TypeError('n cannot be None')\n    result = []\n    for i in range(1, n+1):\n        if i%3 == 0 and i%5 == 0:\n            result.append('FizzBuzz')",
        "detail": "algorithms.algorithms.strings.fizzbuzz",
        "documentation": {}
    },
    {
        "label": "fizzbuzz_with_helper_func",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.fizzbuzz",
        "description": "algorithms.algorithms.strings.fizzbuzz",
        "peekOfCode": "def fizzbuzz_with_helper_func(n):\n    return [fb(m) for m in range(1,n+1)]\ndef fb(m):\n    r = (m % 3 == 0) * \"Fizz\" + (m % 5 == 0) * \"Buzz\"\n    return r if r != \"\" else m",
        "detail": "algorithms.algorithms.strings.fizzbuzz",
        "documentation": {}
    },
    {
        "label": "fb",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.fizzbuzz",
        "description": "algorithms.algorithms.strings.fizzbuzz",
        "peekOfCode": "def fb(m):\n    r = (m % 3 == 0) * \"Fizz\" + (m % 5 == 0) * \"Buzz\"\n    return r if r != \"\" else m",
        "detail": "algorithms.algorithms.strings.fizzbuzz",
        "documentation": {}
    },
    {
        "label": "group_anagrams",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.group_anagrams",
        "description": "algorithms.algorithms.strings.group_anagrams",
        "peekOfCode": "def group_anagrams(strs):\n    d = {}\n    ans = []\n    k = 0\n    for str in strs:\n        sstr = ''.join(sorted(str))\n        if sstr not in d:\n            d[sstr] = k\n            k += 1\n            ans.append([])",
        "detail": "algorithms.algorithms.strings.group_anagrams",
        "documentation": {}
    },
    {
        "label": "int_to_roman",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.int_to_roman",
        "description": "algorithms.algorithms.strings.int_to_roman",
        "peekOfCode": "def int_to_roman(num):\n    \"\"\"\n    :type num: int\n    :rtype: str\n    \"\"\"\n    m = [\"\", \"M\", \"MM\", \"MMM\"];\n    c = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\n    x = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\n    i = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\n    return m[num//1000] + c[(num%1000)//100] + x[(num%100)//10] + i[num%10];",
        "detail": "algorithms.algorithms.strings.int_to_roman",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def is_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    i = 0\n    j = len(s)-1\n    while i < j:\n        while not s[i].isalnum():\n            i += 1",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "remove_punctuation",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def remove_punctuation(s):\n    \"\"\"\n    Remove punctuation, case sensitivity and spaces\n    \"\"\"\n    return \"\".join(i.lower() for i in s if i in ascii_letters)\n# Variation 1\ndef string_reverse(s):\n\treturn s[::-1]\ndef is_palindrome_reverse(s):\n\ts = remove_punctuation(s)",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "string_reverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def string_reverse(s):\n\treturn s[::-1]\ndef is_palindrome_reverse(s):\n\ts = remove_punctuation(s)\n\t# can also get rid of the string_reverse function and just do this return s == s[::-1] in one line.\n\tif (s == string_reverse(s)): \n\t\treturn True\n\treturn False\t\n# Variation 2\ndef is_palindrome_two_pointer(s):",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome_reverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def is_palindrome_reverse(s):\n\ts = remove_punctuation(s)\n\t# can also get rid of the string_reverse function and just do this return s == s[::-1] in one line.\n\tif (s == string_reverse(s)): \n\t\treturn True\n\treturn False\t\n# Variation 2\ndef is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s)//2):",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome_two_pointer",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s)//2):\n        if (s[i] != s[len(s) - i - 1]):\n            return False\n    return True\n# Variation 3\ndef is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome_stack",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n    for i in range(len(s)//2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s)//2):\n        if s[i] != stack.pop():\n            return False\n    return True\t\n# Variation 4 (using deque)",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome_deque",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "def is_palindrome_deque(s):\n    s = remove_punctuation(s)\n    deq = deque()\n    for char in s:\n        deq.appendleft(char)\n    equal = True\n    while len(deq) > 1 and equal:\n        first = deq.pop()\n        last = deq.popleft()\n        if first != last :",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "\ts",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.is_palindrome",
        "description": "algorithms.algorithms.strings.is_palindrome",
        "peekOfCode": "\ts = remove_punctuation(s)\n\t# can also get rid of the string_reverse function and just do this return s == s[::-1] in one line.\n\tif (s == string_reverse(s)): \n\t\treturn True\n\treturn False\t\n# Variation 2\ndef is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s)//2):\n        if (s[i] != s[len(s) - i - 1]):",
        "detail": "algorithms.algorithms.strings.is_palindrome",
        "documentation": {}
    },
    {
        "label": "is_rotated",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_rotated",
        "description": "algorithms.algorithms.strings.is_rotated",
        "peekOfCode": "def is_rotated(s1, s2):\n    if len(s1) == len(s2):\n        return s2 in s1 + s1\n    else:\n        return False\n\"\"\"\nAnother solution: brutal force\nComplexity: O(N^2)\n\"\"\"\ndef is_rotated_v1(s1, s2):",
        "detail": "algorithms.algorithms.strings.is_rotated",
        "documentation": {}
    },
    {
        "label": "is_rotated_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.is_rotated",
        "description": "algorithms.algorithms.strings.is_rotated",
        "peekOfCode": "def is_rotated_v1(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if len(s1) == 0:\n        return True\n    for c in range(len(s1)):\n        if all(s1[(c + i) % len(s1)] == s2[i] for i in range(len(s1))):\n            return True\n    return False",
        "detail": "algorithms.algorithms.strings.is_rotated",
        "documentation": {}
    },
    {
        "label": "judge_circle",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.judge_circle",
        "description": "algorithms.algorithms.strings.judge_circle",
        "peekOfCode": "def judge_circle(moves):\n    dict_moves = {\n        'U' : 0,\n        'D' : 0,\n        'R' : 0,\n        'L' : 0\n    }\n    for char in moves:\n        dict_moves[char] = dict_moves[char] + 1\n    return dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']",
        "detail": "algorithms.algorithms.strings.judge_circle",
        "documentation": {}
    },
    {
        "label": "knuth_morris_pratt",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.knuth_morris_pratt",
        "description": "algorithms.algorithms.strings.knuth_morris_pratt",
        "peekOfCode": "def knuth_morris_pratt(text, pattern):\n    n = len(text)\n    m = len(pattern)\n    pi = [0 for i in range(m)]\n    i = 0\n    j = 0\n    # making pi table\n    for i in range(1, m):\n        while j and pattern[i] != pattern[j]:\n            j = pi[j - 1]",
        "detail": "algorithms.algorithms.strings.knuth_morris_pratt",
        "documentation": {}
    },
    {
        "label": "license_number",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.license_number",
        "description": "algorithms.algorithms.strings.license_number",
        "peekOfCode": "def license_number(key, k):\n    res, alnum = [], []\n    for char in key:\n        if char != \"-\":\n            alnum.append(char)\n    for i, char in enumerate(reversed(alnum)):\n        res.append(char)\n        if (i+1) % k == 0 and i != len(alnum)-1:\n            res.append(\"-\")\n    return \"\".join(res[::-1])",
        "detail": "algorithms.algorithms.strings.license_number",
        "documentation": {}
    },
    {
        "label": "common_prefix",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.longest_common_prefix",
        "description": "algorithms.algorithms.strings.longest_common_prefix",
        "peekOfCode": "def common_prefix(s1, s2):\n    \"Return prefix common of 2 strings\"\n    if not s1 or not s2:\n        return \"\"\n    k = 0\n    while s1[k] == s2[k]:\n        k = k + 1\n        if k >= len(s1) or k >= len(s2):\n            return s1[0:k]\n    return s1[0:k]",
        "detail": "algorithms.algorithms.strings.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.longest_common_prefix",
        "description": "algorithms.algorithms.strings.longest_common_prefix",
        "peekOfCode": "def longest_common_prefix_v1(strs):\n    if not strs:\n        return \"\"\n    result = strs[0]\n    for i in range(len(strs)):\n        result = common_prefix(result, strs[i])\n    return result\n\"\"\"\nSecond solution: Vertical scanning\n\"\"\"",
        "detail": "algorithms.algorithms.strings.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.longest_common_prefix",
        "description": "algorithms.algorithms.strings.longest_common_prefix",
        "peekOfCode": "def longest_common_prefix_v2(strs):\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        for string in strs[1:]:\n            if i == len(string) or string[i] != strs[0][i]:\n                return strs[0][0:i]\n    return strs[0]\n\"\"\"\nThird solution: Divide and Conquer",
        "detail": "algorithms.algorithms.strings.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "longest_common_prefix_v3",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.longest_common_prefix",
        "description": "algorithms.algorithms.strings.longest_common_prefix",
        "peekOfCode": "def longest_common_prefix_v3(strs):\n    if not strs:\n        return \"\"\n    return longest_common(strs, 0, len(strs) -1)\ndef longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)",
        "detail": "algorithms.algorithms.strings.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "longest_common",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.longest_common_prefix",
        "description": "algorithms.algorithms.strings.longest_common_prefix",
        "peekOfCode": "def longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)\n    return common_prefix(lcp_left, lcp_right)",
        "detail": "algorithms.algorithms.strings.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "longest_palindrome",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.longest_palindromic_substring",
        "description": "algorithms.algorithms.strings.longest_palindromic_substring",
        "peekOfCode": "def longest_palindrome(s):\n    if len(s) < 2:\n        return s\n    n_str = '#' + '#'.join(s) + '#'\n    p = [0] * len(n_str)\n    mx, loc = 0, 0\n    index, maxlen = 0, 0\n    for i in range(len(n_str)):\n        if i < mx and 2 * loc - i < len(n_str):\n            p[i] = min(mx - i, p[2 * loc - i])",
        "detail": "algorithms.algorithms.strings.longest_palindromic_substring",
        "documentation": {}
    },
    {
        "label": "make_sentence",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.make_sentence",
        "description": "algorithms.algorithms.strings.make_sentence",
        "peekOfCode": "def make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        prefix, suffix = str_piece[0:i], str_piece[i:]\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True",
        "detail": "algorithms.algorithms.strings.make_sentence",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.make_sentence",
        "description": "algorithms.algorithms.strings.make_sentence",
        "peekOfCode": "count = 0\ndef make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        prefix, suffix = str_piece[0:i], str_piece[i:]\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1",
        "detail": "algorithms.algorithms.strings.make_sentence",
        "documentation": {}
    },
    {
        "label": "is_merge_recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.merge_string_checker",
        "description": "algorithms.algorithms.strings.merge_string_checker",
        "peekOfCode": "def is_merge_recursive(s, part1, part2):\n    if not part1:\n        return s == part2\n    if not part2:\n        return s == part1\n    if not s:\n        return part1 + part2 == ''\n    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):\n        return True\n    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):",
        "detail": "algorithms.algorithms.strings.merge_string_checker",
        "documentation": {}
    },
    {
        "label": "is_merge_iterative",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.merge_string_checker",
        "description": "algorithms.algorithms.strings.merge_string_checker",
        "peekOfCode": "def is_merge_iterative(s, part1, part2):\n    tuple_list = [(s, part1, part2)]\n    while tuple_list:\n        string, p1, p2 = tuple_list.pop()            \n        if string:\n            if p1 and string[0] == p1[0]:\n                tuple_list.append((string[1:], p1[1:], p2))\n            if p2 and string[0] == p2[0]:\n                tuple_list.append((string[1:], p1, p2[1:]))\n        else:",
        "detail": "algorithms.algorithms.strings.merge_string_checker",
        "documentation": {}
    },
    {
        "label": "min_distance",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.min_distance",
        "description": "algorithms.algorithms.strings.min_distance",
        "peekOfCode": "def min_distance(word1, word2):\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))\ndef lcs(s1, s2, i, j):\n    \"\"\"\n    The length of longest common subsequence among the two given strings s1 and s2\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    elif s1[i - 1] == s2[j - 1]:\n        return 1 + lcs(s1, s2, i - 1, j - 1)",
        "detail": "algorithms.algorithms.strings.min_distance",
        "documentation": {}
    },
    {
        "label": "lcs",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.min_distance",
        "description": "algorithms.algorithms.strings.min_distance",
        "peekOfCode": "def lcs(s1, s2, i, j):\n    \"\"\"\n    The length of longest common subsequence among the two given strings s1 and s2\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    elif s1[i - 1] == s2[j - 1]:\n        return 1 + lcs(s1, s2, i - 1, j - 1)\n    else:\n        return max(lcs(s1, s2, i - 1, j), lcs(s1, s2, i, j - 1))",
        "detail": "algorithms.algorithms.strings.min_distance",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.multiply_strings",
        "description": "algorithms.algorithms.strings.multiply_strings",
        "peekOfCode": "def multiply(num1: \"str\", num2: \"str\") -> \"str\":\n    interm = []\n    zero = ord('0')\n    i_pos = 1\n    for i in reversed(num1):\n        j_pos = 1\n        add = 0\n        for j in reversed(num2):\n            mult = (ord(i)-zero) * (ord(j)-zero) * j_pos * i_pos\n            j_pos *= 10",
        "detail": "algorithms.algorithms.strings.multiply_strings",
        "documentation": {}
    },
    {
        "label": "is_one_edit",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.one_edit_distance",
        "description": "algorithms.algorithms.strings.one_edit_distance",
        "peekOfCode": "def is_one_edit(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) > len(t):\n        return is_one_edit(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False",
        "detail": "algorithms.algorithms.strings.one_edit_distance",
        "documentation": {}
    },
    {
        "label": "is_one_edit2",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.one_edit_distance",
        "description": "algorithms.algorithms.strings.one_edit_distance",
        "peekOfCode": "def is_one_edit2(s, t):\n    l1, l2 = len(s), len(t)\n    if l1 > l2:\n        return is_one_edit2(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if l1 == l2:\n                s = s[:i]+t[i]+s[i+1:]  # modify",
        "detail": "algorithms.algorithms.strings.one_edit_distance",
        "documentation": {}
    },
    {
        "label": "panagram",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.panagram",
        "description": "algorithms.algorithms.strings.panagram",
        "peekOfCode": "def panagram(string):\n    \"\"\"\n    Returns whether the input string is an English panagram or not.\n        Parameters:\n            string (str): A sentence in the form of a string.\n        Returns:\n            A boolean with the result.\n    \"\"\"\n    letters = set(ascii_lowercase)\n    for c in string:",
        "detail": "algorithms.algorithms.strings.panagram",
        "documentation": {}
    },
    {
        "label": "RollingHash",
        "kind": 6,
        "importPath": "algorithms.algorithms.strings.rabin_karp",
        "description": "algorithms.algorithms.strings.rabin_karp",
        "peekOfCode": "class RollingHash:\n    def __init__(self, text, size_word):\n        self.text = text\n        self.hash = 0\n        self.size_word = size_word\n        for i in range(0, size_word):\n            #ord maps the character to a number\n            #subtract out the ASCII value of \"a\" to start the indexing at zero\n            self.hash += (ord(self.text[i]) - ord(\"a\")+1)*(26**(size_word - i -1))\n        #start index of current window",
        "detail": "algorithms.algorithms.strings.rabin_karp",
        "documentation": {}
    },
    {
        "label": "rabin_karp",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.rabin_karp",
        "description": "algorithms.algorithms.strings.rabin_karp",
        "peekOfCode": "def rabin_karp(word, text):\n    if word == \"\" or text == \"\":\n        return None\n    if len(word) > len(text):\n        return None\n    rolling_hash = RollingHash(text, len(word))\n    word_hash = RollingHash(word, len(word))\n    #word_hash.move_window()\n    for i in range(len(text) - len(word) + 1):\n        if rolling_hash.hash == word_hash.hash:",
        "detail": "algorithms.algorithms.strings.rabin_karp",
        "documentation": {}
    },
    {
        "label": "repeat_string",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.repeat_string",
        "description": "algorithms.algorithms.strings.repeat_string",
        "peekOfCode": "def repeat_string(A, B):\n    count = 1\n    tmp = A\n    max_count = (len(B) / len(A)) + 1\n    while not(B in tmp):\n        tmp = tmp + A\n        if (count > max_count):\n            count = -1\n            break\n        count = count + 1",
        "detail": "algorithms.algorithms.strings.repeat_string",
        "documentation": {}
    },
    {
        "label": "repeat_substring",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.repeat_substring",
        "description": "algorithms.algorithms.strings.repeat_substring",
        "peekOfCode": "def repeat_substring(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    str = (s + s)[1:-1]\n    return s in str",
        "detail": "algorithms.algorithms.strings.repeat_substring",
        "documentation": {}
    },
    {
        "label": "recursive",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_string",
        "description": "algorithms.algorithms.strings.reverse_string",
        "peekOfCode": "def recursive(s):\n    l = len(s)\n    if l < 2:\n        return s\n    return recursive(s[l//2:]) + recursive(s[:l//2])\ndef iterative(s):\n    r = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        r[i], r[j] = r[j], r[i]",
        "detail": "algorithms.algorithms.strings.reverse_string",
        "documentation": {}
    },
    {
        "label": "iterative",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_string",
        "description": "algorithms.algorithms.strings.reverse_string",
        "peekOfCode": "def iterative(s):\n    r = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        r[i], r[j] = r[j], r[i]\n        i += 1\n        j -= 1\n    return \"\".join(r)\ndef pythonic(s):\n    r = list(reversed(s))",
        "detail": "algorithms.algorithms.strings.reverse_string",
        "documentation": {}
    },
    {
        "label": "pythonic",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_string",
        "description": "algorithms.algorithms.strings.reverse_string",
        "peekOfCode": "def pythonic(s):\n    r = list(reversed(s))\n    return \"\".join(r)\ndef ultra_pythonic(s):\n    return s[::-1]",
        "detail": "algorithms.algorithms.strings.reverse_string",
        "documentation": {}
    },
    {
        "label": "ultra_pythonic",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_string",
        "description": "algorithms.algorithms.strings.reverse_string",
        "peekOfCode": "def ultra_pythonic(s):\n    return s[::-1]",
        "detail": "algorithms.algorithms.strings.reverse_string",
        "documentation": {}
    },
    {
        "label": "reverse_vowel",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_vowel",
        "description": "algorithms.algorithms.strings.reverse_vowel",
        "peekOfCode": "def reverse_vowel(s):\n    vowels = \"AEIOUaeiou\"\n    i, j = 0, len(s)-1\n    s = list(s)\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        s[i], s[j] = s[j], s[i]",
        "detail": "algorithms.algorithms.strings.reverse_vowel",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_words",
        "description": "algorithms.algorithms.strings.reverse_words",
        "peekOfCode": "def reverse(array, i, j):\n    while i < j:\n        array[i], array[j] = array[j], array[i]\n        i += 1\n        j -= 1\ndef reverse_words(string):\n    arr = string.strip().split()  # arr is list of words\n    n = len(arr)\n    reverse(arr, 0, n-1)\n    return \" \".join(arr)",
        "detail": "algorithms.algorithms.strings.reverse_words",
        "documentation": {}
    },
    {
        "label": "reverse_words",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.reverse_words",
        "description": "algorithms.algorithms.strings.reverse_words",
        "peekOfCode": "def reverse_words(string):\n    arr = string.strip().split()  # arr is list of words\n    n = len(arr)\n    reverse(arr, 0, n-1)\n    return \" \".join(arr)\nif __name__ == \"__main__\":\n    test = \"I am keon kim and I like pizza\"\n    print(test)\n    print(reverse_words(test))",
        "detail": "algorithms.algorithms.strings.reverse_words",
        "documentation": {}
    },
    {
        "label": "roman_to_int",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.roman_to_int",
        "description": "algorithms.algorithms.strings.roman_to_int",
        "peekOfCode": "def roman_to_int(s:\"str\")->\"int\":\n    number = 0\n    roman = {'M':1000, 'D':500, 'C': 100, 'L':50, 'X':10, 'V':5, 'I':1}\n    for i in range(len(s)-1):\n        if roman[s[i]] < roman[s[i+1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]\nif __name__ == \"__main__\":",
        "detail": "algorithms.algorithms.strings.roman_to_int",
        "documentation": {}
    },
    {
        "label": "rotate",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.rotate",
        "description": "algorithms.algorithms.strings.rotate",
        "peekOfCode": "def rotate(s, k):\n    long_string = s * (k // len(s) + 2)\n    if k <= len(s):\n        return long_string[k:k + len(s)]\n    else:\n        return long_string[k-len(s):k]\ndef rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]",
        "detail": "algorithms.algorithms.strings.rotate",
        "documentation": {}
    },
    {
        "label": "rotate_alt",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.rotate",
        "description": "algorithms.algorithms.strings.rotate",
        "peekOfCode": "def rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]",
        "detail": "algorithms.algorithms.strings.rotate",
        "documentation": {}
    },
    {
        "label": "strip_url_params1",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.strip_url_params",
        "description": "algorithms.algorithms.strings.strip_url_params",
        "peekOfCode": "def strip_url_params1(url, params_to_strip=None):\n    if not params_to_strip:\n        params_to_strip = []\n    if url:\n        result = '' # final result to be returned\n        tokens = url.split('?')\n        domain = tokens[0]\n        query_string = tokens[-1]\n        result += domain\n        # add the '?' to our result if it is in the url",
        "detail": "algorithms.algorithms.strings.strip_url_params",
        "documentation": {}
    },
    {
        "label": "strip_url_params2",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.strip_url_params",
        "description": "algorithms.algorithms.strings.strip_url_params",
        "peekOfCode": "def strip_url_params2(url, param_to_strip=[]):\n    if '?' not in url:\n        return url\n    queries = (url.split('?')[1]).split('&')\n    queries_obj = [query[0] for query in queries]\n    for i in range(len(queries_obj) - 1, 0, -1):\n        if queries_obj[i] in param_to_strip or queries_obj[i] in queries_obj[0:i]:\n            queries.pop(i)\n    return url.split('?')[0] + '?' + '&'.join(queries)\n# Here is my friend's solution using python's builtin libraries",
        "detail": "algorithms.algorithms.strings.strip_url_params",
        "documentation": {}
    },
    {
        "label": "strip_url_params3",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.strip_url_params",
        "description": "algorithms.algorithms.strings.strip_url_params",
        "peekOfCode": "def strip_url_params3(url, strip=None):\n    if not strip: strip = []\n    parse = urllib.parse.urlparse(url)\n    query = urllib.parse.parse_qs(parse.query)\n    query = {k: v[0] for k, v in query.items() if k not in strip}\n    query = urllib.parse.urlencode(query)\n    new = parse._replace(query=query)\n    return new.geturl()",
        "detail": "algorithms.algorithms.strings.strip_url_params",
        "documentation": {}
    },
    {
        "label": "strong_password",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.strong_password",
        "description": "algorithms.algorithms.strings.strong_password",
        "peekOfCode": "def strong_password(n, password):\n    count_error = 0\n    # Return the minimum number of characters to make the password strong\n    if any(i.isdigit() for i in password) == False:\n        count_error = count_error + 1\n    if any(i.islower() for i in password) == False:\n        count_error = count_error + 1\n    if any(i.isupper() for i in password) == False:\n        count_error = count_error + 1\n    if any(i in '!@#$%^&*()-+' for i in password) == False:",
        "detail": "algorithms.algorithms.strings.strong_password",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.strong_password",
        "description": "algorithms.algorithms.strings.strong_password",
        "peekOfCode": "numbers = \"0123456789\"\nlower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.",
        "detail": "algorithms.algorithms.strings.strong_password",
        "documentation": {}
    },
    {
        "label": "lower_case",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.strong_password",
        "description": "algorithms.algorithms.strings.strong_password",
        "peekOfCode": "lower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)",
        "detail": "algorithms.algorithms.strings.strong_password",
        "documentation": {}
    },
    {
        "label": "upper_case",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.strong_password",
        "description": "algorithms.algorithms.strings.strong_password",
        "peekOfCode": "upper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\nSample Output 2: strong_password(11,\"#Algorithms\")",
        "detail": "algorithms.algorithms.strings.strong_password",
        "documentation": {}
    },
    {
        "label": "special_characters",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.strong_password",
        "description": "algorithms.algorithms.strings.strong_password",
        "peekOfCode": "special_characters = \"!@#$%^&*()-+\"\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\nSample Output 2: strong_password(11,\"#Algorithms\")\nOutput: 1 (Because the password isn't strong, but she can make it strong by adding a single digit.)",
        "detail": "algorithms.algorithms.strings.strong_password",
        "documentation": {}
    },
    {
        "label": "text_justification",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.text_justification",
        "description": "algorithms.algorithms.strings.text_justification",
        "peekOfCode": "def text_justification(words, max_width):\n    '''\n    :type words: list\n    :type max_width: int\n    :rtype: list\n    '''\n    ret = []  # return value\n    row_len = 0  # current length of strs in a row\n    row_words = []  # current words in a row\n    index = 0  # the index of current word in words",
        "detail": "algorithms.algorithms.strings.text_justification",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.text_justification",
        "description": "algorithms.algorithms.strings.text_justification",
        "peekOfCode": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\"\"\"\ndef text_justification(words, max_width):",
        "detail": "algorithms.algorithms.strings.text_justification",
        "documentation": {}
    },
    {
        "label": "maxWidth",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.text_justification",
        "description": "algorithms.algorithms.strings.text_justification",
        "peekOfCode": "maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\"\"\"\ndef text_justification(words, max_width):\n    '''",
        "detail": "algorithms.algorithms.strings.text_justification",
        "documentation": {}
    },
    {
        "label": "convert_morse_word",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.unique_morse",
        "description": "algorithms.algorithms.strings.unique_morse",
        "peekOfCode": "def convert_morse_word(word):\n    morse_word = \"\"\n    word = word.lower()\n    for char in word:\n        morse_word = morse_word + morse_code[char]\n    return morse_word\ndef unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)",
        "detail": "algorithms.algorithms.strings.unique_morse",
        "documentation": {}
    },
    {
        "label": "unique_morse",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.unique_morse",
        "description": "algorithms.algorithms.strings.unique_morse",
        "peekOfCode": "def unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)\n        if morse_word not in unique_morse_word:\n            unique_morse_word.append(morse_word)\n    return len(unique_morse_word)",
        "detail": "algorithms.algorithms.strings.unique_morse",
        "documentation": {}
    },
    {
        "label": "morse_code",
        "kind": 5,
        "importPath": "algorithms.algorithms.strings.unique_morse",
        "description": "algorithms.algorithms.strings.unique_morse",
        "peekOfCode": "morse_code = {\n    'a':\".-\",\n    'b':\"-...\",\n    'c':\"-.-.\",\n    'd': \"-..\",\n    'e':\".\",\n    'f':\"..-.\",\n    'g':\"--.\",\n    'h':\"....\",\n    'i':\"..\",",
        "detail": "algorithms.algorithms.strings.unique_morse",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_0",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.validate_coordinates",
        "description": "algorithms.algorithms.strings.validate_coordinates",
        "peekOfCode": "def is_valid_coordinates_0(coordinates):\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(\", \")\n    if len(l) != 2:\n        return False\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])",
        "detail": "algorithms.algorithms.strings.validate_coordinates",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_1",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.validate_coordinates",
        "description": "algorithms.algorithms.strings.validate_coordinates",
        "peekOfCode": "def is_valid_coordinates_1(coordinates):\n    try:\n        lat, lng = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n    return lat <= 90 and lng <= 180\n# using regular expression\ndef is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match(\"-?(\\d|[1-8]\\d|90)\\.?\\d*, -?(\\d|[1-9]\\d|1[0-7]\\d|180)\\.?\\d*$\", coordinates))",
        "detail": "algorithms.algorithms.strings.validate_coordinates",
        "documentation": {}
    },
    {
        "label": "is_valid_coordinates_regular_expression",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.validate_coordinates",
        "description": "algorithms.algorithms.strings.validate_coordinates",
        "peekOfCode": "def is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match(\"-?(\\d|[1-8]\\d|90)\\.?\\d*, -?(\\d|[1-9]\\d|1[0-7]\\d|180)\\.?\\d*$\", coordinates))",
        "detail": "algorithms.algorithms.strings.validate_coordinates",
        "documentation": {}
    },
    {
        "label": "word_squares",
        "kind": 2,
        "importPath": "algorithms.algorithms.strings.word_squares",
        "description": "algorithms.algorithms.strings.word_squares",
        "peekOfCode": "def word_squares(words):\n    n = len(words[0])\n    fulls = collections.defaultdict(list)\n    for word in words:\n        for i in range(n):\n            fulls[word[:i]].append(word)\n    def build(square):\n        if len(square) == n:\n            squares.append(square)\n            return",
        "detail": "algorithms.algorithms.strings.word_squares",
        "documentation": {}
    },
    {
        "label": "AvlTree",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.avl.avl",
        "description": "algorithms.algorithms.tree.avl.avl",
        "peekOfCode": "class AvlTree(object):\n    \"\"\"\n    An avl tree.\n    \"\"\"\n    def __init__(self):\n        # Root node of the tree.\n        self.node = None\n        self.height = -1\n        self.balance = 0\n    def insert(self, key):",
        "detail": "algorithms.algorithms.tree.avl.avl",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.array_to_bst",
        "description": "algorithms.algorithms.tree.bst.array_to_bst",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\ndef array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums)//2\n    node = TreeNode(nums[mid])",
        "detail": "algorithms.algorithms.tree.bst.array_to_bst",
        "documentation": {}
    },
    {
        "label": "array_to_bst",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.array_to_bst",
        "description": "algorithms.algorithms.tree.bst.array_to_bst",
        "peekOfCode": "def array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums)//2\n    node = TreeNode(nums[mid])\n    node.left = array_to_bst(nums[:mid])\n    node.right = array_to_bst(nums[mid+1:])\n    return node",
        "detail": "algorithms.algorithms.tree.bst.array_to_bst",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.bst",
        "description": "algorithms.algorithms.tree.bst.bst",
        "peekOfCode": "class Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\nclass BST(object):\n    def __init__(self):\n        self.root = None\n    def get_root(self):\n        return self.root",
        "detail": "algorithms.algorithms.tree.bst.bst",
        "documentation": {}
    },
    {
        "label": "BST",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.bst",
        "description": "algorithms.algorithms.tree.bst.bst",
        "peekOfCode": "class BST(object):\n    def __init__(self):\n        self.root = None\n    def get_root(self):\n        return self.root\n    \"\"\"\n        Get the number of elements\n        Using recursion. Complexity O(logN)\n    \"\"\"\n    def size(self):",
        "detail": "algorithms.algorithms.tree.bst.bst",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.bst",
        "description": "algorithms.algorithms.tree.bst.bst",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = BST()\n        self.tree.insert(10)\n        self.tree.insert(15)\n        self.tree.insert(6)\n        self.tree.insert(4)\n        self.tree.insert(9)\n        self.tree.insert(12)\n        self.tree.insert(24)",
        "detail": "algorithms.algorithms.tree.bst.bst",
        "documentation": {}
    },
    {
        "label": "BSTIterator",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.BSTIterator",
        "description": "algorithms.algorithms.tree.bst.BSTIterator",
        "peekOfCode": "class BSTIterator:\n    def __init__(self, root):\n        self.stack = []\n        while root:\n            self.stack.append(root)\n            root = root.left\n    def has_next(self):\n        return bool(self.stack)\n    def next(self):\n        node = self.stack.pop()",
        "detail": "algorithms.algorithms.tree.bst.BSTIterator",
        "documentation": {}
    },
    {
        "label": "closest_value",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.bst_closest_value",
        "description": "algorithms.algorithms.tree.bst.bst_closest_value",
        "peekOfCode": "def closest_value(root, target):\n    \"\"\"\n    :type root: TreeNode\n    :type target: float\n    :rtype: int\n    \"\"\"\n    a = root.val\n    kid = root.left if target < a else root.right\n    if not kid:\n        return a",
        "detail": "algorithms.algorithms.tree.bst.bst_closest_value",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.count_left_node",
        "description": "algorithms.algorithms.tree.bst.count_left_node",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)",
        "detail": "algorithms.algorithms.tree.bst.count_left_node",
        "documentation": {}
    },
    {
        "label": "count_left_node",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.count_left_node",
        "description": "algorithms.algorithms.tree.bst.count_left_node",
        "peekOfCode": "def count_left_node(root):\n    if root is None:\n        return 0\n    elif root.left is None:\n        return count_left_node(root.right)\n    else:\n        return 1 + count_left_node(root.left) + count_left_node(root.right)\n\"\"\"\n    The tree is created for testing:\n                    9",
        "detail": "algorithms.algorithms.tree.bst.count_left_node",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.delete_node",
        "description": "algorithms.algorithms.tree.bst.delete_node",
        "peekOfCode": "class Solution(object):\n    def delete_node(self, root, key):\n        \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root: return None\n        if root.val == key:\n            if root.left:",
        "detail": "algorithms.algorithms.tree.bst.delete_node",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.bst.delete_node",
        "description": "algorithms.algorithms.tree.bst.delete_node",
        "peekOfCode": "root = [5,3,6,2,4,null,7]\nkey = 3\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\nGiven key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n    5",
        "detail": "algorithms.algorithms.tree.bst.delete_node",
        "documentation": {}
    },
    {
        "label": "key",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.bst.delete_node",
        "description": "algorithms.algorithms.tree.bst.delete_node",
        "peekOfCode": "key = 3\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\nGiven key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n    5\n   / \\",
        "detail": "algorithms.algorithms.tree.bst.delete_node",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.depth_sum",
        "description": "algorithms.algorithms.tree.bst.depth_sum",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)",
        "detail": "algorithms.algorithms.tree.bst.depth_sum",
        "documentation": {}
    },
    {
        "label": "depth_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.depth_sum",
        "description": "algorithms.algorithms.tree.bst.depth_sum",
        "peekOfCode": "def depth_sum(root, n):\n    if root:\n        return recur_depth_sum(root, 1)\ndef recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n+1) + recur_depth_sum(root.right, n+1)",
        "detail": "algorithms.algorithms.tree.bst.depth_sum",
        "documentation": {}
    },
    {
        "label": "recur_depth_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.depth_sum",
        "description": "algorithms.algorithms.tree.bst.depth_sum",
        "peekOfCode": "def recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n+1) + recur_depth_sum(root.right, n+1)\n\"\"\"\n    The tree is created for testing:\n                    9",
        "detail": "algorithms.algorithms.tree.bst.depth_sum",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.height",
        "description": "algorithms.algorithms.tree.bst.height",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)",
        "detail": "algorithms.algorithms.tree.bst.height",
        "documentation": {}
    },
    {
        "label": "height",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.height",
        "description": "algorithms.algorithms.tree.bst.height",
        "peekOfCode": "def height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))\n\"\"\"\n    The tree is created for testing:\n                    9\n                 /      \\\n               6         12",
        "detail": "algorithms.algorithms.tree.bst.height",
        "documentation": {}
    },
    {
        "label": "is_bst",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.is_bst",
        "description": "algorithms.algorithms.tree.bst.is_bst",
        "peekOfCode": "def is_bst(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    stack = []\n    pre = None\n    while root or stack:\n        while root:\n            stack.append(root)",
        "detail": "algorithms.algorithms.tree.bst.is_bst",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.kth_smallest",
        "description": "algorithms.algorithms.tree.bst.kth_smallest",
        "peekOfCode": "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef kth_smallest(root, k):\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)",
        "detail": "algorithms.algorithms.tree.bst.kth_smallest",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.kth_smallest",
        "description": "algorithms.algorithms.tree.bst.kth_smallest",
        "peekOfCode": "class Solution(object):\n    def kth_smallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        count = []\n        self.helper(root, count)\n        return count[k-1]",
        "detail": "algorithms.algorithms.tree.bst.kth_smallest",
        "documentation": {}
    },
    {
        "label": "kth_smallest",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.kth_smallest",
        "description": "algorithms.algorithms.tree.bst.kth_smallest",
        "peekOfCode": "def kth_smallest(root, k):\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            break",
        "detail": "algorithms.algorithms.tree.bst.kth_smallest",
        "documentation": {}
    },
    {
        "label": "lowest_common_ancestor",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.lowest_common_ancestor",
        "description": "algorithms.algorithms.tree.bst.lowest_common_ancestor",
        "peekOfCode": "def lowest_common_ancestor(root, p, q):\n    \"\"\"\n    :type root: Node\n    :type p: Node\n    :type q: Node\n    :rtype: Node\n    \"\"\"\n    while root:\n        if p.val > root.val < q.val:\n            root = root.right",
        "detail": "algorithms.algorithms.tree.bst.lowest_common_ancestor",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.num_empty",
        "description": "algorithms.algorithms.tree.bst.num_empty",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)",
        "detail": "algorithms.algorithms.tree.bst.num_empty",
        "documentation": {}
    },
    {
        "label": "num_empty",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.num_empty",
        "description": "algorithms.algorithms.tree.bst.num_empty",
        "peekOfCode": "def num_empty(root):\n    if root is None:\n        return 1\n    elif root.left is None and root.right:\n        return 1 + num_empty(root.right)\n    elif root.right is None and root.left:\n        return 1 + num_empty(root.left)\n    else:\n        return num_empty(root.left) + num_empty(root.right)\n\"\"\"",
        "detail": "algorithms.algorithms.tree.bst.num_empty",
        "documentation": {}
    },
    {
        "label": "predecessor",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.predecessor",
        "description": "algorithms.algorithms.tree.bst.predecessor",
        "peekOfCode": "def predecessor(root, node):\n    pred = None\n    while root:\n        if node.val > root.val:\n            pred = root\n            root = root.right\n        else:\n            root = root.left\n    return pred",
        "detail": "algorithms.algorithms.tree.bst.predecessor",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "description": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\ndef serialize(root):\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)",
        "detail": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "documentation": {}
    },
    {
        "label": "serialize",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "description": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "peekOfCode": "def serialize(root):\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)\n            build_string(node.right)\n        else:\n            vals.append(\"#\")\n    vals = []\n    build_string(root)",
        "detail": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "documentation": {}
    },
    {
        "label": "deserialize",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "description": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "peekOfCode": "def deserialize(data):\n    def build_tree():\n        val = next(vals)\n        if val == \"#\":\n            return None\n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    vals = iter(data.split())",
        "detail": "algorithms.algorithms.tree.bst.serialize_deserialize",
        "documentation": {}
    },
    {
        "label": "successor",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.successor",
        "description": "algorithms.algorithms.tree.bst.successor",
        "peekOfCode": "def successor(root, node):\n    succ = None\n    while root:\n        if node.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ",
        "detail": "algorithms.algorithms.tree.bst.successor",
        "documentation": {}
    },
    {
        "label": "num_trees",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bst.unique_bst",
        "description": "algorithms.algorithms.tree.bst.unique_bst",
        "peekOfCode": "def num_trees(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        for j in range(i+1):",
        "detail": "algorithms.algorithms.tree.bst.unique_bst",
        "documentation": {}
    },
    {
        "label": "F(n)",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.bst.unique_bst",
        "description": "algorithms.algorithms.tree.bst.unique_bst",
        "peekOfCode": "F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0)\n\"\"\"\ndef num_trees(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1",
        "detail": "algorithms.algorithms.tree.bst.unique_bst",
        "documentation": {}
    },
    {
        "label": "Fenwick_Tree",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.fenwick_tree.fenwick_tree",
        "description": "algorithms.algorithms.tree.fenwick_tree.fenwick_tree",
        "peekOfCode": "class Fenwick_Tree(object):\n    def __init__(self, freq):\n        self.arr = freq\n        self.n = len(freq)\n    def get_sum(self, bit_tree, i):\n        \"\"\"\n             Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. \n        \"\"\"\n        s = 0\n        # index in bit_tree[] is 1 more than the index in arr[] ",
        "detail": "algorithms.algorithms.tree.fenwick_tree.fenwick_tree",
        "documentation": {}
    },
    {
        "label": "RBNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.red_black_tree.red_black_tree",
        "description": "algorithms.algorithms.tree.red_black_tree.red_black_tree",
        "peekOfCode": "class RBNode:\n    def __init__(self, val, is_red, parent=None, left=None, right=None):\n        self.val = val\n        self.parent = parent\n        self.left = left\n        self.right = right\n        self.color = is_red\nclass RBTree:\n    def __init__(self):\n        self.root = None",
        "detail": "algorithms.algorithms.tree.red_black_tree.red_black_tree",
        "documentation": {}
    },
    {
        "label": "RBTree",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.red_black_tree.red_black_tree",
        "description": "algorithms.algorithms.tree.red_black_tree.red_black_tree",
        "peekOfCode": "class RBTree:\n    def __init__(self):\n        self.root = None\n    def left_rotate(self, node):\n        # set the node as the left child node of the current node's right node\n        right_node = node.right\n        if right_node is None:\n            return\n        else:\n            # right node's left node become the right node of current node",
        "detail": "algorithms.algorithms.tree.red_black_tree.red_black_tree",
        "documentation": {}
    },
    {
        "label": "SegmentTree",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "peekOfCode": "class SegmentTree:\n    def __init__(self, arr, function):\n        self.tree = [None for _ in range(len(arr))] + arr\n        self.size = len(arr)\n        self.fn = function\n        self.build_tree()\n    def build_tree(self):\n        for i in range(self.size - 1, 0, -1):\n            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])\n    def update(self, p, v):",
        "detail": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "mytree",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "peekOfCode": "mytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))",
        "detail": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "mytree",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "peekOfCode": "mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ...\n\"\"\"\nclass SegmentTree:",
        "detail": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "mytree",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "peekOfCode": "mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ...\n\"\"\"\nclass SegmentTree:\n    def __init__(self, arr, function):\n        self.tree = [None for _ in range(len(arr))] + arr\n        self.size = len(arr)\n        self.fn = function",
        "detail": "algorithms.algorithms.tree.segment_tree.iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "SegmentTree",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "peekOfCode": "class SegmentTree:\n    def __init__(self,arr,function):\n        self.segment = [0 for x in range(3*len(arr)+3)]\n        self.arr = arr\n        self.fn = function\n        self.maketree(0,0,len(arr)-1)\n    def make_tree(self,i,l,r):\n        if l==r:\n            self.segment[i] = self.arr[l]\n        elif l<r:",
        "detail": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "documentation": {}
    },
    {
        "label": "mytree",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "peekOfCode": "mytree = SegmentTree([2,4,5,3,4],max)\nmytree.query(2,4)\nmytree.query(0,3) ...\nmytree = SegmentTree([4,5,2,3,4,43,3],sum)\nmytree.query(1,8)\n...\n'''",
        "detail": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "documentation": {}
    },
    {
        "label": "mytree",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "description": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "peekOfCode": "mytree = SegmentTree([4,5,2,3,4,43,3],sum)\nmytree.query(1,8)\n...\n'''",
        "detail": "algorithms.algorithms.tree.segment_tree.segment_tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.traversal.inorder",
        "description": "algorithms.algorithms.tree.traversal.inorder",
        "peekOfCode": "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef inorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []",
        "detail": "algorithms.algorithms.tree.traversal.inorder",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.inorder",
        "description": "algorithms.algorithms.tree.traversal.inorder",
        "peekOfCode": "def inorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()",
        "detail": "algorithms.algorithms.tree.traversal.inorder",
        "documentation": {}
    },
    {
        "label": "inorder_rec",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.inorder",
        "description": "algorithms.algorithms.tree.traversal.inorder",
        "peekOfCode": "def inorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None: \n        res = []\n    inorder_rec(root.left, res)\n    res.append(root.val)\n    inorder_rec(root.right, res)\n    return res\nif __name__ == '__main__':",
        "detail": "algorithms.algorithms.tree.traversal.inorder",
        "documentation": {}
    },
    {
        "label": "level_order",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.level_order",
        "description": "algorithms.algorithms.tree.traversal.level_order",
        "peekOfCode": "def level_order(root):\n    ans = []\n    if not root:\n        return ans\n    level = [root]\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)",
        "detail": "algorithms.algorithms.tree.traversal.level_order",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.traversal.postorder",
        "description": "algorithms.algorithms.tree.traversal.postorder",
        "peekOfCode": "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res",
        "detail": "algorithms.algorithms.tree.traversal.postorder",
        "documentation": {}
    },
    {
        "label": "postorder",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.postorder",
        "description": "algorithms.algorithms.tree.traversal.postorder",
        "peekOfCode": "def postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)",
        "detail": "algorithms.algorithms.tree.traversal.postorder",
        "documentation": {}
    },
    {
        "label": "postorder_rec",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.postorder",
        "description": "algorithms.algorithms.tree.traversal.postorder",
        "peekOfCode": "def postorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    postorder_rec(root.left, res)\n    postorder_rec(root.right, res)\n    res.append(root.val)\n    return res",
        "detail": "algorithms.algorithms.tree.traversal.postorder",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.traversal.preorder",
        "description": "algorithms.algorithms.tree.traversal.preorder",
        "peekOfCode": "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef preorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []",
        "detail": "algorithms.algorithms.tree.traversal.preorder",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.preorder",
        "description": "algorithms.algorithms.tree.traversal.preorder",
        "peekOfCode": "def preorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res.append(root.val)\n        if root.right:",
        "detail": "algorithms.algorithms.tree.traversal.preorder",
        "documentation": {}
    },
    {
        "label": "preorder_rec",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.preorder",
        "description": "algorithms.algorithms.tree.traversal.preorder",
        "peekOfCode": "def preorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    res.append(root.val)\n    preorder_rec(root.left, res)\n    preorder_rec(root.right, res)\n    return res",
        "detail": "algorithms.algorithms.tree.traversal.preorder",
        "documentation": {}
    },
    {
        "label": "zigzag_level",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.traversal.zigzag",
        "description": "algorithms.algorithms.tree.traversal.zigzag",
        "peekOfCode": "def zigzag_level(root):\n    res = []\n    if not root:\n        return res\n    level = [root]\n    flag = 1\n    while level:\n        current = []\n        new_level = []\n        for node in level:",
        "detail": "algorithms.algorithms.tree.traversal.zigzag",
        "documentation": {}
    },
    {
        "label": "TrieNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.trie.add_and_search",
        "description": "algorithms.algorithms.tree.trie.add_and_search",
        "peekOfCode": "class TrieNode(object):\n    def __init__(self, letter, is_terminal=False):\n        self.children = dict()\n        self.letter = letter\n        self.is_terminal = is_terminal\nclass WordDictionary(object):\n    def __init__(self):\n        self.root = TrieNode(\"\")\n    def add_word(self, word):\n        cur = self.root",
        "detail": "algorithms.algorithms.tree.trie.add_and_search",
        "documentation": {}
    },
    {
        "label": "WordDictionary",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.trie.add_and_search",
        "description": "algorithms.algorithms.tree.trie.add_and_search",
        "peekOfCode": "class WordDictionary(object):\n    def __init__(self):\n        self.root = TrieNode(\"\")\n    def add_word(self, word):\n        cur = self.root\n        for letter in word:\n            if letter not in cur.children:\n                cur.children[letter] = TrieNode(letter)\n            cur = cur.children[letter]\n        cur.is_terminal = True",
        "detail": "algorithms.algorithms.tree.trie.add_and_search",
        "documentation": {}
    },
    {
        "label": "WordDictionary2",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.trie.add_and_search",
        "description": "algorithms.algorithms.tree.trie.add_and_search",
        "peekOfCode": "class WordDictionary2(object):\n    def __init__(self):\n        self.word_dict = collections.defaultdict(list)\n    def add_word(self, word):\n        if word:\n            self.word_dict[len(word)].append(word)\n    def search(self, word):\n        if not word:\n            return False\n        if '.' not in word:",
        "detail": "algorithms.algorithms.tree.trie.add_and_search",
        "documentation": {}
    },
    {
        "label": "TrieNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.trie.trie",
        "description": "algorithms.algorithms.tree.trie.trie",
        "peekOfCode": "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        current = self.root\n        for letter in word:",
        "detail": "algorithms.algorithms.tree.trie.trie",
        "documentation": {}
    },
    {
        "label": "Trie",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.trie.trie",
        "description": "algorithms.algorithms.tree.trie.trie",
        "peekOfCode": "class Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        current = self.root\n        for letter in word:\n            current = current.children[letter]\n        current.is_word = True\n    def search(self, word):\n        current = self.root",
        "detail": "algorithms.algorithms.tree.trie.trie",
        "documentation": {}
    },
    {
        "label": "binary_tree_paths",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.binary_tree_paths",
        "description": "algorithms.algorithms.tree.binary_tree_paths",
        "peekOfCode": "def binary_tree_paths(root):\n    res = []\n    if root is None:\n        return res\n    dfs(res, root, str(root.val))\n    return res\ndef dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:",
        "detail": "algorithms.algorithms.tree.binary_tree_paths",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.binary_tree_paths",
        "description": "algorithms.algorithms.tree.binary_tree_paths",
        "peekOfCode": "def dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:\n        dfs(res, root.left, cur+'->'+str(root.left.val))\n    if root.right:\n        dfs(res, root.right, cur+'->'+str(root.right.val))",
        "detail": "algorithms.algorithms.tree.binary_tree_paths",
        "documentation": {}
    },
    {
        "label": "bin_tree_to_list",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bin_tree_to_list",
        "description": "algorithms.algorithms.tree.bin_tree_to_list",
        "peekOfCode": "def bin_tree_to_list(root):\n    \"\"\"\n    type root: root class\n    \"\"\"\n    if not root:\n        return root\n    root = bin_tree_to_list_util(root)\n    while root.left:\n        root = root.left\n    return root",
        "detail": "algorithms.algorithms.tree.bin_tree_to_list",
        "documentation": {}
    },
    {
        "label": "bin_tree_to_list_util",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bin_tree_to_list",
        "description": "algorithms.algorithms.tree.bin_tree_to_list",
        "peekOfCode": "def bin_tree_to_list_util(root):\n    if not root:\n        return root\n    if root.left:\n        left = bin_tree_to_list_util(root.left)\n        while left.right:\n            left = left.right\n        left.right = root\n        root.left = left\n    if root.right:",
        "detail": "algorithms.algorithms.tree.bin_tree_to_list",
        "documentation": {}
    },
    {
        "label": "print_tree",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.bin_tree_to_list",
        "description": "algorithms.algorithms.tree.bin_tree_to_list",
        "peekOfCode": "def print_tree(root):\n    while root:\n        print(root.val)\n        root = root.right",
        "detail": "algorithms.algorithms.tree.bin_tree_to_list",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.b_tree",
        "description": "algorithms.algorithms.tree.b_tree",
        "peekOfCode": "class Node:\n    def __init__(self):\n        # self.is_leaf = is_leaf\n        self.keys = []\n        self.children = []\n    def __repr__(self):\n        return \"<id_node: {0}>\".format(self.keys)\n    @property\n    def is_leaf(self):\n        return len(self.children) == 0",
        "detail": "algorithms.algorithms.tree.b_tree",
        "documentation": {}
    },
    {
        "label": "BTree",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.b_tree",
        "description": "algorithms.algorithms.tree.b_tree",
        "peekOfCode": "class BTree:\n    def __init__(self, t=2):\n        self.min_numbers_of_keys = t - 1\n        self.max_number_of_keys = 2 * t - 1\n        self.root = Node()\n    def _split_child(self, parent: Node, child_index: int):\n        new_right_child = Node()\n        half_max = self.max_number_of_keys // 2\n        child = parent.children[child_index]\n        middle_key = child.keys[half_max]",
        "detail": "algorithms.algorithms.tree.b_tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "description": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\npre_index = 0\ndef construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        preIndex is a global variable that keeps track of the index in preorder",
        "detail": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "documentation": {}
    },
    {
        "label": "construct_tree_util",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "description": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "peekOfCode": "def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        preIndex is a global variable that keeps track of the index in preorder\n        array.\n        preorder and postorder array are represented are pre[] and post[] respectively.\n        low and high are the indices for the postorder array.\n    \"\"\"\n    global pre_index\n    if pre_index == -1:",
        "detail": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "documentation": {}
    },
    {
        "label": "construct_tree",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "description": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "peekOfCode": "def construct_tree(pre: list, post: list, size: int):\n    \"\"\"\n        Main Function that will construct the full binary tree from given preorder\n        and postorder array.\n    \"\"\"\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size-1, size)\n    return print_inorder(root)\ndef print_inorder(root: TreeNode, result = None):\n    \"\"\"",
        "detail": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "documentation": {}
    },
    {
        "label": "print_inorder",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "description": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "peekOfCode": "def print_inorder(root: TreeNode, result = None):\n    \"\"\"\n        Prints the tree constructed in inorder format\n    \"\"\"\n    if root is None:\n        return []\n    if result is None: \n        result = []\n    print_inorder(root.left, result)\n    result.append(root.val)",
        "detail": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "documentation": {}
    },
    {
        "label": "pre_index",
        "kind": 5,
        "importPath": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "description": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "peekOfCode": "pre_index = 0\ndef construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        preIndex is a global variable that keeps track of the index in preorder\n        array.\n        preorder and postorder array are represented are pre[] and post[] respectively.\n        low and high are the indices for the postorder array.\n    \"\"\"\n    global pre_index",
        "detail": "algorithms.algorithms.tree.construct_tree_postorder_preorder",
        "documentation": {}
    },
    {
        "label": "DeepestLeft",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.deepest_left",
        "description": "algorithms.algorithms.tree.deepest_left",
        "peekOfCode": "class DeepestLeft:\n    def __init__(self):\n        self.depth = 0\n        self.Node = None\ndef find_deepest_left(root, is_left, depth, res):\n    if not root:\n        return\n    if is_left and depth > res.depth:\n        res.depth = depth\n        res.Node = root",
        "detail": "algorithms.algorithms.tree.deepest_left",
        "documentation": {}
    },
    {
        "label": "find_deepest_left",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.deepest_left",
        "description": "algorithms.algorithms.tree.deepest_left",
        "peekOfCode": "def find_deepest_left(root, is_left, depth, res):\n    if not root:\n        return\n    if is_left and depth > res.depth:\n        res.depth = depth\n        res.Node = root\n    find_deepest_left(root.left, True, depth + 1, res)\n    find_deepest_left(root.right, False, depth + 1, res)\nif __name__ == '__main__':\n    root = TreeNode(1)",
        "detail": "algorithms.algorithms.tree.deepest_left",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.invert_tree",
        "description": "algorithms.algorithms.tree.invert_tree",
        "peekOfCode": "def reverse(root):\n    if root is None:\n        return\n    root.left, root.right = root.right, root.left\n    if root.left:\n        reverse(root.left)\n    if root.right:\n        reverse(root.right)",
        "detail": "algorithms.algorithms.tree.invert_tree",
        "documentation": {}
    },
    {
        "label": "is_balanced",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.is_balanced",
        "description": "algorithms.algorithms.tree.is_balanced",
        "peekOfCode": "def is_balanced(root):\n    return __is_balanced_recursive(root)\ndef __is_balanced_recursive(root):\n    \"\"\"\n    O(N) solution\n    \"\"\"\n    return -1 != __get_depth(root)\ndef __get_depth(root):\n    \"\"\"\n    return 0 if unbalanced else depth + 1",
        "detail": "algorithms.algorithms.tree.is_balanced",
        "documentation": {}
    },
    {
        "label": "is_subtree",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.is_subtree",
        "description": "algorithms.algorithms.tree.is_subtree",
        "peekOfCode": "def is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:",
        "detail": "algorithms.algorithms.tree.is_subtree",
        "documentation": {}
    },
    {
        "label": "comp",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.is_subtree",
        "description": "algorithms.algorithms.tree.is_subtree",
        "peekOfCode": "def comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left,q.left) and comp(p.right, q.right)\n    return False",
        "detail": "algorithms.algorithms.tree.is_subtree",
        "documentation": {}
    },
    {
        "label": "is_symmetric",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.is_symmetric",
        "description": "algorithms.algorithms.tree.is_symmetric",
        "peekOfCode": "def is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)\ndef helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)",
        "detail": "algorithms.algorithms.tree.is_symmetric",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.is_symmetric",
        "description": "algorithms.algorithms.tree.is_symmetric",
        "peekOfCode": "def helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)\ndef is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]",
        "detail": "algorithms.algorithms.tree.is_symmetric",
        "documentation": {}
    },
    {
        "label": "is_symmetric_iterative",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.is_symmetric",
        "description": "algorithms.algorithms.tree.is_symmetric",
        "peekOfCode": "def is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        left, right = stack.pop()  # popleft\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False",
        "detail": "algorithms.algorithms.tree.is_symmetric",
        "documentation": {}
    },
    {
        "label": "longest_consecutive",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.longest_consecutive",
        "description": "algorithms.algorithms.tree.longest_consecutive",
        "peekOfCode": "def longest_consecutive(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    max_len = 0\n    dfs(root, 0, root.val, max_len)\n    return max_len",
        "detail": "algorithms.algorithms.tree.longest_consecutive",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.longest_consecutive",
        "description": "algorithms.algorithms.tree.longest_consecutive",
        "peekOfCode": "def dfs(root, cur, target, max_len):\n    if root is None:\n        return\n    if root.val == target:\n        cur += 1\n    else:\n        cur = 1\n    max_len = max(cur, max_len)\n    dfs(root.left, cur, root.val+1, max_len)\n    dfs(root.right, cur, root.val+1, max_len)",
        "detail": "algorithms.algorithms.tree.longest_consecutive",
        "documentation": {}
    },
    {
        "label": "lca",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.lowest_common_ancestor",
        "description": "algorithms.algorithms.tree.lowest_common_ancestor",
        "peekOfCode": "def lca(root, p, q):\n    \"\"\"\n    :type root: TreeNode\n    :type p: TreeNode\n    :type q: TreeNode\n    :rtype: TreeNode\n    \"\"\"\n    if root is None or root is p or root is q:\n        return root\n    left = lca(root.left, p, q)",
        "detail": "algorithms.algorithms.tree.lowest_common_ancestor",
        "documentation": {}
    },
    {
        "label": "max_height",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.max_height",
        "description": "algorithms.algorithms.tree.max_height",
        "peekOfCode": "def max_height(root):\n    if root is None:\n        return 0\n    height = 0\n    queue = [root]\n    while queue:\n        height += 1\n        level = []\n        while queue:\n            node = queue.pop(0)",
        "detail": "algorithms.algorithms.tree.max_height",
        "documentation": {}
    },
    {
        "label": "print_tree",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.max_height",
        "description": "algorithms.algorithms.tree.max_height",
        "peekOfCode": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)\nif __name__ == '__main__':\n    tree = TreeNode(10)\n    tree.left = TreeNode(12)\n    tree.right = TreeNode(15)\n    tree.left.left = TreeNode(25)",
        "detail": "algorithms.algorithms.tree.max_height",
        "documentation": {}
    },
    {
        "label": "max_path_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.max_path_sum",
        "description": "algorithms.algorithms.tree.max_path_sum",
        "peekOfCode": "def max_path_sum(root):\n    maximum = float(\"-inf\")\n    helper(root, maximum)\n    return maximum\ndef helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left+right+root.val)",
        "detail": "algorithms.algorithms.tree.max_path_sum",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.max_path_sum",
        "description": "algorithms.algorithms.tree.max_path_sum",
        "peekOfCode": "def helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left+right+root.val)\n    return root.val + maximum",
        "detail": "algorithms.algorithms.tree.max_path_sum",
        "documentation": {}
    },
    {
        "label": "min_depth",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.min_height",
        "description": "algorithms.algorithms.tree.min_height",
        "peekOfCode": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1",
        "detail": "algorithms.algorithms.tree.min_height",
        "documentation": {}
    },
    {
        "label": "min_height",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.min_height",
        "description": "algorithms.algorithms.tree.min_height",
        "peekOfCode": "def min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:",
        "detail": "algorithms.algorithms.tree.min_height",
        "documentation": {}
    },
    {
        "label": "print_tree",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.min_height",
        "description": "algorithms.algorithms.tree.min_height",
        "peekOfCode": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)\nif __name__ == '__main__':\n    tree = TreeNode(10)\n    tree.left = TreeNode(12)\n    tree.right = TreeNode(15)\n    tree.left.left  = TreeNode(25)",
        "detail": "algorithms.algorithms.tree.min_height",
        "documentation": {}
    },
    {
        "label": "has_path_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum",
        "description": "algorithms.algorithms.tree.path_sum",
        "peekOfCode": "def has_path_sum(root, sum):\n    \"\"\"\n    :type root: TreeNode\n    :type sum: int\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return False\n    if root.left is None and root.right is None and root.val == sum:\n        return True",
        "detail": "algorithms.algorithms.tree.path_sum",
        "documentation": {}
    },
    {
        "label": "has_path_sum2",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum",
        "description": "algorithms.algorithms.tree.path_sum",
        "peekOfCode": "def has_path_sum2(root, sum):\n    if root is None:\n        return False\n    stack = [(root, root.val)]\n    while stack:\n        node, val = stack.pop()\n        if node.left is None and node.right is None:\n            if val == sum:\n                return True\n        if node.left is not None:",
        "detail": "algorithms.algorithms.tree.path_sum",
        "documentation": {}
    },
    {
        "label": "has_path_sum3",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum",
        "description": "algorithms.algorithms.tree.path_sum",
        "peekOfCode": "def has_path_sum3(root, sum):\n    if root is None:\n        return False\n    queue = [(root, sum-root.val)]\n    while queue:\n        node, val = queue.pop(0)  # popleft\n        if node.left is None and node.right is None:\n            if val == 0:\n                return True\n        if node.left is not None:",
        "detail": "algorithms.algorithms.tree.path_sum",
        "documentation": {}
    },
    {
        "label": "path_sum",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum2",
        "description": "algorithms.algorithms.tree.path_sum2",
        "peekOfCode": "def path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res\ndef dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and root.val == sum:\n        ls.append(root.val)\n        res.append(ls)",
        "detail": "algorithms.algorithms.tree.path_sum2",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum2",
        "description": "algorithms.algorithms.tree.path_sum2",
        "peekOfCode": "def dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and root.val == sum:\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum-root.val, ls+[root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum-root.val, ls+[root.val], res)\n# DFS with stack\ndef path_sum2(root, s):",
        "detail": "algorithms.algorithms.tree.path_sum2",
        "documentation": {}
    },
    {
        "label": "path_sum2",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum2",
        "description": "algorithms.algorithms.tree.path_sum2",
        "peekOfCode": "def path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        node, ls = stack.pop()\n        if node.left is None and node.right is None and sum(ls) == s:\n            res.append(ls)\n        if node.left is not None:",
        "detail": "algorithms.algorithms.tree.path_sum2",
        "documentation": {}
    },
    {
        "label": "path_sum3",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.path_sum2",
        "description": "algorithms.algorithms.tree.path_sum2",
        "peekOfCode": "def path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        node, val, ls = queue.pop(0)  # popleft\n        if node.left is None and node.right is None and val == sum:\n            res.append(ls)\n        if node.left is not None:",
        "detail": "algorithms.algorithms.tree.path_sum2",
        "documentation": {}
    },
    {
        "label": "tree_print",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.pretty_print",
        "description": "algorithms.algorithms.tree.pretty_print",
        "peekOfCode": "def tree_print(tree):\n    for key in tree:\n        print(key, end=' ')  # end=' ' prevents a newline character\n        tree_element = tree[key]  # multiple lookups is expensive, even amortized O(1)!\n        for subElem in tree_element:\n            print(\" -> \", subElem, end=' ')\n            if type(subElem) != str:  # OP wants indenting after digits\n                print(\"\\n \")  # newline and a space to match indenting\n        print()  # forces a newline",
        "detail": "algorithms.algorithms.tree.pretty_print",
        "documentation": {}
    },
    {
        "label": "is_same_tree",
        "kind": 2,
        "importPath": "algorithms.algorithms.tree.same_tree",
        "description": "algorithms.algorithms.tree.same_tree",
        "peekOfCode": "def is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None and p.val == q.val:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n    return False\n# Time Complexity O(min(N,M))\n# where N and M are the number of nodes for the trees.\n# Space Complexity O(min(height1, height2))\n# levels of recursion is the mininum height between the two trees.",
        "detail": "algorithms.algorithms.tree.same_tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "algorithms.algorithms.tree.tree",
        "description": "algorithms.algorithms.tree.tree",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.left = None\n        self.right = None",
        "detail": "algorithms.algorithms.tree.tree",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "algorithms.algorithms.unionfind.count_islands",
        "description": "algorithms.algorithms.unionfind.count_islands",
        "peekOfCode": "class Solution(object):\n    def num_islands2(self, m, n, positions):\n        ans = []\n        islands = Union()\n        for p in map(tuple, positions):\n            islands.add(p)\n            for dp in (0, 1), (0, -1), (1, 0), (-1, 0):\n                q = (p[0] + dp[0], p[1] + dp[1])\n                if q in islands.id:\n                    islands.unite(p, q)",
        "detail": "algorithms.algorithms.unionfind.count_islands",
        "documentation": {}
    },
    {
        "label": "Union",
        "kind": 6,
        "importPath": "algorithms.algorithms.unionfind.count_islands",
        "description": "algorithms.algorithms.unionfind.count_islands",
        "peekOfCode": "class Union(object):\n    def __init__(self):\n        self.id = {}\n        self.sz = {}\n        self.count = 0\n    def add(self, p):\n        self.id[p] = p\n        self.sz[p] = 1\n        self.count += 1\n    def root(self, i):",
        "detail": "algorithms.algorithms.unionfind.count_islands",
        "documentation": {}
    },
    {
        "label": "full_path",
        "kind": 2,
        "importPath": "algorithms.algorithms.unix.path.full_path",
        "description": "algorithms.algorithms.unix.path.full_path",
        "peekOfCode": "def full_path(file):\n    return os.path.abspath(os.path.expanduser(file))",
        "detail": "algorithms.algorithms.unix.path.full_path",
        "documentation": {}
    },
    {
        "label": "join_with_slash",
        "kind": 2,
        "importPath": "algorithms.algorithms.unix.path.join_with_slash",
        "description": "algorithms.algorithms.unix.path.join_with_slash",
        "peekOfCode": "def join_with_slash(base, suffix):\n    # Remove / trailing\n    base = base.rstrip('/')\n    # Remove / leading\n    suffix = suffix.lstrip('/').rstrip()\n    full_path = \"{}/{}\".format(base, suffix)\n    return full_path",
        "detail": "algorithms.algorithms.unix.path.join_with_slash",
        "documentation": {}
    },
    {
        "label": "simplify_path_v1",
        "kind": 2,
        "importPath": "algorithms.algorithms.unix.path.simplify_path",
        "description": "algorithms.algorithms.unix.path.simplify_path",
        "peekOfCode": "def simplify_path_v1(path):\n    return os.path.abspath(path)\ndef simplify_path_v2(path):\n    stack, tokens = [], path.split(\"/\")\n    for token in tokens:\n        if token == \"..\" and stack:\n            stack.pop()\n        elif token != \"..\" and token != \".\" and token:\n            stack.append(token)\n    return \"/\" + \"/\".join(stack)",
        "detail": "algorithms.algorithms.unix.path.simplify_path",
        "documentation": {}
    },
    {
        "label": "simplify_path_v2",
        "kind": 2,
        "importPath": "algorithms.algorithms.unix.path.simplify_path",
        "description": "algorithms.algorithms.unix.path.simplify_path",
        "peekOfCode": "def simplify_path_v2(path):\n    stack, tokens = [], path.split(\"/\")\n    for token in tokens:\n        if token == \"..\" and stack:\n            stack.pop()\n        elif token != \"..\" and token != \".\" and token:\n            stack.append(token)\n    return \"/\" + \"/\".join(stack)",
        "detail": "algorithms.algorithms.unix.path.simplify_path",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "algorithms.algorithms.unix.path.simplify_path",
        "description": "algorithms.algorithms.unix.path.simplify_path",
        "peekOfCode": "path = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\nCorner Cases:\nDid you consider the case where path = \"/../\"?\nIn this case, you should return \"/\".\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\nReference: https://leetcode.com/problems/simplify-path/description/\n\"\"\"\nimport os",
        "detail": "algorithms.algorithms.unix.path.simplify_path",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "algorithms.algorithms.unix.path.simplify_path",
        "description": "algorithms.algorithms.unix.path.simplify_path",
        "peekOfCode": "path = \"/a/./b/../../c/\", => \"/c\"\nCorner Cases:\nDid you consider the case where path = \"/../\"?\nIn this case, you should return \"/\".\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\nReference: https://leetcode.com/problems/simplify-path/description/\n\"\"\"\nimport os\ndef simplify_path_v1(path):",
        "detail": "algorithms.algorithms.unix.path.simplify_path",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 2,
        "importPath": "algorithms.algorithms.unix.path.split",
        "description": "algorithms.algorithms.unix.path.split",
        "peekOfCode": "def split(path):\n    parts = []\n    split_part = path.rpartition('/')\n    # Takt the origin path without the last part\n    parts.append(split_part[0])\n    # Take the last element of list\n    parts.append(split_part[2])\n    return parts",
        "detail": "algorithms.algorithms.unix.path.split",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "extensions = ['sphinx.ext.autodoc',\n    'sphinx.ext.doctest',\n    'sphinx.ext.todo',\n    'sphinx.ext.coverage',\n    'sphinx.ext.mathjax',\n    'sphinx.ext.ifconfig',\n    'sphinx.ext.viewcode',\n    'sphinx.ext.githubpages']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "templates_path = ['_templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\nsource_parsers = {\n    '.md': CommonMarkParser\n}\nsource_suffix = ['.rst', '.md']\n# The master toctree document.\nmaster_doc = 'index'",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "source_parsers",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "source_parsers = {\n    '.md': CommonMarkParser\n}\nsource_suffix = ['.rst', '.md']\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 'algorithms'\ncopyright = '2018, Algorithms Team & Contributors'\nauthor = 'Algorithms Team & Contributors'",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "source_suffix = ['.rst', '.md']\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 'algorithms'\ncopyright = '2018, Algorithms Team & Contributors'\nauthor = 'Algorithms Team & Contributors'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = 'algorithms'\ncopyright = '2018, Algorithms Team & Contributors'\nauthor = 'Algorithms Team & Contributors'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "project = 'algorithms'\ncopyright = '2018, Algorithms Team & Contributors'\nauthor = 'Algorithms Team & Contributors'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '0.1.0'\n# The full version, including alpha/beta/rc tags.",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "copyright = '2018, Algorithms Team & Contributors'\nauthor = 'Algorithms Team & Contributors'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '0.1.0'\n# The full version, including alpha/beta/rc tags.\nrelease = '0.1.0'",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "author = 'Algorithms Team & Contributors'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '0.1.0'\n# The full version, including alpha/beta/rc tags.\nrelease = '0.1.0'\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "version = '0.1.0'\n# The full version, including alpha/beta/rc tags.\nrelease = '0.1.0'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "release = '0.1.0'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "language = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = []\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n# -- Options for HTML output ----------------------------------------------",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "exclude_patterns = []\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "todo_include_todos = True\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "html_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "html_static_path = ['_static']\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# This is required for the alabaster theme\n# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars\nhtml_sidebars = {\n    '**': [\n        'about.html',\n        'searchbox.html',",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "html_sidebars",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "html_sidebars = {\n    '**': [\n        'about.html',\n        'searchbox.html',\n        'navigation.html',\n        'relations.html',  # needs 'show_related': True theme option to display\n    ]\n}\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "htmlhelp_basename = 'algorithmsdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "latex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "latex_documents = [\n    (master_doc, 'algorithms.tex', 'algorithms Documentation',\n     'Algorithms Team \\\\& Contributors', 'manual'),\n]\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'algorithms', 'algorithms Documentation',\n     [author], 1)",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "man_pages = [\n    (master_doc, 'algorithms', 'algorithms Documentation',\n     [author], 1)\n]\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'algorithms', 'algorithms Documentation',",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "algorithms.docs.source.conf",
        "description": "algorithms.docs.source.conf",
        "peekOfCode": "texinfo_documents = [\n    (master_doc, 'algorithms', 'algorithms Documentation',\n     author, 'algorithms', 'One line description of project.',\n     'Miscellaneous'),\n]",
        "detail": "algorithms.docs.source.conf",
        "documentation": {}
    },
    {
        "label": "TestJosephus",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestJosephus(unittest.TestCase):\n    def test_josephus(self):\n        a = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n        josephus_generator = josephus(a, 3)\n        self.assertEqual(next(josephus_generator), '3')\n        self.assertEqual(next(josephus_generator), '6')\n        self.assertEqual(next(josephus_generator), '9')\n        self.assertEqual(next(josephus_generator), '4')\n        self.assertEqual(next(josephus_generator), '8')\n        self.assertEqual(next(josephus_generator), '5')",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestDeleteNth",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestDeleteNth(unittest.TestCase):\n    def test_delete_nth_naive(self):\n        self.assertListEqual(delete_nth_naive(\n                             [20, 37, 20, 21, 37, 21, 21], n=1),\n                             [20, 37, 21])\n        self.assertListEqual(delete_nth_naive(\n                             [1, 1, 3, 3, 7, 2, 2, 2, 2], n=3),\n                             [1, 1, 3, 3, 7, 2, 2, 2])\n        self.assertListEqual(delete_nth_naive(\n                             [1, 2, 3, 1, 1, 2, 1, 2, 3, 3, 2, 4, 5, 3, 1], n=3),",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestFlatten",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestFlatten(unittest.TestCase):\n    def test_flatten(self):\n        nested_list = [2, 1, [3, [4, 5], 6], 7, [8]]\n        flattened = flatten(nested_list)\n        self.assertEqual(flattened, [2, 1, 3, 4, 5, 6, 7, 8])\n        nested_list = [[3, [4, 5], 6], 7, [8]]\n        flattened = flatten(nested_list)\n        self.assertEqual(flattened, [3, 4, 5, 6, 7, 8])\n        nested_list = [[], [8]]\n        flattened = flatten(nested_list)",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestGarage",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestGarage(unittest.TestCase):\n    def test_garage(self):\n        initial = [1, 2, 3, 0, 4]\n        final = [0, 3, 2, 1, 4]\n        steps, seq = garage(initial, final)\n        self.assertEqual(steps, 4)\n        self.assertListEqual(seq, [[0, 2, 3, 1, 4],\n                                   [2, 0, 3, 1, 4],\n                                   [2, 3, 0, 1, 4],\n                                   [0, 3, 2, 1, 4]])",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestLongestNonRepeat",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestLongestNonRepeat(unittest.TestCase):\n    def test_longest_non_repeat_v1(self):\n        string = \"abcabcbb\"\n        self.assertEqual(longest_non_repeat_v1(string), 3)\n        string = \"bbbbb\"\n        self.assertEqual(longest_non_repeat_v1(string), 1)\n        string = \"pwwkew\"\n        self.assertEqual(longest_non_repeat_v1(string), 3)\n        string = \"dvdf\"\n        self.assertEqual(longest_non_repeat_v1(string), 3)",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMaxOnesIndex",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMaxOnesIndex(unittest.TestCase):\n    def test_max_ones_index(self):\n        self.assertEqual(9, max_ones_index([1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1]))\n        self.assertEqual(3, max_ones_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]))\n        self.assertEqual(-1, max_ones_index([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\nclass TestMergeInterval(unittest.TestCase):\n    def test_merge(self):\n        interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]\n        intervals = [Interval(i[0], i[1]) for i in interval_list]\n        merged_intervals = Interval.merge(intervals)",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMergeInterval",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMergeInterval(unittest.TestCase):\n    def test_merge(self):\n        interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]\n        intervals = [Interval(i[0], i[1]) for i in interval_list]\n        merged_intervals = Interval.merge(intervals)\n        self.assertEqual(\n            merged_intervals,\n            [Interval(1, 6), Interval(8, 10), Interval(15, 18)]\n        )\n    def test_merge_intervals(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMissingRanges",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMissingRanges(unittest.TestCase):\n    def test_missing_ranges(self):\n        arr = [3, 5, 10, 11, 12, 15, 19]\n        self.assertListEqual(missing_ranges(arr, 0, 20),\n                             [(0, 2), (4, 4), (6, 9),\n                              (13, 14), (16, 18), (20, 20)])\n        self.assertListEqual(missing_ranges(arr, 6, 100),\n                             [(6, 9), (13, 14), (16, 18), (20, 100)])\nclass TestMoveZeros(unittest.TestCase):\n    def test_move_zeros(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestMoveZeros",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestMoveZeros(unittest.TestCase):\n    def test_move_zeros(self):\n        self.assertListEqual(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \"a\"]),\n                             [False, 1, 1, 2, 1, 3, \"a\", 0, 0])\n        self.assertListEqual(move_zeros([0, 34, 'rahul', [], None, 0, True, 0]),\n                             [34, 'rahul', [], None, True, 0, 0, 0])\nclass TestPlusOne(unittest.TestCase):\n    def test_plus_one_v1(self):\n        self.assertListEqual(plus_one_v1([0]), [1])\n        self.assertListEqual(plus_one_v1([9]), [1, 0])",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestPlusOne",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestPlusOne(unittest.TestCase):\n    def test_plus_one_v1(self):\n        self.assertListEqual(plus_one_v1([0]), [1])\n        self.assertListEqual(plus_one_v1([9]), [1, 0])\n        self.assertListEqual(plus_one_v1([1, 0, 9]), [1, 1, 0])\n        self.assertListEqual(plus_one_v1([9, 9, 8, 0, 0, 9]),\n                             [9, 9, 8, 0, 1, 0])\n        self.assertListEqual(plus_one_v1([9, 9, 9, 9]),\n                             [1, 0, 0, 0, 0])\n    def test_plus_one_v2(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestRotateArray",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestRotateArray(unittest.TestCase):\n    def test_rotate_v1(self):\n        self.assertListEqual(rotate_v1([1, 2, 3, 4, 5, 6, 7], k=3),\n                                       [5, 6, 7, 1, 2, 3, 4])\n        self.assertListEqual(rotate_v1([1, 2, 3, 4, 5, 6, 7], k=1),\n                                       [7, 1, 2, 3, 4, 5, 6])\n        self.assertListEqual(rotate_v1([1, 2, 3, 4, 5, 6, 7], k=7),\n                                       [1, 2, 3, 4, 5, 6, 7])\n        self.assertListEqual(rotate_v1([1, 2], k=111), [2, 1])\n    def test_rotate_v2(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestSummaryRanges",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestSummaryRanges(unittest.TestCase):\n    def test_summarize_ranges(self):\n        self.assertListEqual(summarize_ranges([0, 1, 2, 4, 5, 7]),\n                             [(0, 2), (4, 5), (7, 7)])\n        self.assertListEqual(summarize_ranges([-5, -4, -3, 1, 2, 4, 5, 6]),\n                             [(-5, -3), (1, 2), (4, 6)])\n        self.assertListEqual(summarize_ranges([-2, -1, 0, 1, 2]),\n                             [(-2, 2)])\nclass TestThreeSum(unittest.TestCase):\n    def test_three_sum(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestThreeSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestThreeSum(unittest.TestCase):\n    def test_three_sum(self):\n        self.assertSetEqual(three_sum([-1, 0, 1, 2, -1, -4]),\n                            {(-1, 0, 1), (-1, -1, 2)})\n        self.assertSetEqual(three_sum([-1, 3, 1, 2, -1, -4, -2]),\n                            {(-4, 1, 3), (-2, -1, 3), (-1, -1, 2)})\nclass TestTwoSum(unittest.TestCase):\n    def test_two_sum(self):\n        self.assertTupleEqual((0, 2), two_sum([2, 11, 7, 9], target=9))\n        self.assertTupleEqual((0, 3), two_sum([-3, 5, 2, 3, 8, -9], target=0))",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestTwoSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestTwoSum(unittest.TestCase):\n    def test_two_sum(self):\n        self.assertTupleEqual((0, 2), two_sum([2, 11, 7, 9], target=9))\n        self.assertTupleEqual((0, 3), two_sum([-3, 5, 2, 3, 8, -9], target=0))\n        self.assertIsNone(two_sum([-3, 5, 2, 3, 8, -9], target=6))\nclass TestTrimmean(unittest.TestCase):\n    def test_trimmean(self):\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20), 5.5)\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 20), 6.0)\nclass TestTop1(unittest.TestCase):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestTrimmean",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestTrimmean(unittest.TestCase):\n    def test_trimmean(self):\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20), 5.5)\n        self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 20), 6.0)\nclass TestTop1(unittest.TestCase):\n    def test_top_1(self):\n        self.assertListEqual(top_1([1 , 1, 2, 2, 3]), [1, 2])\n        self.assertListEqual(top_1([1, 2, 3, 324, 234, 23, 23, 1, 23, 23]), [23])\nclass TestLimit(unittest.TestCase):\n    def test_limit(self):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestTop1",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestTop1(unittest.TestCase):\n    def test_top_1(self):\n        self.assertListEqual(top_1([1 , 1, 2, 2, 3]), [1, 2])\n        self.assertListEqual(top_1([1, 2, 3, 324, 234, 23, 23, 1, 23, 23]), [23])\nclass TestLimit(unittest.TestCase):\n    def test_limit(self):\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2, 4), [2, 3, 4])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2), [2, 3, 4, 5])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], None, 4), [1, 2, 3, 4])\nclass TestNSum(unittest.TestCase):",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestLimit",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestLimit(unittest.TestCase):\n    def test_limit(self):\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2, 4), [2, 3, 4])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], 2), [2, 3, 4, 5])\n        self.assertListEqual(limit([1, 2, 3, 4, 5], None, 4), [1, 2, 3, 4])\nclass TestNSum(unittest.TestCase):\n    def test_n_sum(self):\n        self.assertEqual(n_sum(2, [-3, 5, 2, 3, 8, -9], 6), [])  # noqa: E501\n        self.assertEqual(n_sum(3, [-5, -4, -3, -2, -1, 0, 1, 2, 3], 0), sorted([[-5,2,3],[-2,0,2],[-4,1,3],[-3,1,2],[-1,0,1],[-2,-1,3],[-3,0,3]]))  # noqa: E501\n        self.assertEqual(n_sum(3, [-1,0,1,2,-1,-4], 0), sorted([[-1,-1,2],[-1,0,1]]))  # noqa: E501",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestNSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_array",
        "description": "algorithms.tests.test_array",
        "peekOfCode": "class TestNSum(unittest.TestCase):\n    def test_n_sum(self):\n        self.assertEqual(n_sum(2, [-3, 5, 2, 3, 8, -9], 6), [])  # noqa: E501\n        self.assertEqual(n_sum(3, [-5, -4, -3, -2, -1, 0, 1, 2, 3], 0), sorted([[-5,2,3],[-2,0,2],[-4,1,3],[-3,1,2],[-1,0,1],[-2,-1,3],[-3,0,3]]))  # noqa: E501\n        self.assertEqual(n_sum(3, [-1,0,1,2,-1,-4], 0), sorted([[-1,-1,2],[-1,0,1]]))  # noqa: E501\n        self.assertEqual(n_sum(4, [1, 0, -1, 0, -2, 2], 0), sorted([[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]))  # noqa: E501\n        self.assertEqual(n_sum(4, [7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 6, 4, -3, -2], 10), sorted([[-6, 2, 7, 7], [-6, 3, 6, 7], [-6, 4, 5, 7], [-6, 4, 6, 6], [-5, 1, 7, 7], [-5, 2, 6, 7], [-5, 3, 5, 7], [-5, 3, 6, 6], [-5, 4, 4, 7], [-5, 4, 5, 6], [-4, 0, 7, 7], [-4, 1, 6, 7], [-4, 2, 5, 7], [-4, 2, 6, 6], [-4, 3, 4, 7], [-4, 3, 5, 6], [-4, 4, 4, 6], [-3, -1, 7, 7], [-3, 0, 6, 7], [-3, 1, 5, 7], [-3, 1, 6, 6], [-3, 2, 4, 7], [-3, 2, 5, 6], [-3, 3, 4, 6], [-3, 4, 4, 5], [-2, -2, 7, 7], [-2, -1, 6, 7], [-2, 0, 5, 7], [-2, 0, 6, 6], [-2, 1, 4, 7], [-2, 1, 5, 6], [-2, 2, 3, 7], [-2, 2, 4, 6], [-2, 3, 4, 5], [-1, 0, 4, 7], [-1, 0, 5, 6], [-1, 1, 3, 7], [-1, 1, 4, 6], [-1, 2, 3, 6], [-1, 2, 4, 5], [-1, 3, 4, 4], [0, 1, 2, 7], [0, 1, 3, 6], [0, 1, 4, 5], [0, 2, 3, 5], [0, 2, 4, 4], [1, 2, 3, 4]]))  # noqa: E501\n        self.assertEqual(n_sum(2, [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]], 0,  # noqa: E501\n                               sum_closure=lambda a, b: a[0] + b[0]),  # noqa: E501\n                         [[[-3, 0], [3, 3]], [[-2, 1], [2, 2]]])  # noqa: E501",
        "detail": "algorithms.tests.test_array",
        "documentation": {}
    },
    {
        "label": "TestDFA",
        "kind": 6,
        "importPath": "algorithms.tests.test_automata",
        "description": "algorithms.tests.test_automata",
        "peekOfCode": "class TestDFA(unittest.TestCase):\n    def test_DFA(self):\n        transitions = {\n            'a': {'1': 'a', '0': 'b'},\n            'b': {'1': 'b', '0': 'a'}\n        }\n        final=['a']\n        start = 'a'\n        self.assertEqual(False, DFA(transitions, start, final, \"000111100\"))\n        self.assertEqual(True, DFA(transitions, start, final, \"111000011\"))",
        "detail": "algorithms.tests.test_automata",
        "documentation": {}
    },
    {
        "label": "TestAddOperator",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestAddOperator(unittest.TestCase):\n    def test_add_operators(self):\n        # \"123\", 6 -> [\"1+2+3\", \"1*2*3\"]\n        s = \"123\"\n        target = 6\n        self.assertEqual(add_operators(s, target), [\"1+2+3\", \"1*2*3\"])\n        # \"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n        s = \"232\"\n        target = 8\n        self.assertEqual(add_operators(s, target), [\"2+3*2\", \"2*3+2\"])",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPermuteAndAnagram",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPermuteAndAnagram(unittest.TestCase):\n    def test_permute(self):\n        perms = ['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\n        self.assertEqual(perms, permute(\"abc\"))\n    def test_permute_iter(self):\n        it = permute_iter(\"abc\")\n        perms = ['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\n        for i in range(len(perms)):\n            self.assertEqual(perms[i], next(it))\n    def test_angram(self):",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestArrayCombinationSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestArrayCombinationSum(unittest.TestCase):\n    def test_array_sum_combinations(self):\n        A = [1, 2, 3, 3]\n        B = [2, 3, 3, 4]\n        C = [2, 3, 3, 4]\n        target = 7\n        answer = [[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3],\n                  [1, 3, 3], [1, 4, 2], [2, 2, 3], [2, 2, 3],\n                  [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n        answer.sort()",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestCombinationSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestCombinationSum(unittest.TestCase):\n    def check_sum(self, nums, target):\n        if sum(nums) == target:\n            return (True, nums)\n        else:\n            return (False, nums)\n    def test_combination_sum(self):\n        candidates1 = [2, 3, 6, 7]\n        target1 = 7\n        answer1 = [",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestFactorCombinations",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestFactorCombinations(unittest.TestCase):\n    def test_get_factors(self):\n        target1 = 32\n        answer1 = [\n            [2, 16],\n            [2, 2, 8],\n            [2, 2, 2, 4],\n            [2, 2, 2, 2, 2],\n            [2, 4, 4],\n            [4, 8]",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestFindWords",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestFindWords(unittest.TestCase):\n    def test_normal(self):\n        board = [\n             ['o', 'a', 'a', 'n'],\n             ['e', 't', 'a', 'e'],\n             ['i', 'h', 'k', 'r'],\n             ['i', 'f', 'l', 'v']\n        ]\n        words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n        self.assertEqual(find_words(board, words).sort(),",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestGenerateAbbreviations",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestGenerateAbbreviations(unittest.TestCase):\n    def test_generate_abbreviations(self):\n        word1 = \"word\"\n        answer1 = ['word', 'wor1', 'wo1d', 'wo2', 'w1rd', 'w1r1', 'w2d', 'w3',\n            '1ord', '1or1', '1o1d', '1o2', '2rd', '2r1', '3d', '4']\n        self.assertEqual(sorted(generate_abbreviations(word1)), sorted(answer1))\n        word2 = \"hello\"\n        answer2 = ['hello', 'hell1', 'hel1o', 'hel2', 'he1lo', 'he1l1', 'he2o',\n            'he3', 'h1llo', 'h1ll1', 'h1l1o', 'h1l2', 'h2lo', 'h2l1', 'h3o', 'h4',\n            '1ello', '1ell1', '1el1o', '1el2', '1e1lo', '1e1l1', '1e2o', '1e3',",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPatternMatch",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPatternMatch(unittest.TestCase):\n    def test_pattern_match(self):\n        pattern1 = \"abab\"\n        string1 = \"redblueredblue\"\n        pattern2 = \"aaaa\"\n        string2 = \"asdasdasdasd\"\n        pattern3 = \"aabb\"\n        string3 = \"xyzabcxzyabc\"\n        self.assertTrue(pattern_match(pattern1, string1))\n        self.assertTrue(pattern_match(pattern2, string2))",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestGenerateParenthesis",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestGenerateParenthesis(unittest.TestCase):\n    def test_generate_parenthesis(self):\n        self.assertEqual(generate_parenthesis_v1(2), ['()()', '(())'])\n        self.assertEqual(generate_parenthesis_v1(3), ['()()()', '()(())', '(())()', '(()())', '((()))'])\n        self.assertEqual(generate_parenthesis_v2(2), ['(())', '()()'])\n        self.assertEqual(generate_parenthesis_v2(3), ['((()))', '(()())', '(())()', '()(())', '()()()'])\nclass TestLetterCombinations(unittest.TestCase):\n    def test_letter_combinations(self):\n        digit1 = \"23\"\n        answer1 = [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestLetterCombinations",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestLetterCombinations(unittest.TestCase):\n    def test_letter_combinations(self):\n        digit1 = \"23\"\n        answer1 = [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n        self.assertEqual(sorted(letter_combinations(digit1)), sorted(answer1))\n        digit2 = \"34\"\n        answer2 = ['dg', 'dh', 'di', 'eg', 'eh', 'ei', 'fg', 'fh', 'fi']\n        self.assertEqual(sorted(letter_combinations(digit2)), sorted(answer2))\nclass TestPalindromicSubstrings(unittest.TestCase):\n    def test_palindromic_substrings(self):",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPalindromicSubstrings",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPalindromicSubstrings(unittest.TestCase):\n    def test_palindromic_substrings(self):\n        string1 = \"abc\"\n        answer1 = [['a', 'b', 'c']]\n        self.assertEqual(palindromic_substrings(string1), sorted(answer1))\n        string2 = \"abcba\"\n        answer2 = [['abcba'], ['a', 'bcb', 'a'], ['a', 'b', 'c', 'b', 'a']]\n        self.assertEqual(sorted(palindromic_substrings(string2)), sorted(answer2))\n        string3 = \"abcccba\"\n        answer3 = [['abcccba'], ['a', 'bcccb', 'a'], ['a', 'b', 'ccc', 'b', 'a'],",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPermuteUnique",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPermuteUnique(unittest.TestCase):\n    def test_permute_unique(self):\n        nums1 = [1, 1, 2]\n        answer1 = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]\n        self.assertEqual(sorted(permute_unique(nums1)), sorted(answer1))\n        nums2 = [1, 2, 1, 3]\n        answer2 = [[3, 1, 2, 1], [1, 3, 2, 1], [1, 2, 3, 1], [1, 2, 1, 3], [3, 2, 1, 1], \n            [2, 3, 1, 1], [2, 1, 3, 1], [2, 1, 1, 3], [3, 1, 1, 2], [1, 3, 1, 2], [1, 1, 3, 2], [1, 1, 2, 3]]\n        self.assertEqual(sorted(permute_unique(nums2)), sorted(answer2))\n        nums3 = [1, 2, 3]",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestPermute",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestPermute(unittest.TestCase):\n    def test_permute(self):\n        nums1 = [1, 2, 3, 4]\n        answer1 = [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4], [2, 3, 4, 1], [1, 3, 2, 4], \n            [3, 1, 2, 4], [3, 2, 1, 4], [3, 2, 4, 1], [1, 3, 4, 2], [3, 1, 4, 2], \n            [3, 4, 1, 2], [3, 4, 2, 1], [1, 2, 4, 3], [2, 1, 4, 3], [2, 4, 1, 3], \n            [2, 4, 3, 1], [1, 4, 2, 3], [4, 1, 2, 3], [4, 2, 1, 3], [4, 2, 3, 1], \n            [1, 4, 3, 2], [4, 1, 3, 2], [4, 3, 1, 2], [4, 3, 2, 1]]\n        self.assertEqual(sorted(permute(nums1)), sorted(answer1))\n        nums2 = [1, 2, 3]",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestSubsetsUnique",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestSubsetsUnique(unittest.TestCase):\n    def test_subsets_unique(self):\n        nums1 = [1, 2, 2]\n        answer1 = [(1, 2), (1,), (1, 2, 2), (2,), (), (2, 2)]\n        self.assertEqual(sorted(subsets_unique(nums1)), sorted(answer1))\n        nums2 = [1, 2, 3, 4]\n        answer2 = [(1, 2), (1, 3), (1, 2, 3, 4), (1,), (2,), (3,), (1, 4), (1, 2, 3), \n            (4,), (), (2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 4), (2, 4)]\n        self.assertEqual(sorted(subsets_unique(nums2)), sorted(answer2))\nclass TestSubsets(unittest.TestCase):",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestSubsets",
        "kind": 6,
        "importPath": "algorithms.tests.test_backtrack",
        "description": "algorithms.tests.test_backtrack",
        "peekOfCode": "class TestSubsets(unittest.TestCase):\n    def test_subsets(self):\n        nums1 = [1, 2, 3]\n        answer1 = [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n        self.assertEqual(sorted(subsets(nums1)), sorted(answer1))\n        nums2 = [1, 2, 3, 4]\n        answer2 = [[1, 2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 2], [1, 3, 4], \n            [1, 3], [1, 4], [1], [2, 3, 4], [2, 3], [2, 4], [2], [3, 4], [3], [4], []]\n        self.assertEqual(sorted(subsets(nums2)), sorted(answer2))\n    def test_subsets_v2(self):",
        "detail": "algorithms.tests.test_backtrack",
        "documentation": {}
    },
    {
        "label": "TestCountIslands",
        "kind": 6,
        "importPath": "algorithms.tests.test_bfs",
        "description": "algorithms.tests.test_bfs",
        "peekOfCode": "class TestCountIslands(unittest.TestCase):\n    def test_count_islands(self):\n        grid_1 = [[1,1,1,1,0], [1,1,0,1,0], [1,1,0,0,0], [0,0,0,0,0]]\n        self.assertEqual(1, count_islands(grid_1))\n        grid_2 = [[1,1,0,0,0], [1,1,0,0,0], [0,0,1,0,0], [0,0,0,1,1]]\n        self.assertEqual(3, count_islands(grid_2))\n        grid_3 = [[1,1,1,0,0,0], [1,1,0,0,0,0], [1,0,0,0,0,1], [0,0,1,1,0,1], [0,0,1,1,0,0]]\n        self.assertEqual(3, count_islands(grid_3))\n        grid_4 = [[1,1,0,0,1,1], [0,0,1,1,0,0], [0,0,0,0,0,1], [1,1,1,1,0,0]]\n        self.assertEqual(5, count_islands(grid_4))",
        "detail": "algorithms.tests.test_bfs",
        "documentation": {}
    },
    {
        "label": "TestMazeSearch",
        "kind": 6,
        "importPath": "algorithms.tests.test_bfs",
        "description": "algorithms.tests.test_bfs",
        "peekOfCode": "class TestMazeSearch(unittest.TestCase):\n    def test_maze_search(self):\n        grid_1 = [[1,0,1,1,1,1],[1,0,1,0,1,0],[1,0,1,0,1,1],[1,1,1,0,1,1]]\n        self.assertEqual(14, maze_search(grid_1))\n        grid_2 = [[1,0,0],[0,1,1],[0,1,1]]\n        self.assertEqual(-1, maze_search(grid_2))\nclass TestWordLadder(unittest.TestCase):\n    def test_ladder_length(self):\n        # hit -> hot -> dot -> dog -> cog\n        self.assertEqual(5, ladder_length('hit', 'cog', [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]))",
        "detail": "algorithms.tests.test_bfs",
        "documentation": {}
    },
    {
        "label": "TestWordLadder",
        "kind": 6,
        "importPath": "algorithms.tests.test_bfs",
        "description": "algorithms.tests.test_bfs",
        "peekOfCode": "class TestWordLadder(unittest.TestCase):\n    def test_ladder_length(self):\n        # hit -> hot -> dot -> dog -> cog\n        self.assertEqual(5, ladder_length('hit', 'cog', [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]))\n        # pick -> sick -> sink -> sank -> tank == 5\n        self.assertEqual(5, ladder_length('pick', 'tank',\n                                          ['tock', 'tick', 'sank', 'sink', 'sick']))\n        # live -> life == 1, no matter what is the word_list.\n        self.assertEqual(1, ladder_length('live', 'life', ['hoho', 'luck']))\n        # 0 length from ate -> ate",
        "detail": "algorithms.tests.test_bfs",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_bit",
        "description": "algorithms.tests.test_bit",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Initialize seed.\"\"\"\n        random.seed(\"test\")\n    def test_add_bitwise_operator(self):\n        self.assertEqual(5432 + 97823, add_bitwise_operator(5432, 97823))\n        self.assertEqual(0, add_bitwise_operator(0, 0))\n        self.assertEqual(10, add_bitwise_operator(10, 0))\n        self.assertEqual(10, add_bitwise_operator(0, 10))\n    def test_count_ones_recur(self):",
        "detail": "algorithms.tests.test_bit",
        "documentation": {}
    },
    {
        "label": "TestHuffmanCoding",
        "kind": 6,
        "importPath": "algorithms.tests.test_compression",
        "description": "algorithms.tests.test_compression",
        "peekOfCode": "class TestHuffmanCoding(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.file_in_name = \"huffman_coding_in.txt\"\n        cls.file_out_bin_name = \"huffman_coding_out.bin\"\n        cls.file_out_name = \"huffman_coding_out.txt\"\n    def setUp(self):\n        import random\n        random.seed(1951)\n        with open(self.file_in_name, \"wb\") as file_in:",
        "detail": "algorithms.tests.test_compression",
        "documentation": {}
    },
    {
        "label": "TestRLECompression",
        "kind": 6,
        "importPath": "algorithms.tests.test_compression",
        "description": "algorithms.tests.test_compression",
        "peekOfCode": "class TestRLECompression(unittest.TestCase):\n    def test_encode_rle(self):\n        self.assertEqual('12W1B12W3B24W1B14W',\n            encode_rle('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'))\n    def test_decode_rle(self):\n        self.assertEqual('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW', \n            decode_rle('12W1B12W3B24W1B14W'))\nclass TestEliasCoding(unittest.TestCase):\n    def test_elias_gamma(self):\n        correct_result = ['0', '00', '100', '101', '11000', '11001', '11010', '11011', '1110000', '1110001', '1110010']",
        "detail": "algorithms.tests.test_compression",
        "documentation": {}
    },
    {
        "label": "TestEliasCoding",
        "kind": 6,
        "importPath": "algorithms.tests.test_compression",
        "description": "algorithms.tests.test_compression",
        "peekOfCode": "class TestEliasCoding(unittest.TestCase):\n    def test_elias_gamma(self):\n        correct_result = ['0', '00', '100', '101', '11000', '11001', '11010', '11011', '1110000', '1110001', '1110010']\n        result = []\n        for i in range(11):\t\n            result.append(elias_gamma(i))\n        self.assertEqual(correct_result, result)\n    def test_elias_delta(self):\n        correct_result = ['0', '000', '1000', '1001', '10100', '10101', '10110', '10111', '11000000', '11000001', '11000010']\n        result = []",
        "detail": "algorithms.tests.test_compression",
        "documentation": {}
    },
    {
        "label": "TestAllFactors",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestAllFactors(unittest.TestCase):\n    def test_get_factors(self):\n        self.assertEqual([[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]],\n        get_factors(32))\n    def test_get_factors_iterative1(self):\n        self.assertEqual([[2, 16], [4, 8], [2, 2, 8], [2, 4, 4], [2, 2, 2, 4], [2, 2, 2, 2, 2]],\n        get_factors_iterative1(32))\n    def test_get_factors_iterative2(self):\n        self.assertEqual([[2, 2, 2, 2, 2], [2, 2, 2, 4], [2, 2, 8], [2, 4, 4], [2, 16], [4, 8]],\n        get_factors_iterative2(32))",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestCountIslands",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestCountIslands(unittest.TestCase):\n    def test_num_islands(self):\n        self.assertEqual(1, num_islands([[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]))\n        self.assertEqual(3, num_islands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]))\nclass TestPacificAtlantic(unittest.TestCase):\n    def test_pacific_atlantic(self):\n        self.assertEqual([[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]], \n            pacific_atlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]))\nclass TestSudoku(unittest.TestCase):\n    def test_sudoku_solver(self):",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestPacificAtlantic",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestPacificAtlantic(unittest.TestCase):\n    def test_pacific_atlantic(self):\n        self.assertEqual([[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]], \n            pacific_atlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]))\nclass TestSudoku(unittest.TestCase):\n    def test_sudoku_solver(self):\n        board = [[\"5\",\"3\",\".\"], [\"6\",\".\", \".\"],[\".\",\"9\",\"8\"]]\n        test_obj = Sudoku(board, 3, 3)\n        test_obj.solve()\n        self.assertEqual([['5', '3', '1'], ['6', '1', '2'], ['1', '9', '8']],test_obj.board)",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestSudoku",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestSudoku(unittest.TestCase):\n    def test_sudoku_solver(self):\n        board = [[\"5\",\"3\",\".\"], [\"6\",\".\", \".\"],[\".\",\"9\",\"8\"]]\n        test_obj = Sudoku(board, 3, 3)\n        test_obj.solve()\n        self.assertEqual([['5', '3', '1'], ['6', '1', '2'], ['1', '9', '8']],test_obj.board)\nclass TestWallsAndGates(unittest.TestCase):\n    def test_walls_and_gates(self):\n        rooms = [[float(\"inf\"), -1, 0, float(\"inf\")], \n                [float(\"inf\"), float(\"inf\"), float(\"inf\"), -1], ",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestWallsAndGates",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestWallsAndGates(unittest.TestCase):\n    def test_walls_and_gates(self):\n        rooms = [[float(\"inf\"), -1, 0, float(\"inf\")], \n                [float(\"inf\"), float(\"inf\"), float(\"inf\"), -1], \n                [float(\"inf\"), -1, float(\"inf\"), -1], \n                [0, -1, float(\"inf\"), float(\"inf\")]]\n        walls_and_gates(rooms)\n        self.assertEqual([[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]], rooms)\nclass TestMazeSearch(unittest.TestCase):\n    def test_maze_search(self):",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestMazeSearch",
        "kind": 6,
        "importPath": "algorithms.tests.test_dfs",
        "description": "algorithms.tests.test_dfs",
        "peekOfCode": "class TestMazeSearch(unittest.TestCase):\n    def test_maze_search(self):\n        maze_1 = [[1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1], [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1]]\n        self.assertEqual(37, find_path(maze_1))\n        maze_2 = [[1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1]]\n        self.assertEqual(14, find_path(maze_2))\n        maze_3 = [[1,0,0], [0,1,1], [0,1,1]]\n        self.assertEqual(-1, find_path(maze_3))\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "algorithms.tests.test_dfs",
        "documentation": {}
    },
    {
        "label": "TestBuySellStock",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestBuySellStock(unittest.TestCase):\n    def test_max_profit_naive(self):\n        self.assertEqual(max_profit_naive([7, 1, 5, 3, 6, 4]), 5)\n        self.assertEqual(max_profit_naive([7, 6, 4, 3, 1]), 0)\n    def test_max_profit_optimized(self):\n        self.assertEqual(max_profit_optimized([7, 1, 5, 3, 6, 4]), 5)\n        self.assertEqual(max_profit_optimized([7, 6, 4, 3, 1]), 0)\nclass TestClimbingStairs(unittest.TestCase):\n    def test_climb_stairs(self):\n        self.assertEqual(climb_stairs(2), 2)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestClimbingStairs",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestClimbingStairs(unittest.TestCase):\n    def test_climb_stairs(self):\n        self.assertEqual(climb_stairs(2), 2)\n        self.assertEqual(climb_stairs(10), 89)\n    def test_climb_stairs_optimized(self):\n        self.assertEqual(climb_stairs_optimized(2), 2)\n        self.assertEqual(climb_stairs_optimized(10), 89)\nclass TestCoinChange(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(count([1, 2, 3], 4), 4)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestCoinChange",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestCoinChange(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(count([1, 2, 3], 4), 4)\n        self.assertEqual(count([2, 5, 3, 6], 10), 5)\nclass TestCombinationSum(unittest.TestCase):\n    def test_combination_sum_topdown(self):\n        self.assertEqual(combination_sum_topdown([1, 2, 3], 4), 7)\n    def test_combination_sum_bottom_up(self):\n        self.assertEqual(combination_sum_bottom_up([1, 2, 3], 4), 7)\nclass TestEditDistance(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestCombinationSum",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestCombinationSum(unittest.TestCase):\n    def test_combination_sum_topdown(self):\n        self.assertEqual(combination_sum_topdown([1, 2, 3], 4), 7)\n    def test_combination_sum_bottom_up(self):\n        self.assertEqual(combination_sum_bottom_up([1, 2, 3], 4), 7)\nclass TestEditDistance(unittest.TestCase):\n    def test_edit_distance(self):\n        self.assertEqual(edit_distance('food', 'money'), 4)\n        self.assertEqual(edit_distance('horse', 'ros'), 3)\nclass TestEggDrop(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestEditDistance",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestEditDistance(unittest.TestCase):\n    def test_edit_distance(self):\n        self.assertEqual(edit_distance('food', 'money'), 4)\n        self.assertEqual(edit_distance('horse', 'ros'), 3)\nclass TestEggDrop(unittest.TestCase):\n    def test_egg_drop(self):\n        self.assertEqual(egg_drop(1, 2), 2)\n        self.assertEqual(egg_drop(2, 6), 3)\n        self.assertEqual(egg_drop(3, 14), 4)\nclass TestFib(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestEggDrop",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestEggDrop(unittest.TestCase):\n    def test_egg_drop(self):\n        self.assertEqual(egg_drop(1, 2), 2)\n        self.assertEqual(egg_drop(2, 6), 3)\n        self.assertEqual(egg_drop(3, 14), 4)\nclass TestFib(unittest.TestCase):\n    def test_fib_recursive(self):\n        self.assertEqual(fib_recursive(10), 55)\n        self.assertEqual(fib_recursive(30), 832040)\n    def test_fib_list(self):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestFib",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestFib(unittest.TestCase):\n    def test_fib_recursive(self):\n        self.assertEqual(fib_recursive(10), 55)\n        self.assertEqual(fib_recursive(30), 832040)\n    def test_fib_list(self):\n        self.assertEqual(fib_list(10), 55)\n        self.assertEqual(fib_list(30), 832040)\n    def test_fib_iter(self):\n        self.assertEqual(fib_iter(10), 55)\n        self.assertEqual(fib_iter(30), 832040)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestHosoyaTriangle",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestHosoyaTriangle(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file hosoya_triangle\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_hosoya(self):\n        self.assertEqual([1], hosoya_testing(1))\n        self.assertEqual([1,\n                         1, 1,",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestHouseRobber",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestHouseRobber(unittest.TestCase):\n    def test_house_robber(self):\n        self.assertEqual(44, house_robber([1, 2, 16, 3, 15, 3, 12, 1]))\nclass TestJobScheduling(unittest.TestCase):\n    def test_job_scheduling(self):\n        job1, job2 = Job(1, 3, 2), Job(2, 3, 4)\n        self.assertEqual(4, schedule([job1, job2]))\nclass TestKnapsack(unittest.TestCase):\n    def test_get_maximum_value(self):\n        item1, item2, item3 = Item(60, 10), Item(100, 20), Item(120, 30)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestJobScheduling",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestJobScheduling(unittest.TestCase):\n    def test_job_scheduling(self):\n        job1, job2 = Job(1, 3, 2), Job(2, 3, 4)\n        self.assertEqual(4, schedule([job1, job2]))\nclass TestKnapsack(unittest.TestCase):\n    def test_get_maximum_value(self):\n        item1, item2, item3 = Item(60, 10), Item(100, 20), Item(120, 30)\n        self.assertEqual(220, get_maximum_value([item1, item2, item3], 50))\n        item1, item2, item3, item4 = Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)\n        self.assertEqual(80, get_maximum_value([item1, item2, item3, item4], 5))",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestKnapsack",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestKnapsack(unittest.TestCase):\n    def test_get_maximum_value(self):\n        item1, item2, item3 = Item(60, 10), Item(100, 20), Item(120, 30)\n        self.assertEqual(220, get_maximum_value([item1, item2, item3], 50))\n        item1, item2, item3, item4 = Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)\n        self.assertEqual(80, get_maximum_value([item1, item2, item3, item4], 5))\nclass TestLongestIncreasingSubsequence(unittest.TestCase):\n    def test_longest_increasing_subsequence(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestLongestIncreasingSubsequence",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestLongestIncreasingSubsequence(unittest.TestCase):\n    def test_longest_increasing_subsequence(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestLongestIncreasingSubsequenceOptimized(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestLongestIncreasingSubsequenceOptimized2(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized2(self):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestLongestIncreasingSubsequenceOptimized",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestLongestIncreasingSubsequenceOptimized(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestLongestIncreasingSubsequenceOptimized2(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized2(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestIntDivide(unittest.TestCase):\n    def test_int_divide(self):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestLongestIncreasingSubsequenceOptimized2",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestLongestIncreasingSubsequenceOptimized2(unittest.TestCase):\n    def test_longest_increasing_subsequence_optimized2(self):\n        sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n        self.assertEqual(5, longest_increasing_subsequence(sequence))\nclass TestIntDivide(unittest.TestCase):\n    def test_int_divide(self):\n        self.assertEqual(5, int_divide(4))\n        self.assertEqual(42, int_divide(10))\n        self.assertEqual(204226, int_divide(50))\nclass Test_dp_K_Factor(unittest.TestCase):",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestIntDivide",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestIntDivide(unittest.TestCase):\n    def test_int_divide(self):\n        self.assertEqual(5, int_divide(4))\n        self.assertEqual(42, int_divide(10))\n        self.assertEqual(204226, int_divide(50))\nclass Test_dp_K_Factor(unittest.TestCase):\n    def test_kfactor(self):\n        #Test 1\n        n1=4\n        k1=1",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "Test_dp_K_Factor",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class Test_dp_K_Factor(unittest.TestCase):\n    def test_kfactor(self):\n        #Test 1\n        n1=4\n        k1=1\n        self.assertEqual(find_k_factor(n1,k1),1)\n        #Test 2\n        n2=7\n        k2=1\n        self.assertEqual(find_k_factor(n2,k2),70302)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestPlantingTrees",
        "kind": 6,
        "importPath": "algorithms.tests.test_dp",
        "description": "algorithms.tests.test_dp",
        "peekOfCode": "class TestPlantingTrees(unittest.TestCase):\n    def test_simple(self):\n        # arrange\n        trees = [0, 1, 10, 10]\n        L = 10\n        W = 1\n        # act\n        res = planting_trees(trees, L, W)\n        # assert\n        self.assertEqual(res, 2.414213562373095)",
        "detail": "algorithms.tests.test_dp",
        "documentation": {}
    },
    {
        "label": "TestTarjan",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestTarjan(unittest.TestCase):\n    \"\"\"\n    Test for the file tarjan.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_tarjan_example_1(self):\n        # Graph from https://en.wikipedia.org/wiki/File:Scc.png\n        example = {\n            'A': ['B'],",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestCheckBipartite",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestCheckBipartite(unittest.TestCase):\n    def test_check_bipartite(self):\n        adj_list_1 = [[0, 0, 1], [0, 0, 1], [1, 1, 0]]\n        self.assertEqual(True, check_bipartite(adj_list_1))\n        adj_list_2 = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n        self.assertEqual(True, check_bipartite(adj_list_2))\n        adj_list_3 = [[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]\n        self.assertEqual(False, check_bipartite(adj_list_3))\nclass TestDijkstra(unittest.TestCase):\n    def test_dijkstra(self):",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestDijkstra",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestDijkstra(unittest.TestCase):\n    def test_dijkstra(self):\n        g = Dijkstra(9) \n        g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], \n           [4, 0, 8, 0, 0, 0, 0, 11, 0], \n           [0, 8, 0, 7, 0, 4, 0, 0, 2], \n           [0, 0, 7, 0, 9, 14, 0, 0, 0], \n           [0, 0, 0, 9, 0, 10, 0, 0, 0], \n           [0, 0, 4, 14, 10, 0, 2, 0, 0], \n           [0, 0, 0, 0, 0, 2, 0, 1, 6], ",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestMaximumFlow",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestMaximumFlow(unittest.TestCase):\n    \"\"\"\n    Test for the file maximum_flow.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_ford_fulkerson(self):\n        capacity = [\n                [0, 10, 10, 0, 0, 0, 0],\n                [0, 0, 2, 0, 4, 8, 0],",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestMaximum_Flow_Bfs",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestMaximum_Flow_Bfs(unittest.TestCase):\n    \"\"\"\n    Test for the file def maximum_flow_bfs.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_maximum_flow_bfs(self):\n        graph = [\n            [0, 16, 13, 0, 0, 0],\n            [0, 0, 10, 12, 0, 0],",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestMaximum_Flow_Dfs",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestMaximum_Flow_Dfs(unittest.TestCase):\n    \"\"\"\n    Test for the file def maximum_flow_dfs.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_maximum_flow_dfs(self):\n        graph = [\n            [0, 16, 13, 0, 0, 0],\n            [0, 0, 10, 12, 0, 0],",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestAll_Pairs_Shortest_Path",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestAll_Pairs_Shortest_Path(unittest.TestCase):\n    def test_all_pairs_shortest_path(self):\n        graph = [[0, 0.1, 0.101, 0.142, 0.277], \n                 [0.465, 0, 0.191, 0.192, 0.587], \n                 [0.245, 0.554, 0, 0.333, 0.931], \n                 [1.032, 0.668, 0.656, 0, 0.151], \n                 [0.867, 0.119, 0.352, 0.398, 0]]\n        result = all_pairs_shortest_path(graph)\n        self.assertEqual(result, [\n          [0, 0.1, 0.101, 0.142, 0.277],",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestBellmanFord",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestBellmanFord(unittest.TestCase):\n    def test_bellman_ford(self):\n        graph1 = {\n            'a': {'b': 6, 'e': 7},\n            'b': {'c': 5, 'd': -4, 'e': 8},\n            'c': {'b': -2},\n            'd': {'a': 2, 'c': 7},\n            'e': {'b': -3}\n        }\n        self.assertEqual(True, bellman_ford(graph1, 'a'))",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestConnectedComponentInGraph",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class TestConnectedComponentInGraph(unittest.TestCase):    \n    \"\"\"\n     Class for testing different cases for connected components in graph\n    \"\"\"\n    def test_count_connected_components(self):\n        \"\"\"\n           Test Function that test the different cases of count connected components\n            2----------0    1--------5      3\n            |\n            |",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "PrimsMinimumSpanning",
        "kind": 6,
        "importPath": "algorithms.tests.test_graph",
        "description": "algorithms.tests.test_graph",
        "peekOfCode": "class PrimsMinimumSpanning(unittest.TestCase):\n    def test_prim_spanning(self):\n        graph1 = {\n            1 : [ [3, 2], [8, 3] ],\n            2 : [ [3, 1], [5, 4] ],\n            3 : [ [8, 1], [2, 4], [4, 5] ],\n            4 : [ [5, 2], [2, 3], [6, 5] ],\n            5 : [ [4, 3], [6, 4] ]\n        }\n        self.assertEqual(14, prims_minimum_spanning(graph1))",
        "detail": "algorithms.tests.test_graph",
        "documentation": {}
    },
    {
        "label": "TestBinaryHeap",
        "kind": 6,
        "importPath": "algorithms.tests.test_heap",
        "description": "algorithms.tests.test_heap",
        "peekOfCode": "class TestBinaryHeap(unittest.TestCase):\n    \"\"\"\n        Test suite for the binary_heap data structures\n    \"\"\"\n    def setUp(self):\n        self.min_heap = BinaryHeap()\n        self.min_heap.insert(4)\n        self.min_heap.insert(50)\n        self.min_heap.insert(7)\n        self.min_heap.insert(55)",
        "detail": "algorithms.tests.test_heap",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_heap",
        "description": "algorithms.tests.test_heap",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_get_skyline(self):\n        buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12],\n                     [15, 20, 10], [19, 24, 8]]\n        # Expect output\n        output = [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10],\n                  [20, 8], [24, 0]]\n        self.assertEqual(output, get_skyline(buildings))\n    def test_max_sliding_window(self):\n        nums = [1, 3, -1, -3, 5, 3, 6, 7]",
        "detail": "algorithms.tests.test_heap",
        "documentation": {}
    },
    {
        "label": "TestListsInHistogram",
        "kind": 6,
        "importPath": "algorithms.tests.test_histogram",
        "description": "algorithms.tests.test_histogram",
        "peekOfCode": "class TestListsInHistogram(unittest.TestCase):\n    def test_histogram(self):\n        list_1 = [3, 3, 2, 1]\n        list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7]\n        self.assertEqual(get_histogram(list_1), {1: 1, 2: 1, 3: 2})\n        self.assertEqual(get_histogram(list_2),\n                         {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1})\nif __name__ == '__main__':\n    unittest.main()",
        "detail": "algorithms.tests.test_histogram",
        "documentation": {}
    },
    {
        "label": "TestSegmentTree",
        "kind": 6,
        "importPath": "algorithms.tests.test_iterative_segment_tree",
        "description": "algorithms.tests.test_iterative_segment_tree",
        "peekOfCode": "class TestSegmentTree(unittest.TestCase):\n    \"\"\"\n    Test for the Iterative Segment Tree data structure\n    \"\"\"\n    def test_segment_tree_creation(self):\n        arr = [2, 4, 3, 6, 8, 9, 3]\n        max_segment_tree = SegmentTree(arr, max)\n        min_segment_tree = SegmentTree(arr, min)\n        sum_segment_tree = SegmentTree(arr, lambda a, b: a + b)\n        gcd_segment_tree = SegmentTree(arr, gcd)",
        "detail": "algorithms.tests.test_iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "algorithms.tests.test_iterative_segment_tree",
        "description": "algorithms.tests.test_iterative_segment_tree",
        "peekOfCode": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nclass TestSegmentTree(unittest.TestCase):\n    \"\"\"\n    Test for the Iterative Segment Tree data structure\n    \"\"\"\n    def test_segment_tree_creation(self):\n        arr = [2, 4, 3, 6, 8, 9, 3]",
        "detail": "algorithms.tests.test_iterative_segment_tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.tests.test_linkedlist",
        "description": "algorithms.tests.test_linkedlist",
        "peekOfCode": "class Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n# Convert from linked list Node to list for testing\ndef convert(head):\n    ret = []\n    if head:\n        current = head\n        while current:",
        "detail": "algorithms.tests.test_linkedlist",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_linkedlist",
        "description": "algorithms.tests.test_linkedlist",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def setUp(self):\n        # list test for palindrome\n        self.l = Node('A')\n        self.l.next = Node('B')\n        self.l.next.next = Node('C')\n        self.l.next.next.next = Node('B')\n        self.l.next.next.next.next = Node('A')\n        self.l1 = Node('A')\n        self.l1.next = Node('B')",
        "detail": "algorithms.tests.test_linkedlist",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "algorithms.tests.test_linkedlist",
        "description": "algorithms.tests.test_linkedlist",
        "peekOfCode": "def convert(head):\n    ret = []\n    if head:\n        current = head\n        while current:\n            ret.append(current.val)\n            current = current.next\n    return ret\nclass TestSuite(unittest.TestCase):\n    def setUp(self):",
        "detail": "algorithms.tests.test_linkedlist",
        "documentation": {}
    },
    {
        "label": "TestHashTable",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestHashTable(unittest.TestCase):\n    def test_one_entry(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        self.assertEqual('1', m.get(1))\n    def test_add_entry_bigger_than_table_size(self):\n        m = HashTable(10)\n        m.put(11, '1')\n        self.assertEqual('1', m.get(11))\n    def test_get_none_if_key_missing_and_hash_collision(self):",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestSeparateChainingHashTable",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestSeparateChainingHashTable(unittest.TestCase):\n    def test_one_entry(self):\n        m = SeparateChainingHashTable(10)\n        m.put(1, '1')\n        self.assertEqual('1', m.get(1))\n    def test_two_entries_with_same_hash(self):\n        m = SeparateChainingHashTable(10)\n        m.put(1, '1')\n        m.put(11, '11')\n        self.assertEqual('1', m.get(1))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestWordPattern",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestWordPattern(unittest.TestCase):\n    def test_word_pattern(self):\n        self.assertTrue(word_pattern(\"abba\", \"dog cat cat dog\"))\n        self.assertFalse(word_pattern(\"abba\", \"dog cat cat fish\"))\n        self.assertFalse(word_pattern(\"abba\", \"dog dog dog dog\"))\n        self.assertFalse(word_pattern(\"aaaa\", \"dog cat cat dog\"))\nclass TestIsSomorphic(unittest.TestCase):\n    def test_is_isomorphic(self):\n        self.assertTrue(is_isomorphic(\"egg\", \"add\"))\n        self.assertFalse(is_isomorphic(\"foo\", \"bar\"))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestIsSomorphic",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestIsSomorphic(unittest.TestCase):\n    def test_is_isomorphic(self):\n        self.assertTrue(is_isomorphic(\"egg\", \"add\"))\n        self.assertFalse(is_isomorphic(\"foo\", \"bar\"))\n        self.assertTrue(is_isomorphic(\"paper\", \"title\"))\nclass TestLongestPalindromicSubsequence(unittest.TestCase):\n    def test_longest_palindromic_subsequence_is_correct(self):\n        self.assertEqual(3,longest_palindromic_subsequence('BBABCBCAB'))\n        self.assertEqual(4,longest_palindromic_subsequence('abbaeae'))\n        self.assertEqual(7,longest_palindromic_subsequence('babbbababaa'))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestLongestPalindromicSubsequence",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestLongestPalindromicSubsequence(unittest.TestCase):\n    def test_longest_palindromic_subsequence_is_correct(self):\n        self.assertEqual(3,longest_palindromic_subsequence('BBABCBCAB'))\n        self.assertEqual(4,longest_palindromic_subsequence('abbaeae'))\n        self.assertEqual(7,longest_palindromic_subsequence('babbbababaa'))\n        self.assertEqual(4,longest_palindromic_subsequence('daccandeeja'))\n    def test_longest_palindromic_subsequence_is_incorrect(self):\n        self.assertNotEqual(4,longest_palindromic_subsequence('BBABCBCAB'))\n        self.assertNotEqual(5,longest_palindromic_subsequence('abbaeae'))\n        self.assertNotEqual(2,longest_palindromic_subsequence('babbbababaa'))",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestIsAnagram",
        "kind": 6,
        "importPath": "algorithms.tests.test_map",
        "description": "algorithms.tests.test_map",
        "peekOfCode": "class TestIsAnagram(unittest.TestCase):\n    def test_is_anagram(self):\n        self.assertTrue(is_anagram(\"anagram\", \"nagaram\"))\n        self.assertFalse(is_anagram(\"rat\", \"car\"))\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "algorithms.tests.test_map",
        "documentation": {}
    },
    {
        "label": "TestPower",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPower(unittest.TestCase):\n    \"\"\"\n    Test for the file power.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_power(self):\n        self.assertEqual(8, power(2, 3))\n        self.assertEqual(1, power(5, 0))\n        self.assertEqual(0, power(10, 3, 5))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestBaseConversion",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestBaseConversion(unittest.TestCase):\n    \"\"\"\n    Test for the file base_conversion.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_int_to_base(self):\n        self.assertEqual(\"101\", int_to_base(5, 2))\n        self.assertEqual(\"0\", int_to_base(0, 2))\n        self.assertEqual(\"FF\", int_to_base(255, 16))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestDecimalToBinaryIP",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestDecimalToBinaryIP(unittest.TestCase):\n    \"\"\"\n    Test for the file decimal_to_binary_ip.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_decimal_to_binary_ip(self):\n        self.assertEqual(\"00000000.00000000.00000000.00000000\",\n                         decimal_to_binary_ip(\"0.0.0.0\"))\n        self.assertEqual(\"11111111.11111111.11111111.11111111\",",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestEulerTotient",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestEulerTotient(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file euler_totient.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_euler_totient(self):\n        self.assertEqual(4, euler_totient(8))\n        self.assertEqual(12, euler_totient(21))\n        self.assertEqual(311040, euler_totient(674614))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestExtendedGcd",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestExtendedGcd(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file extended_gcd.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_extended_gcd(self):\n        self.assertEqual((0, 1, 2), extended_gcd(8, 2))\n        self.assertEqual((0, 1, 17), extended_gcd(13, 17))\nclass TestGcd(unittest.TestCase):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestGcd",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestGcd(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file gcd.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_gcd(self):\n        self.assertEqual(4, gcd(8, 12))\n        self.assertEqual(1, gcd(13, 17))\n    def test_gcd_non_integer_input(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestGenerateStroboGrammatic",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestGenerateStroboGrammatic(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file generate_strobogrammatic.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_gen_strobomatic(self):\n        self.assertEqual(['88', '11', '96', '69'], gen_strobogrammatic(2))\n    def test_strobogrammatic_in_range(self):\n        self.assertEqual(4, strobogrammatic_in_range(\"10\", \"100\"))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestIsStrobogrammatic",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestIsStrobogrammatic(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file is_strobogrammatic.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_strobogrammatic(self):\n        self.assertTrue(is_strobogrammatic(\"69\"))\n        self.assertFalse(is_strobogrammatic(\"14\"))\n    def test_is_strobogrammatic2(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestModularInverse",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestModularInverse(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file modular_Exponential.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_modular_inverse(self):\n        # checks if x * x_inv == 1 (mod m)\n        self.assertEqual(1, 2 * modular_inverse.modular_inverse(2, 19) % 19)\n        self.assertEqual(1, 53 * modular_inverse.modular_inverse(53, 91) % 91)",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestModularExponential",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestModularExponential(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file modular_Exponential.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_modular_exponential(self):\n        self.assertEqual(1, modular_exponential(5, 117, 19))\n        self.assertEqual(pow(1243, 65321, 10 ** 9 + 7),\n                         modular_exponential(1243, 65321, 10 ** 9 + 7))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestNextPerfectSquare",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestNextPerfectSquare(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file next_perfect_square.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_next_square(self):\n        self.assertEqual(36, find_next_square(25))\n        self.assertEqual(1, find_next_square(0))\n    def test_find_next_square2(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestPrimesSieveOfEratosthenes",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPrimesSieveOfEratosthenes(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file primes_sieve_of_eratosthenes.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_primes(self):\n        self.assertListEqual([2, 3, 5, 7], get_primes(7))\n        self.assertRaises(ValueError, get_primes, -42)\nclass TestPrimeTest(unittest.TestCase):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestPrimeTest",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPrimeTest(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file prime_test.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_prime_test(self):\n        \"\"\"\n            checks all prime numbers between 2 up to 100.\n            Between 2 up to 100 exists 25 prime numbers!",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestPythagoras",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestPythagoras(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file pythagoras.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_pythagoras(self):\n        self.assertEqual(\"Hypotenuse = 3.605551275463989\", pythagoras(3, 2, \"?\"))\nclass TestRabinMiller(unittest.TestCase):\n    \"\"\"[summary]",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestRabinMiller",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestRabinMiller(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rabin_miller.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_prime(self):\n        self.assertTrue(is_prime(7, 2))\n        self.assertTrue(is_prime(13, 11))\n        self.assertFalse(is_prime(6, 2))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestRSA",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestRSA(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rsa.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_encrypt_decrypt(self):\n        self.assertEqual(7, decrypt(encrypt(7, 23, 143), 47, 143))\n    # def test_key_generator(self):  # this test takes a while!\n    #     for i in range(100):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestCombination",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestCombination(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file combination.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_combination(self):\n        self.assertEqual(10, combination(5, 2))\n        self.assertEqual(252, combination(10, 5))\n    def test_combination_memo(self):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestFactorial",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestFactorial(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file factorial.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_factorial(self):\n        self.assertEqual(1, factorial(0))\n        self.assertEqual(120, factorial(5))\n        self.assertEqual(3628800, factorial(10))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestHailstone",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestHailstone(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file hailstone.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_hailstone(self):\n        self.assertEqual([8, 4, 2, 1], hailstone.hailstone(8))\n        self.assertEqual([10, 5, 16, 8, 4, 2, 1], hailstone.hailstone(10))\nclass TestCosineSimilarity(unittest.TestCase):",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestCosineSimilarity",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestCosineSimilarity(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file cosine_similarity.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_cosine_similarity(self):\n        vec_a = [1, 1, 1]\n        vec_b = [-1, -1, -1]\n        vec_c = [1, 2, -1]",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestFindPrimitiveRoot",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestFindPrimitiveRoot(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file find_primitive_root_simple.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_primitive_root_simple(self):\n        self.assertListEqual([0], find_primitive_root(1))\n        self.assertListEqual([2, 3], find_primitive_root(5))\n        self.assertListEqual([], find_primitive_root(24))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestFindOrder",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestFindOrder(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file find_order_simple.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_order_simple(self):\n        self.assertEqual(1, find_order(1, 1))\n        self.assertEqual(6, find_order(3, 7))\n        self.assertEqual(-1, find_order(128, 256))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestKrishnamurthyNumber",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestKrishnamurthyNumber(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file krishnamurthy_number.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_krishnamurthy_number(self):\n        self.assertFalse(krishnamurthy_number(0))\n        self.assertTrue(krishnamurthy_number(2))\n        self.assertTrue(krishnamurthy_number(1))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestMagicNumber",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestMagicNumber(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file find_order_simple.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_magic_number(self):\n        self.assertTrue(magic_number(50113))\n        self.assertTrue(magic_number(1234))\n        self.assertTrue(magic_number(100))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestDiffieHellmanKeyExchange",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestDiffieHellmanKeyExchange(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file diffie_hellman_key_exchange.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_find_order_simple(self):\n        self.assertFalse(diffie_hellman_key_exchange(3, 6))\n        self.assertTrue(diffie_hellman_key_exchange(3, 353))\n        self.assertFalse(diffie_hellman_key_exchange(5, 211))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestNumberOfDigits",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestNumberOfDigits(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file num_digits.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_num_digits(self):\n        self.assertEqual(2,num_digits(12))\n        self.assertEqual(5,num_digits(99999))\n        self.assertEqual(1,num_digits(8))",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestChineseRemainderSolver",
        "kind": 6,
        "importPath": "algorithms.tests.test_maths",
        "description": "algorithms.tests.test_maths",
        "peekOfCode": "class TestChineseRemainderSolver(unittest.TestCase):\n    def test_k_three(self):\n        # Example which should give the answer 143\n        # which is the smallest possible x that\n        # solves the system of equations\n        num = [3, 7, 10]\n        rem = [2, 3, 3]\n        self.assertEqual(chinese_remainder_theorem.solve_chinese_remainder(num, rem), 143)\n    def test_k_five(self):\n        # Example which should give the answer 3383",
        "detail": "algorithms.tests.test_maths",
        "documentation": {}
    },
    {
        "label": "TestBombEnemy",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestBombEnemy(unittest.TestCase):\n    def test_3x4(self):\n        grid1 = [\n            [\"0\", \"E\", \"0\", \"0\"],\n            [\"E\", \"0\", \"W\", \"E\"],\n            [\"0\", \"E\", \"0\", \"0\"]\n        ]\n        self.assertEqual(3, bomb_enemy.max_killed_enemies(grid1))\n        grid1 = [\n            [\"0\", \"E\", \"0\", \"E\"],",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestCopyTransform",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestCopyTransform(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file copy_transform.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_copy_transform(self):\n        self.assertEqual(copy_transform.rotate_clockwise(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\n        self.assertEqual(copy_transform.rotate_counterclockwise(",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestCroutMatrixDecomposition",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestCroutMatrixDecomposition(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file crout_matrix_decomposition.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_crout_matrix_decomposition(self):\n        self.assertEqual(([[9.0, 0.0], [7.0, 0.0]],\n                          [[1.0, 1.0], [0.0, 1.0]]),\n                         crout_matrix_decomposition.crout_matrix_decomposition(",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestCholeskyMatrixDecomposition",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestCholeskyMatrixDecomposition(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file cholesky_matrix_decomposition.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_cholesky_matrix_decomposition(self):\n        self.assertEqual([[2.0, 0.0, 0.0],\n                          [6.0, 1.0, 0.0],\n                          [-8.0, 5.0, 3.0]],",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestInversion",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestInversion(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file matrix_inversion.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_inversion(self):\n        from fractions import Fraction\n        m1 = [[1, 1], [1, 2]]\n        self.assertEqual(matrix_inversion.invert_matrix(m1),",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMatrixExponentiation",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestMatrixExponentiation(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file matrix_exponentiation.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_matrix_exponentiation(self):\n        mat = [[1, 0, 2], [2, 1, 0], [0, 2, 1]]\n        self.assertEqual(matrix_exponentiation.matrix_exponentiation(mat, 0),\n            [[1, 0, 0], [0, 1, 0], [0, 0, 1]])",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMultiply",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestMultiply(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file multiply.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_multiply(self):\n        self.assertEqual(multiply.multiply(\n            [[1, 2, 3], [2, 1, 1]], [[1], [2], [3]]), [[14], [7]])\nclass TestRotateImage(unittest.TestCase):",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestRotateImage",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestRotateImage(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rotate_image.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_rotate_image(self):\n        self.assertEqual(rotate_image.rotate(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\nclass TestSparseDotVector(unittest.TestCase):",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSparseDotVector",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSparseDotVector(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file sparse_dot_vector.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_sparse_dot_vector(self):\n        self.assertEqual(sparse_dot_vector.dot_product(sparse_dot_vector.vector_to_index_value_list(\n            [1., 2., 3.]), sparse_dot_vector.vector_to_index_value_list([0., 2., 2.])), 10)\nclass TestSpiralTraversal(unittest.TestCase):",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSpiralTraversal",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSpiralTraversal(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file spiral_traversal.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_spiral_traversal(self):\n        self.assertEqual(spiral_traversal.spiral_traversal(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [1, 2, 3, 6, 9, 8, 7, 4, 5])\nclass TestSudokuValidator(unittest.TestCase):",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSudokuValidator",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSudokuValidator(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file sudoku_validator.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_sudoku_validator(self):\n        self.assertTrue(\n            sudoku_validator.valid_solution(\n                [",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSumSubSquares",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSumSubSquares(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file sum_sub_squares.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_sum_sub_squares(self):\n        mat = [[1, 1, 1, 1, 1],\n               [2, 2, 2, 2, 2],\n               [3, 3, 3, 3, 3],",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestSortMatrixDiagonally",
        "kind": 6,
        "importPath": "algorithms.tests.test_matrix",
        "description": "algorithms.tests.test_matrix",
        "peekOfCode": "class TestSortMatrixDiagonally(unittest.TestCase):\n    def test_sort_diagonally(self):\n        mat = [\n            [3, 3, 1, 1],\n            [2, 2, 1, 2],\n            [1, 1, 1, 2]\n        ]\n        self.assertEqual(sort_matrix_diagonally.sort_diagonally(mat), [\n            [1, 1, 1, 1],\n            [1, 2, 2, 2],",
        "detail": "algorithms.tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestML",
        "kind": 6,
        "importPath": "algorithms.tests.test_ml",
        "description": "algorithms.tests.test_ml",
        "peekOfCode": "class TestML(unittest.TestCase):\n    def setUp(self):\n        # train set for the AND-function\n        self.trainSetAND = {(0,0) : 0, (0,1) :0, (1,0) : 0, (1,1) : 1} \n        # train set for light or dark colors\n        self.trainSetLight = {(11, 98, 237) : 'L', (3, 39, 96) : 'D', (242, 226, 12) : 'L', (99, 93, 4) : 'D',\n        (232, 62, 32) : 'L', (119, 28, 11) : 'D', (25, 214, 47) : 'L', (89, 136, 247) : 'L',\n        (21, 34, 63) : 'D', (237, 99, 120) : 'L', (73, 33, 39) : 'D'}\n    def test_nearest_neighbor(self):\n        # AND-function",
        "detail": "algorithms.tests.test_ml",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.m1 = Monomial({})\n\t\tself.m2 = Monomial({1: 1}, 2)\n\t\tself.m3 = Monomial({1: 2, 2: -1}, 1.5)\n\t\tself.m4 = Monomial({1: 1, 2: 2, 3: -2}, 3)\n\t\tself.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m1",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m1 = Monomial({})\n\t\tself.m2 = Monomial({1: 1}, 2)\n\t\tself.m3 = Monomial({1: 2, 2: -1}, 1.5)\n\t\tself.m4 = Monomial({1: 1, 2: 2, 3: -2}, 3)\n\t\tself.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m2",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m2 = Monomial({1: 1}, 2)\n\t\tself.m3 = Monomial({1: 2, 2: -1}, 1.5)\n\t\tself.m4 = Monomial({1: 1, 2: 2, 3: -2}, 3)\n\t\tself.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m3",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m3 = Monomial({1: 2, 2: -1}, 1.5)\n\t\tself.m4 = Monomial({1: 1, 2: 2, 3: -2}, 3)\n\t\tself.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m4",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m4 = Monomial({1: 1, 2: 2, 3: -2}, 3)\n\t\tself.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m5",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m5 = Monomial({2: 1, 3: 0}, Fraction(2, 3))\n\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m6",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m6 = Monomial({1: 0, 2: 0, 3: 0}, -2.27)\n\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m7",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m7 = Monomial({1: 2, 7: 2}, -math.pi)\n\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m8",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m8 = Monomial({150: 5, 170: 2, 10000:3}, 0)\n\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m9",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m9 = 2\n\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m10",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m10 = math.pi\n\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m11",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m11 = Fraction(3, 8)\n\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m12",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m12 = 0\n\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m1, self.m2)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m13",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m13 = Monomial({1: 1}, -2)\n\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m1, self.m2)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m3)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m14",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m14 = Monomial({1: 2}, 3)\n\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m1, self.m2)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m3)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m14)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m15",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m15 = Monomial({1: 1}, 3)\n\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m1, self.m2)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m3)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m14)\n\t\t# Additive inverses of each other should produce the zero monomial.",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m16",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m16 = Monomial({1: 2, 7: 2}, math.pi)\n\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m1, self.m2)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m3)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m14)\n\t\t# Additive inverses of each other should produce the zero monomial.\n\t\tself.assertEqual(self.m13 + self.m2, self.m1)",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m17",
        "kind": 5,
        "importPath": "algorithms.tests.test_monomial",
        "description": "algorithms.tests.test_monomial",
        "peekOfCode": "\t\tself.m17 = Monomial({1: -1})\n\tdef test_monomial_addition(self):\n\t\t# Monomials with different underlying variables or\n\t\t# even different power of those variables must not be added!\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m1, self.m2)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m3)\n\t\tself.assertRaises(ValueError, lambda x, y: x + y, self.m2, self.m14)\n\t\t# Additive inverses of each other should produce the zero monomial.\n\t\tself.assertEqual(self.m13 + self.m2, self.m1)\n\t\t# Zero monomial + Zero monomial = Zero monomial",
        "detail": "algorithms.tests.test_monomial",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.p0 = Polynomial([\n\t\t\tMonomial({})\n\t\t])\n\t\tself.p1 = Polynomial([\n\t\t\tMonomial({}), Monomial({})\n\t\t])\n\t\tself.p2 = Polynomial([\n\t\t\tMonomial({1: 1}, 2)",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p0",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p0 = Polynomial([\n\t\t\tMonomial({})\n\t\t])\n\t\tself.p1 = Polynomial([\n\t\t\tMonomial({}), Monomial({})\n\t\t])\n\t\tself.p2 = Polynomial([\n\t\t\tMonomial({1: 1}, 2)\n\t\t])\n\t\tself.p3 = Polynomial([",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p1",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p1 = Polynomial([\n\t\t\tMonomial({}), Monomial({})\n\t\t])\n\t\tself.p2 = Polynomial([\n\t\t\tMonomial({1: 1}, 2)\n\t\t])\n\t\tself.p3 = Polynomial([\n\t\t\tMonomial({1: 1}, 2),\n\t\t\tMonomial({1: 2, 2: -1}, 1.5)\n\t\t])",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p2",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p2 = Polynomial([\n\t\t\tMonomial({1: 1}, 2)\n\t\t])\n\t\tself.p3 = Polynomial([\n\t\t\tMonomial({1: 1}, 2),\n\t\t\tMonomial({1: 2, 2: -1}, 1.5)\n\t\t])\n\t\tself.p4 = Polynomial([\n\t\t\tMonomial({2: 1, 3: 0}, Fraction(2, 3)),\n\t\t\tMonomial({1: -1, 3: 2}, math.pi),",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p3",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p3 = Polynomial([\n\t\t\tMonomial({1: 1}, 2),\n\t\t\tMonomial({1: 2, 2: -1}, 1.5)\n\t\t])\n\t\tself.p4 = Polynomial([\n\t\t\tMonomial({2: 1, 3: 0}, Fraction(2, 3)),\n\t\t\tMonomial({1: -1, 3: 2}, math.pi),\n\t\t\tMonomial({1: -1, 3: 2}, 1)\n\t\t])\n\t\tself.p5 = Polynomial([",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p4",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p4 = Polynomial([\n\t\t\tMonomial({2: 1, 3: 0}, Fraction(2, 3)),\n\t\t\tMonomial({1: -1, 3: 2}, math.pi),\n\t\t\tMonomial({1: -1, 3: 2}, 1)\n\t\t])\n\t\tself.p5 = Polynomial([\n\t\t\tMonomial({150: 5, 170: 2, 10000:3}, 0),\n\t\t\tMonomial({1: -1, 3: 2}, 1),\t\n\t\t])\n\t\tself.p6 = Polynomial([",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p5",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p5 = Polynomial([\n\t\t\tMonomial({150: 5, 170: 2, 10000:3}, 0),\n\t\t\tMonomial({1: -1, 3: 2}, 1),\t\n\t\t])\n\t\tself.p6 = Polynomial([\n\t\t\t2,\n\t\t\t-3,\n\t\t\tFraction(1, 7),\n\t\t\t2**math.pi,\n\t\t\tMonomial({2: 3, 3: 1}, 1.25)",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p6",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p6 = Polynomial([\n\t\t\t2,\n\t\t\t-3,\n\t\t\tFraction(1, 7),\n\t\t\t2**math.pi,\n\t\t\tMonomial({2: 3, 3: 1}, 1.25)\n\t\t])\n\t\tself.p7 = Polynomial([\n\t\t\tMonomial({1: 1}, -2),\n\t\t\tMonomial({1: 2, 2: -1}, -1.5)",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.p7",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.p7 = Polynomial([\n\t\t\tMonomial({1: 1}, -2),\n\t\t\tMonomial({1: 2, 2: -1}, -1.5)\n\t\t])\n\t\tself.m1 = Monomial({1: 2, 2: 3}, -1)\n\t\treturn\n\tdef test_polynomial_addition(self):\n\t\t# The zero polynomials should add up to\n\t\t# itselves only.\n\t\tself.assertEqual(self.p0 + self.p1, self.p0)",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "\t\tself.m1",
        "kind": 5,
        "importPath": "algorithms.tests.test_polynomial",
        "description": "algorithms.tests.test_polynomial",
        "peekOfCode": "\t\tself.m1 = Monomial({1: 2, 2: 3}, -1)\n\t\treturn\n\tdef test_polynomial_addition(self):\n\t\t# The zero polynomials should add up to\n\t\t# itselves only.\n\t\tself.assertEqual(self.p0 + self.p1, self.p0)\n\t\tself.assertEqual(self.p0 + self.p1, self.p1)\n\t\t# Additive inverses should add up to the\n\t\t# zero polynomial.\n\t\tself.assertEqual(self.p3 + self.p7, self.p0)",
        "detail": "algorithms.tests.test_polynomial",
        "documentation": {}
    },
    {
        "label": "TestQueue",
        "kind": 6,
        "importPath": "algorithms.tests.test_queues",
        "description": "algorithms.tests.test_queues",
        "peekOfCode": "class TestQueue(unittest.TestCase):\n    \"\"\"\n        Test suite for the Queue data structures.\n    \"\"\"\n    def test_ArrayQueue(self):\n        queue = ArrayQueue()\n        queue.enqueue(1)\n        queue.enqueue(2)\n        queue.enqueue(3)\n        # test __iter__()",
        "detail": "algorithms.tests.test_queues",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_queues",
        "description": "algorithms.tests.test_queues",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_max_sliding_window(self):\n        array = [1, 3, -1, -3, 5, 3, 6, 7]\n        self.assertEqual(max_sliding_window(array, k=5), [5, 5, 6, 7])\n        self.assertEqual(max_sliding_window(array, k=3), [3, 3, 5, 5, 6, 7])\n        self.assertEqual(max_sliding_window(array, k=7), [6, 7])\n        array = [8, 5, 10, 7, 9, 4, 15, 12, 90, 13]\n        self.assertEqual(max_sliding_window(array, k=4), [10, 10, 10, 15, 15, 90, 90])\n        self.assertEqual(max_sliding_window(array, k=7), [15, 15, 90, 90])\n        self.assertEqual(max_sliding_window(array, k=2), [8, 10, 10, 9, 9, 15, 15, 90, 90])",
        "detail": "algorithms.tests.test_queues",
        "documentation": {}
    },
    {
        "label": "TestPriorityQueue",
        "kind": 6,
        "importPath": "algorithms.tests.test_queues",
        "description": "algorithms.tests.test_queues",
        "peekOfCode": "class TestPriorityQueue(unittest.TestCase):\n    \"\"\"Test suite for the PriorityQueue data structures.\n    \"\"\"\n    def test_PriorityQueue(self):\n        queue = PriorityQueue([3, 4, 1, 6])\n        self.assertEqual(4, queue.size())\n        self.assertEqual(1, queue.pop())\n        self.assertEqual(3, queue.size())\n        queue.push(2)\n        self.assertEqual(4, queue.size())",
        "detail": "algorithms.tests.test_queues",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_search",
        "description": "algorithms.tests.test_search",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_first_occurrence(self):\n        def helper(array, query):\n            idx = array.index(query) if query in array else None\n            return idx\n        array = [1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 6]\n        self.assertEqual(first_occurrence(array, 1), helper(array, 1))\n        self.assertEqual(first_occurrence(array, 3), helper(array, 3))\n        self.assertEqual(first_occurrence(array, 5), helper(array, 5))\n        self.assertEqual(first_occurrence(array, 6), helper(array, 6))",
        "detail": "algorithms.tests.test_search",
        "documentation": {}
    },
    {
        "label": "TestFindKeyboardRow",
        "kind": 6,
        "importPath": "algorithms.tests.test_set",
        "description": "algorithms.tests.test_set",
        "peekOfCode": "class TestFindKeyboardRow(unittest.TestCase):\n    def test_find_keyboard_row(self):\n        self.assertEqual([\"Alaska\", \"Dad\"],\n                         find_keyboard_row([\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]))",
        "detail": "algorithms.tests.test_set",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_sort",
        "description": "algorithms.tests.test_sort",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_bogo_sort(self):\n        self.assertTrue(is_sorted(bogo_sort([1, 23, 5])))\n    def test_bitonic_sort(self):\n        self.assertTrue(is_sorted(bitonic_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    def test_bubble_sort(self):\n        self.assertTrue(is_sorted(bubble_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    def test_comb_sort(self):\n        self.assertTrue(is_sorted(comb_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    def test_counting_sort(self):",
        "detail": "algorithms.tests.test_sort",
        "documentation": {}
    },
    {
        "label": "TestTopSort",
        "kind": 6,
        "importPath": "algorithms.tests.test_sort",
        "description": "algorithms.tests.test_sort",
        "peekOfCode": "class TestTopSort(unittest.TestCase):\n    def setUp(self):\n        self.depGraph = {\n                            \"a\" : [ \"b\" ],\n                            \"b\" : [ \"c\" ],\n                            \"c\" :  [ 'e'],\n                            'e' : [ 'g' ],\n                            \"d\" : [ ],\n                            \"f\" : [\"e\" , \"d\"],\n                            \"g\" : [ ]",
        "detail": "algorithms.tests.test_sort",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "kind": 2,
        "importPath": "algorithms.tests.test_sort",
        "description": "algorithms.tests.test_sort",
        "peekOfCode": "def is_sorted(array):\n    \"\"\"\n    Helper function to check if the given array is sorted.\n    :param array: Array to check if sorted\n    :return: True if sorted in ascending order, else False\n    \"\"\"\n    for i in range(len(array) - 1):\n        if array[i] > array[i + 1]:\n            return False\n    return True",
        "detail": "algorithms.tests.test_sort",
        "documentation": {}
    },
    {
        "label": "TestSuite",
        "kind": 6,
        "importPath": "algorithms.tests.test_stack",
        "description": "algorithms.tests.test_stack",
        "peekOfCode": "class TestSuite(unittest.TestCase):\n    def test_is_consecutive(self):\n        self.assertTrue(first_is_consecutive([3, 4, 5, 6, 7]))\n        self.assertFalse(first_is_consecutive([3, 4, 6, 7]))\n        self.assertFalse(first_is_consecutive([3, 2, 1]))\n        self.assertTrue(second_is_consecutive([3, 4, 5, 6, 7]))\n        self.assertFalse(second_is_consecutive([3, 4, 6, 7]))\n        self.assertFalse(second_is_consecutive([3, 2, 1]))\n    def test_is_sorted(self):\n        # Test case: bottom [6, 3, 5, 1, 2, 4] top",
        "detail": "algorithms.tests.test_stack",
        "documentation": {}
    },
    {
        "label": "TestStack",
        "kind": 6,
        "importPath": "algorithms.tests.test_stack",
        "description": "algorithms.tests.test_stack",
        "peekOfCode": "class TestStack(unittest.TestCase):\n    def test_ArrayStack(self):\n        stack = ArrayStack()\n        stack.push(1)\n        stack.push(2)\n        stack.push(3)\n        # test __iter__()\n        it = iter(stack)\n        self.assertEqual(3, next(it))\n        self.assertEqual(2, next(it))",
        "detail": "algorithms.tests.test_stack",
        "documentation": {}
    },
    {
        "label": "TestOrderedStack",
        "kind": 6,
        "importPath": "algorithms.tests.test_stack",
        "description": "algorithms.tests.test_stack",
        "peekOfCode": "class TestOrderedStack(unittest.TestCase):\n    def test_OrderedStack(self):\n        stack = OrderedStack()\n        self.assertTrue(stack.is_empty())\n        stack.push(1)\n        stack.push(4)\n        stack.push(3)\n        stack.push(6)\n        \"bottom - > 1 3 4 6 \"\n        self.assertEqual(6, stack.pop())",
        "detail": "algorithms.tests.test_stack",
        "documentation": {}
    },
    {
        "label": "TestMisraGreis",
        "kind": 6,
        "importPath": "algorithms.tests.test_streaming",
        "description": "algorithms.tests.test_streaming",
        "peekOfCode": "class TestMisraGreis(unittest.TestCase):\n    def test_misra_correct(self):\n        self.assertEqual({'4':5},misras_gries([1,4,4,4,5,4,4]))\n        self.assertEqual({'1':4},misras_gries([0,0,0,1,1,1,1]))\n        self.assertEqual({'0':4,'1':3},misras_gries([0,0,0,0,1,1,1,2,2],3))\n    def test_misra_incorrect(self):\n        self.assertEqual(None,misras_gries([1,2,5,4,5,4,4,5,4,4,5]))\n        self.assertEqual(None,misras_gries([0,0,0,2,1,1,1]))\n        self.assertEqual(None,misras_gries([0,0,0,1,1,1]))\nclass TestOneSparse(unittest.TestCase):",
        "detail": "algorithms.tests.test_streaming",
        "documentation": {}
    },
    {
        "label": "TestOneSparse",
        "kind": 6,
        "importPath": "algorithms.tests.test_streaming",
        "description": "algorithms.tests.test_streaming",
        "peekOfCode": "class TestOneSparse(unittest.TestCase):\n    def test_one_sparse_correct(self):\n        self.assertEqual(4,one_sparse([(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')]))\n        self.assertEqual(2,one_sparse([(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]))\n    def test_one_sparse_incorrect(self):\n        self.assertEqual(None,one_sparse([(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')])) #Two values remaining\n        self.assertEqual(None,one_sparse([(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'-'),(2,'-'),(2,'-'),(2,'-')])) # No values remaining\n        self.assertEqual(None,one_sparse([(2,'+'),(2,'+'),(4,'+'),(4,'+')])) # Bitsum sum of sign is inccorect",
        "detail": "algorithms.tests.test_streaming",
        "documentation": {}
    },
    {
        "label": "TestAddBinary",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestAddBinary(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file add_binary.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_add_binary(self):\n        self.assertEqual(\"100\", add_binary(\"11\", \"1\"))\n        self.assertEqual(\"101\", add_binary(\"100\", \"1\"))\n        self.assertEqual(\"10\", add_binary(\"1\", \"1\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestBreakingBad",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestBreakingBad(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file breaking_bad.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def setUp(self):\n        self.words = ['Amazon', 'Microsoft', 'Google']\n        self.symbols = ['i', 'Am', 'cro', 'le', 'abc']\n        self.result = ['M[i]crosoft', '[Am]azon', 'Mi[cro]soft', 'Goog[le]']",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestDecodeString",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestDecodeString(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file decode_string.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_decode_string(self):\n        self.assertEqual(\"aaabcbc\", decode_string(\"3[a]2[bc]\"))\n        self.assertEqual(\"accaccacc\", decode_string(\"3[a2[c]]\"))\nclass TestDeleteReoccurring(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestDeleteReoccurring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestDeleteReoccurring(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file delete_reoccurring.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_delete_reoccurring_characters(self):\n        self.assertEqual(\"abc\", delete_reoccurring_characters(\"aaabcccc\"))\nclass TestDomainExtractor(unittest.TestCase):\n    \"\"\"[summary]",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestDomainExtractor",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestDomainExtractor(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file domain_extractor.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_valid(self):\n        self.assertEqual(domain_name_1(\"https://github.com/SaadBenn\"), \"github\")\n    def test_invalid(self):\n        self.assertEqual(domain_name_2(\"http://google.com\"), \"google\")",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestEncodeDecode",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestEncodeDecode(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file encode_decode.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_encode(self):\n        self.assertEqual(\"4:keon2:is7:awesome\", encode(\"keon is awesome\"))\n    def test_decode(self):\n        self.assertEqual(['keon', 'is', 'awesome'], decode(\"4:keon2:is7:awesome\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestGroupAnagrams",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestGroupAnagrams(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file group_anagrams.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_group_anagrams(self):\n        self.assertEqual([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']], \\\n                         group_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]))\nclass TestIntToRoman(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestIntToRoman",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestIntToRoman(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file int_to_roman.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_int_to_roman(self):\n        self.assertEqual(\"DCXLIV\", int_to_roman(644))\n        self.assertEqual(\"I\", int_to_roman(1))\n        self.assertEqual(\"MMMCMXCIX\", int_to_roman(3999))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestIsPalindrome",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestIsPalindrome(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file is_palindrome.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_palindrome(self):\n        # 'Otto' is a old german name.\n        self.assertTrue(is_palindrome(\"Otto\"))\n        self.assertFalse(is_palindrome(\"house\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestIsRotated",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestIsRotated(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file is_rotated.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_rotated(self):\n        self.assertTrue(is_rotated(\"hello\", \"hello\"))\n        self.assertTrue(is_rotated(\"hello\", \"llohe\"))\n        self.assertFalse(is_rotated(\"hello\", \"helol\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRotated",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRotated(unittest.TestCase):\n    def test_rotate(self):\n        self.assertEqual(\"llohe\", rotate(\"hello\", 2))\n        self.assertEqual(\"hello\", rotate(\"hello\", 5))\n        self.assertEqual(\"elloh\", rotate(\"hello\", 6))\n        self.assertEqual(\"llohe\", rotate(\"hello\", 7))\n    def test_rotate_alt(self):\n        self.assertEqual(\"llohe\", rotate_alt(\"hello\", 2))\n        self.assertEqual(\"hello\", rotate_alt(\"hello\", 5))\n        self.assertEqual(\"elloh\", rotate_alt(\"hello\", 6))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestLicenseNumber",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestLicenseNumber(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file license_number.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_license_number(self):\n        self.assertEqual(\"a-b-c-d-f-d-d-f\", license_number(\"a-bc-dfd-df\", 1))\n        self.assertEqual(\"ab-cd-fd-df\", license_number(\"a-bc-dfd-df\", 2))\n        self.assertEqual(\"ab-cdf-ddf\", license_number(\"a-bc-dfd-df\", 3))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMakeSentence",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMakeSentence(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file make_sentence.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_make_sentence(self):\n        dictionarys = [\"\", \"app\", \"let\", \"t\", \"apple\", \"applet\"]\n        word = \"applet\"\n        self.assertTrue(make_sentence(word, dictionarys))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMergeStringChecker",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMergeStringChecker(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file merge_string_checker.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_merge_recursive(self):\n        self.assertTrue(is_merge_recursive(\"codewars\", \"cdw\", \"oears\"))\n    def test_is_merge_iterative(self):\n        self.assertTrue(is_merge_iterative(\"codewars\", \"cdw\", \"oears\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMultiplyStrings",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMultiplyStrings(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file multiply_strings.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_multiply(self):\n        self.assertEqual(\"23\", multiply(\"1\", \"23\"))\n        self.assertEqual(\"529\", multiply(\"23\", \"23\"))\n        self.assertEqual(\"0\", multiply(\"0\", \"23\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestOneEditDistance",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestOneEditDistance(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file one_edit_distance.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_is_one_edit(self):\n        self.assertTrue(is_one_edit(\"abc\", \"abd\"))\n        self.assertFalse(is_one_edit(\"abc\", \"aed\"))\n        self.assertFalse(is_one_edit(\"abcd\", \"abcd\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRabinKarp",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRabinKarp(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file rabin_karp.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_rabin_karp(self):\n        self.assertEqual(3, rabin_karp(\"abc\", \"zsnabckfkd\"))\n        self.assertEqual(None, rabin_karp(\"abc\", \"zsnajkskfkd\"))\nclass TestReverseString(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestReverseString",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestReverseString(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file reverse_string.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_recursive(self):\n        self.assertEqual(\"ereht olleh\", recursive(\"hello there\"))\n    def test_iterative(self):\n        self.assertEqual(\"ereht olleh\", iterative(\"hello there\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestReverseVowel",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestReverseVowel(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file reverse_vowel.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_reverse_vowel(self):\n        self.assertEqual(\"holle\", reverse_vowel(\"hello\"))\nclass TestReverseWords(unittest.TestCase):\n    \"\"\"[summary]",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestReverseWords",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestReverseWords(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file reverse_words.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_reverse_words(self):\n        self.assertEqual(\"pizza like I and kim keon am I\", \\\n                         reverse_words(\"I am keon kim and I like pizza\"))\nclass TestRomanToInt(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRomanToInt",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRomanToInt(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file roman_to_int.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_roman_to_int(self):\n        self.assertEqual(621, roman_to_int(\"DCXXI\"))\n        self.assertEqual(1, roman_to_int(\"I\"))\n        self.assertEqual(3999, roman_to_int(\"MMMCMXCIX\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestValidateCoordinates",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestValidateCoordinates(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file validate_coordinates.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_valid(self):\n        valid_coordinates = [\"-23, 25\", \"4, -3\", \"90, 180\", \"-90, -180\"]\n        for coordinate in valid_coordinates:\n            self.assertTrue(is_valid_coordinates_0(coordinate))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestWordSquares",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestWordSquares(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file word_squares.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_word_squares(self):\n        self.assertEqual([['wall', 'area', 'lead', 'lady'], ['ball', 'area', 'lead', 'lady']], \\\n                         word_squares([\"area\", \"lead\", \"wall\", \"lady\", \"ball\"]))\nclass TestUniqueMorse(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestUniqueMorse",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestUniqueMorse(unittest.TestCase):\n    def test_convert_morse_word(self):\n        self.assertEqual(\"--...-.\", convert_morse_word(\"gin\"))\n        self.assertEqual(\"--...--.\", convert_morse_word(\"msg\"))\n    def test_unique_morse(self):\n        self.assertEqual(2, unique_morse([\"gin\", \"zen\", \"gig\", \"msg\"]))\nclass TestJudgeCircle(unittest.TestCase):\n    def test_judge_circle(self):\n        self.assertTrue(judge_circle(\"UDLRUD\"))\n        self.assertFalse(judge_circle(\"LLRU\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestJudgeCircle",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestJudgeCircle(unittest.TestCase):\n    def test_judge_circle(self):\n        self.assertTrue(judge_circle(\"UDLRUD\"))\n        self.assertFalse(judge_circle(\"LLRU\"))\nclass TestStrongPassword(unittest.TestCase):\n    def test_strong_password(self):\n        self.assertEqual(3, strong_password(3, \"Ab1\"))\n        self.assertEqual(1, strong_password(11, \"#Algorithms\"))\nclass TestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestStrongPassword",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestStrongPassword(unittest.TestCase):\n    def test_strong_password(self):\n        self.assertEqual(3, strong_password(3, \"Ab1\"))\n        self.assertEqual(1, strong_password(11, \"#Algorithms\"))\nclass TestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):\n        self.assertEqual(\"Lipps_Asvph!\", caesar_cipher(\"Hello_World!\", 4))\n        self.assertEqual(\"okffng-Qwvb\", caesar_cipher(\"middle-Outz\", 2))\nclass TestCheckPangram(unittest.TestCase):\n    def test_check_pangram(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCaesarCipher",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):\n        self.assertEqual(\"Lipps_Asvph!\", caesar_cipher(\"Hello_World!\", 4))\n        self.assertEqual(\"okffng-Qwvb\", caesar_cipher(\"middle-Outz\", 2))\nclass TestCheckPangram(unittest.TestCase):\n    def test_check_pangram(self):\n        self.assertTrue(check_pangram(\"The quick brown fox jumps over the lazy dog\"))\n        self.assertFalse(check_pangram(\"The quick brown fox\"))\nclass TestContainString(unittest.TestCase):\n    def test_contain_string(self):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCheckPangram",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCheckPangram(unittest.TestCase):\n    def test_check_pangram(self):\n        self.assertTrue(check_pangram(\"The quick brown fox jumps over the lazy dog\"))\n        self.assertFalse(check_pangram(\"The quick brown fox\"))\nclass TestContainString(unittest.TestCase):\n    def test_contain_string(self):\n        self.assertEqual(-1, contain_string(\"mississippi\", \"issipi\"))\n        self.assertEqual(0, contain_string(\"Hello World\", \"\"))\n        self.assertEqual(2, contain_string(\"hello\", \"ll\"))\nclass TestCountBinarySubstring(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestContainString",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestContainString(unittest.TestCase):\n    def test_contain_string(self):\n        self.assertEqual(-1, contain_string(\"mississippi\", \"issipi\"))\n        self.assertEqual(0, contain_string(\"Hello World\", \"\"))\n        self.assertEqual(2, contain_string(\"hello\", \"ll\"))\nclass TestCountBinarySubstring(unittest.TestCase):\n    def test_count_binary_substring(self):\n        self.assertEqual(6, count_binary_substring(\"00110011\"))\n        self.assertEqual(4, count_binary_substring(\"10101\"))\n        self.assertEqual(3, count_binary_substring(\"00110\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCountBinarySubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCountBinarySubstring(unittest.TestCase):\n    def test_count_binary_substring(self):\n        self.assertEqual(6, count_binary_substring(\"00110011\"))\n        self.assertEqual(4, count_binary_substring(\"10101\"))\n        self.assertEqual(3, count_binary_substring(\"00110\"))\nclass TestCountBinarySubstring(unittest.TestCase):\n    def test_repeat_string(self):\n        self.assertEqual(3, repeat_string(\"abcd\", \"cdabcdab\"))\n        self.assertEqual(4, repeat_string(\"bb\", \"bbbbbbb\"))\nclass TestTextJustification(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestCountBinarySubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestCountBinarySubstring(unittest.TestCase):\n    def test_repeat_string(self):\n        self.assertEqual(3, repeat_string(\"abcd\", \"cdabcdab\"))\n        self.assertEqual(4, repeat_string(\"bb\", \"bbbbbbb\"))\nclass TestTextJustification(unittest.TestCase):\n    def test_text_justification(self):\n        self.assertEqual([\"This    is    an\",\n                          \"example  of text\",\n                          \"justification.  \"],\n                         text_justification([\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestTextJustification",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestTextJustification(unittest.TestCase):\n    def test_text_justification(self):\n        self.assertEqual([\"This    is    an\",\n                          \"example  of text\",\n                          \"justification.  \"],\n                         text_justification([\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n                                            , 16)\n                         )\n        self.assertEqual([\"What   must   be\",\n                          \"acknowledgment  \",",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestMinDistance",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestMinDistance(unittest.TestCase):\n    def test_min_distance(self):\n        self.assertEqual(2, min_distance(\"sea\", \"eat\"))\n        self.assertEqual(6, min_distance(\"abAlgocrithmf\", \"Algorithmmd\"))\nclass TestLongestCommonPrefix(unittest.TestCase):\n    def test_longest_common_prefix(self):\n        # Test first solution\n        self.assertEqual(\"fl\", longest_common_prefix_v1([\"flower\",\"flow\",\"flight\"]))\n        self.assertEqual(\"\", longest_common_prefix_v1([\"dog\",\"racecar\",\"car\"]))\n        # Test second solution",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestLongestCommonPrefix",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestLongestCommonPrefix(unittest.TestCase):\n    def test_longest_common_prefix(self):\n        # Test first solution\n        self.assertEqual(\"fl\", longest_common_prefix_v1([\"flower\",\"flow\",\"flight\"]))\n        self.assertEqual(\"\", longest_common_prefix_v1([\"dog\",\"racecar\",\"car\"]))\n        # Test second solution\n        self.assertEqual(\"fl\", longest_common_prefix_v2([\"flower\",\"flow\",\"flight\"]))\n        self.assertEqual(\"\", longest_common_prefix_v2([\"dog\",\"racecar\",\"car\"]))\n        # Test third solution\n        self.assertEqual(\"fl\", longest_common_prefix_v3([\"flower\",\"flow\",\"flight\"]))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestFirstUniqueChar",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestFirstUniqueChar(unittest.TestCase):\n    def test_first_unique_char(self):\n        self.assertEqual(0, first_unique_char(\"leetcode\"))\n        self.assertEqual(2, first_unique_char(\"loveleetcode\"))\nclass TestRepeatSubstring(unittest.TestCase):\n    def test_repeat_substring(self):\n        self.assertTrue(repeat_substring(\"abab\"))\n        self.assertFalse(repeat_substring(\"aba\"))\n        self.assertTrue(repeat_substring(\"abcabcabcabc\"))\nclass TestAtbashCipher(unittest.TestCase):",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestRepeatSubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestRepeatSubstring(unittest.TestCase):\n    def test_repeat_substring(self):\n        self.assertTrue(repeat_substring(\"abab\"))\n        self.assertFalse(repeat_substring(\"aba\"))\n        self.assertTrue(repeat_substring(\"abcabcabcabc\"))\nclass TestAtbashCipher(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file atbash_cipher.py\n    Arguments:\n        unittest {[type]} -- [description]",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestAtbashCipher",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestAtbashCipher(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file atbash_cipher.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_atbash_cipher(self):\n        self.assertEqual(\"zyxwvutsrqponml\", atbash(\"abcdefghijklmno\"))\n        self.assertEqual(\"KbgslM\", atbash(\"PythoN\"))\n        self.assertEqual(\"AttaCK at DawN\", atbash(\"ZggzXP zg WzdM\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestLongestPalindromicSubstring",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestLongestPalindromicSubstring(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file longest_palindromic_substring.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_longest_palindromic_substring(self):\n        self.assertEqual(\"bb\", longest_palindrome(\"cbbd\"))\n        self.assertEqual(\"abba\", longest_palindrome(\"abba\"))\n        self.assertEqual(\"asdadsa\", longest_palindrome(\"dasdasdasdasdasdadsa\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestKnuthMorrisPratt",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestKnuthMorrisPratt(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file knuth_morris_pratt.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_knuth_morris_pratt(self):\n        self.assertEqual([0, 1, 2, 3, 4], knuth_morris_pratt(\"aaaaaaa\", \"aaa\"))\n        self.assertEqual([0, 4], knuth_morris_pratt(\"abcdabc\", \"abc\"))\n        self.assertEqual([], knuth_morris_pratt(\"aabcdaab\", \"aba\"))",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "TestPanagram",
        "kind": 6,
        "importPath": "algorithms.tests.test_strings",
        "description": "algorithms.tests.test_strings",
        "peekOfCode": "class TestPanagram(unittest.TestCase):\n    \"\"\"[summary]\n    Test for the file panagram.py\n    Arguments:\n        unittest {[type]} -- [description]\n    \"\"\"\n    def test_empty_string(self):\n        # Arrange\n        string = \"\"\n        # Act",
        "detail": "algorithms.tests.test_strings",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass TestTraversal(unittest.TestCase):\n    def test_preorder(self):\n        tree = create_tree()\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder(tree))\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder_rec(tree))",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestTraversal",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestTraversal(unittest.TestCase):\n    def test_preorder(self):\n        tree = create_tree()\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder(tree))\n        self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder_rec(tree))\n    def test_postorder(self):\n        tree = create_tree()\n        self.assertEqual([25, 75, 50, 125, 175, 150, 100], postorder(tree))\n        self.assertEqual([25, 75, 50, 125, 175, 150, 100], postorder_rec(tree))\n    def test_inorder(self):",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestBTree",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestBTree(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        import random\n        random.seed(18719)\n        cls.random = random\n        cls.range = 10000\n    def setUp(self):\n        self.keys_to_insert = [self.random.randrange(-self.range, self.range) for i in range(self.range)]\n    def test_insertion_and_find_even_degree(self):",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestConstructTreePreorderPostorder",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestConstructTreePreorderPostorder(unittest.TestCase):\n    def test_construct_tree(self):\n        # Test 1\n        ctpp.pre_index = 0\n        pre1 = [1, 2, 4, 8, 9, 5, 3, 6, 7]\n        post1 = [8, 9, 4, 5, 2, 6, 7, 3, 1]\n        size1 = len(pre1)\n        self.assertEqual(ctpp.construct_tree(pre1, post1, size1), [8,4,9,2,5,1,6,3,7])\n        # Test 2\n        ctpp.pre_index = 0",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestFenwickTree",
        "kind": 6,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "class TestFenwickTree(unittest.TestCase):\n    def test_construct_tree_with_update_1(self):\n        freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]\n        ft = Fenwick_Tree(freq)\n        bit_tree = ft.construct()\n        self.assertEqual(12, ft.get_sum(bit_tree, 5))\n        freq[3] += 6\n        ft.update_bit(bit_tree, 3, 6)\n        self.assertEqual(18, ft.get_sum(bit_tree, 5))\n    def test_construct_tree_with_update_2(self):",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "create_tree",
        "kind": 2,
        "importPath": "algorithms.tests.test_tree",
        "description": "algorithms.tests.test_tree",
        "peekOfCode": "def create_tree():\n    n1 = Node(100)\n    n2 = Node(50)\n    n3 = Node(150)\n    n4 = Node(25)\n    n5 = Node(75)\n    n6 = Node(125)\n    n7 = Node(175)\n    n1.left, n1.right = n2, n3\n    n2.left, n2.right = n4, n5",
        "detail": "algorithms.tests.test_tree",
        "documentation": {}
    },
    {
        "label": "TestUnixPath",
        "kind": 6,
        "importPath": "algorithms.tests.test_unix",
        "description": "algorithms.tests.test_unix",
        "peekOfCode": "class TestUnixPath(unittest.TestCase):\n    def test_join_with_slash(self):\n        self.assertEqual(\"path/to/dir/file\", join_with_slash(\"path/to/dir/\", \"file\"))\n        self.assertEqual(\"path/to/dir/file\", join_with_slash(\"path/to/dir\", \"file\"))\n        self.assertEqual(\"http://algorithms/part\", join_with_slash(\"http://algorithms\", \"part\"))\n        self.assertEqual(\"http://algorithms/part\", join_with_slash(\"http://algorithms/\", \"part\"))\n    def test_full_path(self):\n        file_name = \"file_name\"\n        # Test full path relative\n        expect_path = \"{}/{}\".format(os.getcwd(), file_name)",
        "detail": "algorithms.tests.test_unix",
        "documentation": {}
    },
    {
        "label": "long_description",
        "kind": 2,
        "importPath": "algorithms.setup",
        "description": "algorithms.setup",
        "peekOfCode": "def long_description():\n    with io.open('README.md', 'r', encoding='utf-8') as f:\n        readme = f.read()\n    return readme\nsetup(name='algorithms',\n      version='0.1.4',\n      description='Pythonic Data Structures and Algorithms',\n      long_description=long_description(),\n      long_description_content_type=\"text/markdown\",\n      url='https://github.com/keon/algorithms',",
        "detail": "algorithms.setup",
        "documentation": {}
    }
]